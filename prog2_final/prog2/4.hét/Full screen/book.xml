

<book xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="hu" xsi:noNamespaceSchemaLocation="http://docbook.org/xsd/4.4/docbook.xsd">
 <!-- NE VÁLTOZTASD A DOKUMENTUM TÖRDELÉSÉT, MERT ELROMLIK A
TARTALMAZOTT FORRÁSOK, FORRÁSRÉSZLETEK TABULÁLÁSA! -->
       
        <title>Javát tanítok</title>
        <subtitle>Bevezetés a programozásba a Turing gépektől a CORBA technológiáig</subtitle>

        <bookinfo>
        
        <title>Javát tanítok</title>
        <subtitle>Bevezetés a programozásba a Turing gépektől a CORBA technológiáig</subtitle>
        
        <authorgroup>
        <author>
            <surname>Bátfai</surname>
            <firstname>Norbert</firstname>
            <affiliation>
                <orgname>
                    Debreceni Egyetem, Informatikai Kar, Alkalmazott 
                    Matematika és Valószínűségszámítás Tanszék
                </orgname>
                <address>
                    <email>nbatfai@inf.unideb.hu</email>
                </address>                
            </affiliation>
            <address>
                <street>Egyetem tér 1.</street>
                <city>Debrecen</city>
                <postcode>4032</postcode>
                <country>Magyarország</country>
                <email>nbatfai@inf.unideb.hu</email>
                <otheraddr><ulink url="http://www.inf.unideb.hu/~nbatfai">http://www.inf.unideb.hu/~nbatfai</ulink></otheraddr>
            </address>
        </author>

        <author>
            <surname>Juhász</surname>
            <firstname>István</firstname>
            <affiliation>
                <orgname>
                    Debreceni Egyetem, Informatikai Kar, 
                    Információ Technológia Tanszék
                </orgname>
                <address>
                    <email>pici@inf.unideb.hu</email>
                </address>
            </affiliation>
            <address>
                <street>Egyetem tér 1.</street>
                <city>Debrecen</city>
                <postcode>4032</postcode>
                <country>Magyarország</country>
                <email>pici@inf.unideb.hu</email>
                <otheraddr><ulink url="http://infotech.inf.unideb.hu/juhasz">http://infotech.inf.unideb.hu/juhasz</ulink></otheraddr>
            </address>
        </author>
                
        </authorgroup>
                
        <edition>Javát tanítok digitális szakkönyv, verzió 1.0.0</edition>
        
        <pubdate>2007</pubdate>
        
        <copyright>
            <year>2007</year>
            <holder>Bátfai Norbert, Juhász István</holder>
        </copyright>
        
        <legalnotice>
            <para>
                Copyright 2007, Bátfai Norbert, Juhász István. Ez a 
                digitális tartalom Kempelen Farkas Felsőoktatási Digitális 
                Tankönyvtár vagy más által közreadott digitális tartalom a 
                szerzői jogról szóló 1999. évi LXXVI. tv. 33.§ (4) bekezdésében 
                meghatározott oktatási, illetve tudományos kutatási célra 
                használható fel. A felhasználó a digitális tartalmat képernyőn 
                megjelenítheti, letöltheti, elektronikus adathordozóra vagy 
                papírra másolhatja, adatrögzítő rendszerében tárolhatja. 
                A Kempelen Farkas Felsőoktatási Digitális Tankönyvtár vagy 
                más weblapján található digitális tartalmak üzletszerű 
                felhasználása tilos, valamint kizárt a digitális tartalom 
                módosítása és átdolgozása, illetve az ilyen módon keletkezett 
                származékos anyag további felhasználása is.
            </para>
            <para>A jelen digitális tartalom internetes közreadását 
                a Nemzeti Kutatási és Technológiai Hivatal 2006-ban nyújtott 
                támogatása tette lehetővé.
            </para>			
        </legalnotice>
        
		<!-- revhistory kivéve -->
                
                
                
                
                
                
					

    </bookinfo>
    
    <dedication>
    <para>
        Keresztmamának.
    </para>   
                
    </dedication>

    <preface>        
    
        <prefaceinfo>
            <keywordset>
              <keyword>programozás</keyword>
              <keyword>programozási példák</keyword>
              <keyword>informatika tanítása</keyword>              
              <keyword>esettanulmányok</keyword>
              <keyword>Java esettanulmányok</keyword>                            
              <keyword>labirintus</keyword>                            
              <keyword>Java</keyword>                                          
              <keyword>Applet</keyword>                                          
              <keyword>MIDlet</keyword>
              <keyword>mobiltelefonos Java</keyword>
              <keyword>Servlet</keyword>
              <keyword>Java RMI</keyword>
              <keyword>CORBA</keyword>
              <keyword>elosztott programozás</keyword>
              <keyword>Windows</keyword>
              <keyword>Linux</keyword>
              <keyword>Fedora</keyword>
              <keyword>Bátfai Norbert</keyword>
              <keyword>Juhász István</keyword>
              <keyword>Bátfai</keyword>
              <keyword>Juhász</keyword>
            </keywordset>
        </prefaceinfo>
    
        <title>Bevezetés</title>

        <epigraph>
            <attribution>
                MÁTRIX
            </attribution>
            <para>
                „Ha a kéket veszed be... a játéknak vége. 
                Felébredsz az ágyadban, azt hiszel, amit hinni akarsz.
                De ha a pirosat: maradsz Csodaországban.
                És én megmutatom, milyen mély a nyúl ürege.”                    
            </para>
        </epigraph>

        <highlights>
            <para>
                Ebben a bevezető részben
                <itemizedlist>
					<listitem><para>röviden bemutatjuk a szerzőpárost</para></listitem>
					<listitem><para>olvashatjuk a szerzők előszavát</para></listitem>
                    <listitem><para>a könyv néhány javasolt használati esetét</para></listitem>                    
                    <listitem><para>a szereplő esettanulmányok koncepcionális szintű bemutatását</para></listitem>                    
                    <listitem><para>megtaláljuk itt a legfontosabb könyvjelzőket</para></listitem>
                    <listitem><para>megismerhetjük a könyvben használt jelöléseket</para></listitem>                                        
                </itemizedlist>                
            </para>                
        </highlights>
        
        
<sect1 id="szerzokrol">
   <title>A szerzőkről</title> 
   
                <para>            
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/elozetes/kep_bn.png" />
                    </imageobject>
                    <textobject>
                        <phrase>Bátfai Norbert</phrase>
                    </textobject>	
                </inlinemediaobject>                
                </para>

                <para>
                Bátfai Norbert 1996-ban szerzett programozó matematikusi, majd 1998-ban kitüntetéses programtervező matematikusi oklevelet a Debreceni Egyetemen, többek között éppen Juhász István tanítványaként. 1998-ban megnyerte a Java Szövetség Java Programozási Versenyét.                 
                </para>
                <para>
                Bátfai Erikával közös mobil-információtechnológiai cége, 
            az <ulink url="http://www.eurosmobil.hu/">Eurosmobil</ulink>, második helyezést ért el 2004-ben 
            a Motorola JavaJáték Versenyén, ugyancsak az Eurosmobil 2004-ben a Sun és a Nokia közös 
            Mobil Java Fejlesztői Versenyén a  
            <emphasis>Ha hívsz, támadok! - (H.A.H)</emphasis>
            hálózati (Java EE szerver, Java ME kliens) játéksorozattal első díjat nyert. 2005-ben az Eurosmobil
            képviseletében Bátfai Erikával
            <emphasis>A Java mobiljáték-fejlesztés elmélete és gyakorlata és a kék (JSR 82) játékok</emphasis> címmel
            előadott a Java 10. születésnapja alkalmával megrendezett 5. Sun Java Fejlesztői Napon.
                </para>
                <para>
            Társszerzője a 
            <emphasis>Fantasztikus programozás</emphasis>
            (<ulink url="http://javacska.lib.unideb.hu/">Jávácska Vortál</ulink>, 
            <ulink url="http://www.javacska.hu/">Jávácska Barátai</ulink>) című ismeretterjesztő 
            kalandregény sorozatnak. 
                </para>
                <para>            
            Jelenleg a 
            Debreceni Egyetem Informatikai Kara Alkalmazott 
            Matematika és Valószínűségszámítás Tanszékének munkatársa. 
            Oktatási tapasztalata az alábbi tárgyak gyakorlatain alapul: 
            Java esettanulmányok, J2SE hálózatok, Java appletek, CORBA, 
            Programozás, Hálózatok, Formális nyelvek és automaták, Algoritmuselmélet, 
            Bevezetés az informatikába, Operációs rendszerek, Alkalmazások fejlesztése WWW-re, 
            Objektumorientált programozás a középiskolában, Mobil programozás. 
                </para>
                <para>                        
            Szerzője a 
            <emphasis><ulink url="http://www.inf.unideb.hu/~nbatfai/ProgramozoPaternoszter.pdf">Programozó Páternoszter</ulink></emphasis>
            programozás jegyzetnek. </para>
            
                <para>            
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/elozetes/kep_ji.png" />
                    </imageobject>
                    <textobject>
                        <phrase>Juhász István</phrase>
                    </textobject>	
                </inlinemediaobject>                
                </para>

                <para>
Juhász István 1975-ben végzett a Kossuth Lajos Tudományegyetem matematika-fizika szakán, jelenleg a Debreceni Egyetem Informatikai Karának oktatója. 1982-ben egyetemi doktori címet szerzett. Kutatómunkáját a matematikai statisztika területén végezte. 
</para>
                <para>
1974 óta vesz részt az egyetemi oktatásban. Elsősorban programtervező informatikusokat, programozó matematikusokat, programtervező matematikusokat, informatika tanárokat, informatikus könyvtárosokat, matematikusokat, és matematika tanárokat tanított illetve tanít. Főbb oktatási területei: programozás, adatszerkezetek, adatmodellek, adatbázis-kezelő rendszerek, rendszerfejlesztési technológiák 
</para>
                <para>
Az egyetemen a kreditrendszerű képzés koncepciójának és a programtervező informatikus BSC szak illetve a programtervező informatikus MSC információs rendszerek szakirány egyik kidolgozója volt. 
</para>
                <para>
Rendszeresen foglalkozik TDK-s hallgatókkal. Az elmúlt években két első díjas és több helyezést elért dolgozat született a vezetésével. Tagja  az OTDK Informatika szekció Szakmai Bizottságának. 
</para>
                <para>
Az utóbbi években társszerzőkkel több könyvet írt és fordított, illetve lektorált és szerkesztett, elsősorban az információ technológia, az adatbázis-kezelés és a web területén. Írt két elektronikus jegyzetet is.
</para>
                <para>
Jelenlegi kutatási területei: objektumorientált és azon túli paradigmák, objektumorientált adatmodellek, komponens technológia, az informatika oktatásának didaktikai problémái.                 
				</para>
				
		</sect1>
        
        <sect1>
            <title>Előszó</title>
                        
            <para>A programozásra gondolva olykor valami misztikus érzés járja 
                át az embert, ami további hajtóerőt és lelkesedést kölcsönöz. A 
                sikeres oktatás elsődleges célja ennek átadása, ebből fejlődhet 
                majd ki minden más, ami csak kell: az ipar számára a 
                professzionális programozó, a tudománynak és az emberiségnek a 
                komplex problémákkal megküzdeni tudó algoritmuselmélész, az 
                egyénnek és a társadalomnak a boldog és tetterős polgár. 
                Reményeink szerint ennek az érzésnek az átadásához ezzel a 
                digitális szakkönyvvel mi is hozzá tudunk járulni, miközben 
                általában foglalkozunk a programozással, annak elméletével és filozófiájával, 
                majd részletesen és 
                gyakorlatiasan az objektumorientált paradigmával, és ezen belül a 
                Java programozással. 
            </para>
            <para>Minden OO programhoz kapcsolható egy sajátos világ, egy mikrokozmosz. A kisebb, egyszerűbb programok esetén ez a mikrokozmosz általában nem külön létező, hanem csupán egy már létező világ parányi, kiragadott része. A nagyobb, bonyolultabb programok esetén maga a program, azaz a programozó építheti fel ezt a mikrokozmoszt. Példaként tekintsünk egy labirintus játék programot, amiben a világ maga a labirintus, kincsestől, szörnyestől, hősöstől, a szokásos történettel: a hős bolyong, a szörnyek próbálják megenni, a kincs várja, hogy rábukkanjanak. Az OO programozás ereje abban rejlik, hogy a programozó a fejlesztés során rá van utalva, hogy saját világokat építsen, saját világokat teremtsen! Építőelemei a választott OO platform API interfészének osztályai, habarcsa pedig maga a választott OO nyelv. </para>
            <para>Ebben a kézikönyvben a Java nyelvvel egy labirintus játék világának felépítése során ismerkedünk meg, ami során ezt az egyszerű, példa labirintus játékot elkészítjük a weboldalon elhelyezhető appletként, mobiltelefonos és teljes képernyős PC-s, illetve hálózati: TCP/IP, Java Servlet, Java RMI és CORBA változatban is. De ezeken a labirintus témájú esettanulmányokon
            túl biológiai, matematikai és informatikai programozási példákkal is megismerkedhet majd a 
            kedves Olvasó.</para>
            <para>A könyvet elsősorban tanári kézikönyvként ajánljuk középiskolai informatikatanároknak, de kiegészítő irodalomként hasznos olvasmánynak tartjuk informatikus tanárjelöltek, diákok és általában a programozni tanulni 
            vágyók számára egyaránt.</para>
            <para>Bátfai Norbert</para>
            
            <sect2>
                <title>Bíztatás</title>
                <para>                
                    A kézikönyvet itt-ott felütve, a gyakorlati és az elméleti 
                    érdeklődésű Olvasót is
                    elbizonytalaníthatja egy-egy dolog azt illetően, hogy lelkesen
                    vesse bele magát az olvasásába.
                </para>
                <para>                
                    A gyakorlati érdeklődésűeknek meglepő lehet, hogy a programozás
                    alapjairól szóló részekben elméleti konstrukciókkal, 
                    például Turing gépekkel
                    találkoznak, amik esetleg korábbi tanulmányaik során nem váltak 
                    kedvenceikké,
                    vagy az is könnyen meglehet, hogy
                    egyáltalán nem is ismerik ezeket a gépeket.
                    Nekik mégis azt tanácsoljuk, ne hagyják ki ezeket a fejezeteket, mert nem 
                    öncélúan, hanem valódi élmények nyújtásának 
                    céljával tárgyaljuk
                    - ráadásul korántsem kimért matematikai, hanem gyakorlati és 
                    ismeretterjesztő szinten - ezeket a képzeletbeli gépeket. 
                    Olyan mentális élmények lesznek ezek,
                    amiket némi erőfeszítéssel bárki befogadhat, 
                    de a programozók, az informatikusok különösen könnyen, mivel ezek
                    az tézisek az ő gondolkodási paradigmáik szerint épülnek fel, 
                    mert alapfogalmuk a számítógépes program. S mi éppen e gyakorlati
                    megközelítéssel tárgyaljuk ezeket az emberi gondolkodást - 
                    programozói filozofálást - avagy a matematikai vénát messzire
                    elvezető alapfogalmakat.  
                </para>
                <para>
                    A másik, ami az elméleti érdeklődésűeket és 
                    a kevésbé gyakorlottakat lepheti meg, 
                    hogy a valódi programozási részekben olyan példákkal
                    találkozhatnak, melyek leginkább a haladó és nem
                    a bevezető kurzusok témái. Ilyen
                    témák például
                    a mobil, a hálózati vagy az elosztott programozás. De itt is
                    megnyugtathatjuk a kedves Olvasót, hogy bevezető szinten tárgyaljuk a
                    példákat, ahol nem a finomságokat akarjuk elemezni, hanem a lényeget
                    megmutatni. Ennek megfelelően persze megadunk további 
                    szakirodalmi 
                    hivatkozásokat,
                    ahol az itt érintett, haladóbb témák részleteiben is 
                    elmerülhetnek az érdeklődő Olvasók.
                </para>

				<sect3>
					<title>Előismeretek</title>
					<para>
					A kézikönyv gyakorlatias szemlélete a Java programozási részekben
					úgy jelenik meg, hogy inkább a szerzők adott Java akcentusát tükrözi, semmint
					a Java nyelvi utasítások, konstrukciók általános kimerítő tárgyalását.
					Annak a kedves Olvasónak, aki ezt hiányként éli meg, a kézikönyv 
					feldolgozása mellé bevezető könyvként a <citation>JAVA START</citation> vagy a 
					<citation>JAVA KÖNYV</citation> első kötetének elejét ajánljuk a figyelmébe.  
					</para>        
					
					<para>
Természetesen a könyv feltételezi a számítógépes alapismeretek meglétét, némi programozási ismeretet, az internet és a web használatát, de elsősorban a motivációra, az alkotni vágyásra és sok-sok gyakorlásra épít.					
					</para>        
					        
                </sect3>
                
            </sect2>
            
            <sect2 id="feldolgozas">
                <title>Javasolt használati esetek</title>
                
                <para> 
                    Az alábbi feldolgozási módokat javasoljuk, ha a kedves Olvasó
                    
                    <orderedlist numeration="lowerroman">
                        <listitem>
                            <para><emphasis>Középiskolai informatikatanár</emphasis>
                            </para>
                            <para>
                                Ha a kedves Olvasó már rendelkezik némi Java 
                                programozási tapasztalattal, akkor a 
                                kézikönyv folyamatos olvasása
                                nem okozhat gondot.
                            </para>
                            <para>
                                Ha az Olvasó még nem rendelkezik Java 
                                programozási tapasztalatokkal, s ez elbizonytalanítja,
                                akkor e bevezető részek elolvasása után
                                <emphasis><link linkend="elso_java">Az első Java tapasztalatok</link></emphasis>
                                című melléklet gyors feldolgozását javasoljuk. E
                                a pontnak nem küldetése a Java programozás bevezetése,
                                hiszen ezt a célt maga az egész kézikönyv célozta meg.
                                Célja viszont néhány egyszerű, de nem pofonegyszerű,
                                példa végigvitelével az Olvasó eme említett 
                                bizonytalanság érzésének
                                eloszlatása. Ha viszont a bizonytalanság érzése  
                                ezen az ágon mégsem jelenik meg, akkor itt is bátran
                                kezdje a folyamatos olvasást és kövesse a menet közben
                                szereplő feldolgozási utasításokat.
                            </para>
                        </listitem>
                        <listitem>
                            <para><emphasis>Informatikai jellegű szak felsőoktatásbeli hallgatója</emphasis>
                            </para>
                            <para>
                                Ha a kedves Olvasó már rendelkezik némi Java 
                                programozási tapasztalattal, akkor a folyamatos olvasás
                                itt sem okozhat gondot. Az esetlegesen mégis
                                felmerülő megértésbeli problémákat a hasonló érdeklődésű
                                csoporttársakkal való átbeszélés bizonyára
                                sikeresen orvosolja. Ezen az ágon az elméleti, a
                                <emphasis><link linkend="prog_papiron">Programozás papíron</link></emphasis>
                                című 
                                rész átolvasása után rögtön a 
                                <emphasis><link linkend="prog_gepen">Programozás gépen</link></emphasis>
                                című rész esettanulmányainak feldolgozását javasolhatjuk.
                                Ezen belül azt a tetszőleges témát, amely leginkább felkeltette
                                az Olvasó érdeklődését.
                            </para>
                            <para>
                                Ha az Olvasó még nem rendelkezik Java 
                                programozási tapasztalatokkal, akkor a kézikönyv szekvenciális 
                                feldolgozásával
                                párhuzamosan érdemes lehet egy bevezető Java kurzus
                                felvétele az Olvasó oktatási tanintézményében. A 
                                <emphasis><link linkend="prog_papiron">Programozás papíron</link></emphasis>
                                című rész elméleti meggondolásait pedig a Matematikai logika, 
                                Formális nyelvek és automaták vagy leginkább az Algoritmuselmélet című,
                                tartalmú kurzusok elvégzésével mélyítheti el.
                            </para>                            
                        </listitem>
                        <listitem>
                            <para><emphasis>Informatikai jellegű tárgy középiskolai tanulója</emphasis>
                            </para>
                            <para>
                                Ha a kedves Olvasó már rendelkezik némi Java 
                                programozási tapasztalattal, de a folyamatos olvasás
                                során mégis valamilyen megértésbeli gondja támad, akkor
                                barátaival való megbeszélése után
                                érdemes azt felvetnie informatikatanárának, 
                                szakkörvezetőjének, akitől bizonyára megkapja a 
                                megfelelő útbaigazítást.
                            </para>
                            <para>
                                Ha az Olvasó még nem rendelkezik Java 
                                programozási tapasztalatokkal, akkor a feldolgozást
                                <emphasis><link linkend="java_vilaga">A Java világa</link></emphasis>
                                című, a Java nyelvi programozást részletesen bevezető 
                                résszel javasoljuk kezdeni.
                            </para>                            
                        </listitem>
                    </orderedlist>
                    
                </para>
                
            <sect3 id="kilencven">
                <title>A még teljesen kezdő és csak a Java programozás
                  iránt érdeklődőkről szóló használati eset</title>
                  
                            <para>

								Ebben az esetben az alább belinkelt feldolgozási sorrendet javasoljuk pontosan követni a kedves Olvasónak.                            
							<orderedlist numeration="arabic">
								<listitem>
									<para><emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>										</para>
								</listitem>
								<listitem>
									<para><emphasis><link linkend="OO_vilag">Az OO világ, a programozó szűkebb hazája</link></emphasis>										</para>
								</listitem>
								<listitem>
									<para><emphasis><link linkend="java_platform">A Java platform</link></emphasis>
									</para>
								</listitem>
								<listitem>
									<para><emphasis><link linkend="elso_java_ford">Az első Java osztály lefordítása</link></emphasis>
									</para>
								</listitem>
								<listitem>
									<para><emphasis><link linkend="tortenet">Történet és oktatás</link></emphasis>
									</para>
								</listitem>
								<listitem>
									<para><emphasis><link linkend="java_OO">A Java OO világ</link></emphasis>
									</para>
								</listitem>
								<listitem>
									<para><emphasis><link linkend="se_oo">Java SE OO világ</link></emphasis>
									</para>
								</listitem>
								<listitem>
									<para><emphasis><link linkend="sajat_vilagok">Saját világok teremtése és Java alapok</link></emphasis>
									</para>
								</listitem>
								<listitem>
									<para><emphasis><link linkend="java_vilaga">A Java világa</link></emphasis> részletes feldolgozása
									</para>
								</listitem>
								<listitem>
									<para>A választott <emphasis><link linkend="java_esettanulmanyok">Java esettanulmányok</link></emphasis> feldolgozása
									</para>
								</listitem>
                            </orderedlist>
                            </para>
                                  
			</sect3>

            <sect3>
                <title>Csak a Java programozás oktatása
                  iránt érdeklődőkről szóló használati eset</title>
                  
                            <para>

								Ebben az esetben feltehetjük, hogy a kedves Olvasó már
								nem - az előző pontnak megfelelő - teljesen kezdő. Ekkor 
								az alább belinkelt feldolgozási sorrendet javasoljuk 
								követni.

							<orderedlist numeration="arabic">
								<listitem>
									<para><emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>										</para>
								</listitem>

								<listitem>
									<para><emphasis><link linkend="sajat_vilagok">Saját világok teremtése és Java alapok</link></emphasis>
									</para>
								</listitem>
								<listitem>
									<para><emphasis><link linkend="java_vilaga">A Java világa</link></emphasis> részletes feldolgozása
									</para>
								</listitem>
								<listitem>
									<para>A választott <emphasis><link linkend="java_esettanulmanyok">Java esettanulmányok</link></emphasis> feldolgozása
									</para>
								</listitem>
                            </orderedlist>
                            </para>
                                  
			</sect3>
                                    
            <sect3>
                <title>Szekvenciális feldolgozással kezdő, de ezt a Programozás
                papíron részben feladókról szóló használati eset</title>
                  
                            <para>
								Ebben az esetben feltehetőleg érdemben olvasni szerette volna az
								éppen  
								szereplő, de csupán megelőlegezett Java forrásokat is
								a kedves Olvasó. Ha
								 továbbra is ragaszkodik ehhez a folyamatosan 
								és mélyen megértő feldolgozási
								módhoz, akkor ugorjon az alább belinkelt részre és ennek
								feldolgozása után már könnyen legyőzi a most feltorlódott
								akadályokat. 

							<orderedlist numeration="arabic">
								<listitem>
									<para><emphasis><link linkend="sajat_vilagok">Saját világok teremtése és Java alapok</link></emphasis>
									</para>
								</listitem>
                            </orderedlist>
                            </para>
                                  
			</sect3>

            </sect2>
            
            <sect2>
                <title>Köszönet</title>            
                <para>Ez a kézikönyv a Nemzeti Kutatási és Technológiai Hivatal, DIGITÁLIS SZAKKÖNYV, DIGIT 2005 pályázat keretében készült el, ezért köszönetünket elsődlegesen ennek a támogatásnak kell címeznünk. Köszönjük továbbá a Debreceni Egyetem Informatikai Kar Információ Technológia Tanszékének és Alkalmazott Matematika és Valószínűségszámítás Tanszékének, mint a szerzők munkahelyeinek, hogy otthont adtak a pályázat teljesítésének és ezzel egyetemben lehetővé tették az egyetemi hálózat és gépek használatát. 
                Továbbá köszönjük az EUROSMOBIL-nak, hogy több szereplő, 
                de különösen a mobiltelefonos és a Linuxos 
                <hardware>Sun W1100Z Workstation</hardware> munkaállomáson futtatott példák 
                kipróbálásához és a kézikönyv kifejlesztéséhez a megfelelő infrastruktúrát a rendelkezésünkre bocsátotta. Végül itt is megköszönjük a lektorok: 
                Korotij Ágnes és Vágner Anikó munkáját.</para>
            </sect2>

            <sect2>
                <title>Figyelmeztetés</title>
                <caution>
                    <title>Nincs felelősségvállalás</title>
                    <para>A szerzők a példák elkészítésekor a legjobb tudásuk szerint jártak el, de előfordulhatnak, sőt bizonyára vannak is hibák a programokban, a könyvben. A programok és általában a könyv bármely felhasználásával kapcsolatba hozható esetleges károkért a szerzők semmilyen felelősséget nem vállalnak.</para>
                    <para>Még arra hívjuk fel az Olvasó figyelmét, hogy a szereplő példaprogramok oktatási céllal készültek, ezért tipikusan valami olyan tulajdonságot mutatnak, amit velük kapcsolatban a könyvben 
                    kiemelünk, feldolgozunk. Például a labirintus elosztott változata azt akarja megmutatni, hogy minden szereplő objektum külön számítógépen van. De ennél nem többet, ennek megfelelően nem foglalkozik például - az egyébként természetesen felmerülő - hálózati terheléssel, szinkronizációs problémákkal, hibakezeléssel, magas szereplőszám esetén a működőképességgel kapcsolatos kérdésekkel.</para>
                </caution>
            </sect2>
        
        <sect2>
            <title>Könyvjelzők</title>

            <sect3>			
                <title>Szervezési könyvjelzők</title>
                <orderedlist numeration="upperroman">
                    <listitem><para>A példaprogramok rövid 
                            <link linkend="pelda_bemutatas">
                                bemutatása</link></para>
                    </listitem>
                    <listitem><para>A példaprogramok <link linkend="pelda_csomagok">szervezése és forrásszövegek</link></para>
                    </listitem>
                </orderedlist>                
            </sect3>
            
            <sect3>			
                <title>Főbb tartalmi könyvjelzők</title>
                
                <para>
                A kézikönyv főbb tartalmi elemeit az alábbi felsorolásba linkeltük be. Az esettanulmányok példáitól eltérő
                további gyakorlati példákat egy későbbi pont alatt bontjuk ki bővebben.
			</para>
                
                <orderedlist numeration="upperroman">
                    <listitem>
                        <para>A programozás és a programozó gondolkodásának alapjai</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                                <para><link linkend="turing_gep">Turing gép</link></para>
                            </listitem>
                            <listitem>
                                <para><link linkend="megallas">Megállási (végtelen ciklus) probléma</link></para>
                            </listitem>
                            <listitem>
                                <para><link linkend="bonyolultsag">Chaitin-Kolmogorov-Solomonoff bonyolultság</link></para>
                            </listitem>
                            <listitem>
                                <para><link linkend="omega">Chaitin gépek és az Omega</link></para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>A programozás filogenetikája</para>
                        <!--
                        <orderedlist numeration="lowerroman">
                            <listitem>
                            <para><link linkend="java_csharp">A Java és a C Sharp összehasonlítása</link></para>
                            </listitem>
                        </orderedlist> 
                        -->                       
                    </listitem>
                    <listitem>
                        <para>A jövő programozása</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                            <para><link linkend="orch_or">A Penrose-Hameroff Orch OR tudatmodell</link></para>
                            </listitem>
                        </orderedlist>                        
                    </listitem>
                    <listitem>
                        <para>Bevezetés a Java programozásba</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                                <para><link linkend="sajat_labirintus">OO tervezés és egyben Java alapok</link></para>
                            </listitem>
                            <listitem>
                                <para><link linkend="sajat_vilagok">Java programfejlesztés</link></para>
                            </listitem>
                            <listitem>
                            <para><link linkend="tigris_delfin">Java újdonságok a Tigristől a Musztángon át a Delfinig</link></para>
                            </listitem>
                        </orderedlist>                                                
                    </listitem>
                    <listitem>
                        <para>Labirintusos Java esettanulmányok</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                                <para><link linkend="tiszta_oo">„Tiszta” OO implementálás</link></para>
                            </listitem>
                            <listitem>
                                <para><link linkend="labirintus_applet">Java Applet</link></para>
                            </listitem>
                            <listitem>
                                <para><link linkend="labirintus_jatek">Teljes képernyő - Full Screen Exclusive Mode</link></para>
                            </listitem>
                            <listitem>
                                <para><link linkend="labirintus_midlet">Java ME - mobil programozás</link></para>
                            </listitem>
                            <listitem>
                                <para>Szerveroldali Java</para>
                                    <orderedlist numeration="loweralpha">
                                        <listitem>
                                            <para><link linkend="labirintus_socket">java.net csomag</link></para>
                                        </listitem>
                                        <listitem>
                                            <para><link linkend="labirintus_servlet">Java Servlet</link></para>
                                        </listitem>
                                        <listitem>
                                            <para><link linkend="labirintus_rmi">Java RMI</link></para>
                                        </listitem>
                                        <listitem>
                                            <para><link linkend="labirintus_idl">Java IDL</link></para>
                                        </listitem>
                                    </orderedlist>
                                </listitem>
                                <listitem>
                                    <para><link linkend="elosztott_labirintus">CORBA - elosztott programozás heterogén OO környezetben</link></para>
                            </listitem>                            
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>További programozási példák</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                                <para>Biológiai témájú programok</para>
                                    <orderedlist numeration="loweralpha">
                                        <listitem>
                                        <para><link linkend="pontmatrix">Genomok, fehérjék összehasonlítása</link></para>
                                        </listitem>
                                    </orderedlist>                                
                            </listitem>
                            <listitem>
                                <para>Matematikai témájú programok</para>
                                    <orderedlist numeration="loweralpha">
                                        <listitem>
                                        <para><link linkend="mandelbrot_halmaz">Fraktálok nagyítása</link></para>
                                        </listitem>
                                        <listitem>
                                        <para><link linkend="conway">Sejtautomaták</link></para>
                                        </listitem>
                                        <listitem>
                                        <para><link linkend="pi_jegyei">A Pi hexadecimális jegyei</link></para>
                                        </listitem>                                        
                                        <listitem>
                                        <para><link linkend="galton_kiserlet">Galton deszkás kísérletek</link></para>
                                        </listitem>                                        
                                    </orderedlist>                                
                            </listitem>
                        </orderedlist>                        
                    </listitem>                    
                </orderedlist>
            </sect3>
            
            <sect3>			
                <title>Technikai könyvjelzők</title>
                
                <orderedlist numeration="upperroman">
                    <listitem>
                        <para>A Java SE, ME 
                        <link linkend="telepites">telepítése</link>
                        </para>
                    </listitem>
                    <listitem>
                        <para>A jegyzet példaprogramjainak 
                        <link linkend="pelda_futtatas">fordítása, futtatása</link></para>
                    </listitem>
                    <listitem>
                        <para>A jegyzet példaprogramjai forrásainak
                        <link linkend="forras_letoltes">letöltése</link></para>
                    </listitem>
                </orderedlist>
                
            </sect3>
        </sect2>
        
        </sect1>
        
        <sect1 id="pelda_bemutatas">
            <title>Előzetes a példaprogramokból</title>
            <blockquote>
                <attribution>Marx György</attribution>
                <para>„Minden számítógép-pedagógus tudja a világon, hogy játékokkal kell kezdeni.”</para>
            </blockquote>
            
            <para>
                Ebben a bevezető részben megtudjuk, milyen példákkal 
                ismerkedhetünk meg a kézikönyv forgatása során. Az anyagban            
                szereplő számos példára, kódrészletre igaz, hogy részei
                a jegyzethez készített, a következőkben felsorolt különböző 
                labirintus játékoknak. Az Olvasó alapértelmezésben, azaz a 
                folyamatos, szekvenciális
                olvasás során ugyanebben a sorrendben fog találkozni 
                ezekkel a programokkal. Javaslatunk, hogy  -  a példák 
                egymásra épülése és a könyv bevezető jellege miatt  -  ezen 
                sorrendtől ne térjen el a feldolgozás során, hacsak más
                iránymutatást nem kapott a korábbi 
                <emphasis><link linkend="feldolgozas">Javasolt használati esetek</link></emphasis>
                című pontban.
                
                <note>
                    <para>
                        Ebbe a szekvenciális olvasásba az is beletartozik, 
                        hogy az Olvasó tudásszintjétől függően arra kaphat 
                        utasítást, hogy egy részt éppen hagyjon ki és egy
                        másik rész feldolgozása után térjen ide vissza
                        vagy éppen ugorjon egy másik, valamit mélyebben
                        kibontó részre.
                    </para>
                </note>                 
                
            </para>
            
            <sect2>
                <title>Egygépes példák</title>
                
                <para>
                    Az egygépes példák, mint nevük is mutatja, a kézikönyvet
                    egyetlen gép mellett ülve feldolgozó Olvasóknak nyújtják a programozás
                    élményét. De ebbe a csokorba szedtük a labirintus 
                    appletes esettanulmányt
                    is. Nem csupán azért, mert egyszerű alkalmazásként is 
                    futtatható, sokkal inkább azért,
                    mert nem használ aktív hálózatkezelést; abban az
                    értelemben, hogy jelen programozói
                    nézőpontunkból, egy honlapról történő applet letöltést
                    passzív hálózatkezelésnek tekintünk.
                </para>
                
            <sect3>
                <title>A LabirintusVilág példa</title>
                
                <para>
                    <inlinemediaobject>
                        <objectinfo>
                            <title>A Labirintus Világ példa feladata a teremtett "tiszta"
                            OO labirintus világunk bemutatása, ennek megfelelően csupán
                            karakteres megjelenítést biztosít.</title>
                        </objectinfo>
                        <imageobject>
                            <imagedata fileref="images/elozetes/labirintus_vilag.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A karakteres kimenetű Labirintus Világ példa.</phrase>
                        </textobject>
                    </inlinemediaobject>
                    </para>
                    
                    <para>
                    Kezdetben elkészítjük labirintusunk világát: magát a labirintust, kincsestől, szörnyestől, hősöstől, a szokásos történettel: miszerint a hős bolyong, a szörnyek próbálják megenni, a kincs várja, hogy rábukkanjanak. A kézikönyv fő feladata megmutatni, hogyan meséljük el, 
                    mutassuk be ezt az elképzelt labirintus világot Java nyelven. Ha ezzel az elbeszéléssel, leírással elkészültünk, akkor ebben a példában, ebben a programban  -  avagy Java nyelven majd azt mondjuk: ebben a 
                    <classname>LabirintusVilág</classname> nevű osztályban  -  keltjük életre ezt az elbeszélést. Ennek megfelelően ez az osztály nem fogja csillogó grafikus felülettel felruházni elbeszélésünket, hanem csupán egy karakteres megjelenést ad majd, hogy megmutassa, hogyan kel életre ez a most teremtett tiszta OO mikrovilágunk: a labirintus. 
                </para>
                <para>A példaprogramokban a téma, a labirintus mikrovilágának életre keltése közös, de a megcélzott platformok és a létrehozott labirintusok funkcionális szintje már markánsan különböző. Ez utóbbira példa, hogy a jelen program a labirintus világának valóságát önálló idővel ruházza fel, azaz a labirintus világának valóságában az idő a játékostól, azaz a hős lépéseitől függetlenül telik, szemben például majd a következő példával, ahol a labirintus világának valóságában mindig csak akkor üt egyet az óra, ha a játékos, azaz a hős lép egyet. A platformok különbözősége kapcsán arra gondoljunk, hogy a példák között van Java SE, Java ME, Java EE platformra és CORBA architektúrára készített program is. A Java SE a Java alapkiadása, egyelőre elég annyi róla, hogy abban az esetben, ha nem tudjuk, hogy az aktuálisan írt Java programunkat mégis éppen milyen platformra kéne felkészítenünk, akkor valószínűleg az alapkiadásra, 
                azaz a Java SE kiadásra, a Java sztenderd kiadásra van szükségünk.</para>
                
            </sect3>
            
            <sect3>
                <title>A LabirintusApplet példa</title>
                
                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/elozetes/labirintus_applet.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Labirintus Applet példa.</phrase>
                        </textobject>	
                    </inlinemediaobject>                    
                    </para>
                    
                    <para>
                    Ez az osztály a labirintus mikrovilágának egy appletbeli életre keltésére ad példát. 
                    Az <classname>Applet</classname> objektumok azok a Java SE platformbeli objektumok, akik képesek a böngészőkben létezni, s mint ilyenek megjelenni az internetes weblapokon. Ezzel, mintegy varázsütésre teremtett labirintus mikrovilágunk már nemcsak a mi PC-nken létezhet, hanem bármely olyan internetes gép böngészőjében, amelyről ezt az appletünket letöltik. További érdekessége a példának, hogy önálló alkalmazásként való futtatásra is felkészítettük.
                </para>
                <para>Ennek a példának nincs önálló időbeli fejlődése, hanem csupán a játékos lépéseitől függő, azaz mondhatjuk, hogy a program futását a játékostól érkező események irányítják. Viszont a labirintus megjelenítése már grafikus.</para>
                
            </sect3>
            
            <sect3>
                <title>A LabirintusJáték példa</title>
                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/elozetes/labirintus_jatek.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A teljes képernyős Labirintus Játék példa.</phrase>
                        </textobject>	
                    </inlinemediaobject>                    
                    </para>
                    <para>
                    A PC-s játékok tipikusan a teljes képernyőt uralják, ez az osztály a labirintus mikrovilágának egy olyan életre keltését tartalmazza, amely ugyancsak képes erre! Ennek megfelelően a labirintus világának megjelenítése grafikus, időbeli fejlődése pedig önálló. Ha például a hőst nem mozgatja a játékos, akkor is könnyen meglehet, hogy az okos szörnyek felkutatják és hipp-hopp, néhány időegység után máris felfalták!
                </para>
                
            </sect3>
            
            </sect2>
            
            <sect2>
                <title>Mobiltelefonos példák</title>
            
                <para>
                    Ezen példák, mint nevük is mutatja, a mobiltelefonra
                    történő Java alkalmazások fejlesztését vezetik be.
                </para>
                
            <sect3>
                <title> LabirintusMIDlet példa</title>
                
                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/elozetes/labirintus_midlet.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A mobiltelefonos Labirintus MIDlet példa.</phrase>
                        </textobject>	
                    </inlinemediaobject>                    
                    </para>
                    <para>
                    Ahogyan labirintus világunk appletként a böngészőbe töltődött, úgy töltődik MIDletként a mobiltelefonba. A <classname>MIDlet</classname> objektumok azok a Java ME platformbeli objektumok, akik képesek létezni a mobiltelefonok Java virtuális gépeiben.
                </para>
                <para>Ez az osztály tehát arra ad példát, hogyan vihetjük át mobilra a teremtett labirintus mikrovilágunkat. A labirintus világának megjelenítése itt is grafikus, időbeli fejlődése szintén önálló.</para>
                
            </sect3>
            
            </sect2>
            
            <sect2>
                <title>Hálózati példák</title>
            
                <para>
                    A hálózati példák, mint nevük is mutatja, a kézikönyvet
                    több összekapcsolt gép mellett ülve feldolgozó 
                    Olvasóknak nyújtják legoptimálisabban a programozás
                    élményét. Ilyen lehet otthon két összekapcsolt gép, vagy
                    annak az oktatási intézménynek a tantermi
                    hálózata, melyhez az Olvasó tanárként, hallgatóként, diákként
                    kötődik. De természetesen egyetlen, akár Windows, akár Linux
                    operációs rendszerű gépet
                    használva is tesztelhetők a példák.
                </para>
                
            <sect3>
                <title>A LabirintusServlet példa</title>
                
                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/elozetes/labirintus_servlet.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Labirintus Servlet példa.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                        
                    </para>
                    <para>
                    Hasonlóan az előző példához: ahogyan labirintus világunk appletként a böngészőbe töltődött, vagy éppen MIDletként a mobiltelefonba, úgy töltődik Servletként a webszerverbe. A <classname>Servlet</classname> osztálybeli objektumok azok a Java EE platformbeli objektumok, akik képesek a webszerverekben létezni. Tehát szemben az előző két példával, objektumaink most nem a kliens oldalon, azaz nem a böngészőben és nem a mobiltelefon Java virtuális gépében léteznek, hanem a szerver oldalon: a webszerverben. 
                </para>
                <para>A labirintus világának megjelenítése jelen példánál nem grafikus, hanem a böngészőbe történő HTML nyelvű, azaz szöveges lapok küldésében merül ki, tehát elvben karakteres, de ebbe a szöveges válaszba megfelelő 
                <computeroutput>&lt;img scr=""&gt;</computeroutput>
                HTML parancsok küldésével nagyon könnyen grafikussá is tehető a labirintusunk böngészőbeli megjelenítése. Továbbá a példa időfejlődése sem önálló.</para>
                
            </sect3>
            <sect3>
                <title>A HálózatiLabirintus példa</title>
                
                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/elozetes/halozati_labirintus.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Hálózati Labirintus példa.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                        
                    </para>
                    <para>
                    Az informatikában van királyi út, abban az értelemben, hogy minél több programon keresztül csinál valamit a programozó, annál egyszerűbb az élete. Gondoljunk csak arra, hogy mekkora erőfeszítés lenne gépi kódban olyan programokat írni, amelyek különböző processzorú hardvereken működnek. Ennél kisebb erőfeszítés lenne olyan programot írni, ami ugyanezeken a különböző hardvereken, de mondjuk mindegyik esetén Linux operációs rendszerek alatt futna, mert már élvezhetnénk az operációs rendszer támogatását, ha egy magasabb szintű nyelvet választanánk a fejlesztéshez, mondjuk a C nyelvet. De ha még a különböző hardvereken esetleg különböző operációs rendszerek is futnak, viszont 
                    mindannyiukra megvan a Java Virtuális Gép (JVM - Java Virtual Machine), 
                    akkor igazán a királyi úton járhatunk: Java programunk mindenhol futni fog, ahol fut a Java Virtuális Gép. Ez a jelenség általában is megfigyelhető: az előző példában nem kellett foglalkoznunk a 
                    <classname>Servlet</classname>
                    objektumunk és a kliensek hálózati kapcsolatteremésének beprogramozásával, hanem csak azzal, hogy egy kész kapcsolaton keresztül milyen, de már csupán a saját labirintusunkkal kapcsolatos adatokat akarunk küldeni a kliensnek. 
                </para>
                <para>Ebben az értelemben a jelen példa lépés visszafelé, mert itt bizony foglalkozunk a hálózati kapcsolat kiépítésének beprogramozásával, lévén, hogy a 
                <classname>java.net</classname> csomag TCP-s hálózati osztályainak felhasználásával a socket programozás absztrakciós szintjén dolgozunk itt. Ennek megfelelően kliensként 
                a <application>telnet</application> programot használjuk majd, azaz a megjelenítésünk karakteres lesz. Viszont a szerver oldalon a labirintust önálló időfejlődéssel látjuk el.</para>
                
            </sect3>
            <sect3>
                <title>A TávoliLabirintus példa</title>
                
                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/elozetes/tavoli_labirintus.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Távoli Labirintus példa.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                        
                    </para>
                    <para>
                    Abban az értelemben, ami szerint az előző példával visszafelé léptünk, most előre haladunk: itt nem foglalkozunk kommunikációs kapcsolatok felépítésével, hanem csak a kommunikációnak a saját labirintus példánk kapcsán érdekes részével. A kliens oldalon megszerezzük a távoli labirintus objektum referenciáját, ami után már nincs akadálya, hogy a referencia után egy pontot téve 
                    meghívjuk a hivatkozott objektum egy metódusát, igen távolról: de hoppá, ez az objektum egy másik, a távoli szerver oldal virtuális gépében van!
                </para>                
            </sect3>
            
            <sect3>
                <title>A KorbásLabirintus példa</title>
                
                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/elozetes/korbas_labirintus.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Korbás Labirintus példa.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                        
                    </para>
                    <para>
                    Ezzel a példával tovább lépünk előre az absztrakciónak azon útján, amit a TCP/IP-s példa kapcsán kezdtünk el boncolgatni. Immár az sem számít majd, hogy objektumaink milyen nyelven készültek, hanem csupán az, hogy milyen üzeneteket lehet küldeni az objektumainknak vagy ha így jobban tetszik: milyen szolgáltatásokat nyújtanak az objektumaink. Azt azért gyorsan megjegyezzük, hogy ettől persze mi továbbra is Java nyelven dolgozunk, Java osztályokat készítünk, de példánknál maradva már leginkább csak arra kell figyelnünk, hogy mit csinálnak a hősök a labirintusban...
                </para>
                <para>Ez királyi út, de persze ára is van: sok programnak kell együtt és helyesen együtt működnie, hogy a programozó kisebb terheket hordhasson a vállán... </para>                
            </sect3>
            
            <sect3>
                <title>A ElosztottLabirintus példa</title>
                
                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/elozetes/elosztott_labirintus.png" />
                        </imageobject>
                        <textobject>
                            <phrase>Az Elosztott Labirintus példa.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                        
                    </para>
                    <para>
                    Az eddigi példákat az jellemezte, hogy volt egy labirintus mikrovilágunk, aminek különféle használati eseteit készítettük el. A jelen példa pedig arról szól, hogy a hős és a labirintus, sőt még a kincs és a szörny objektumok is valóban különböző gépeken lehetnek! Például az ábra mutatta esetben a labirintus CORBA objektum a
                    <computeroutput>172.21.0.152</computeroutput>
                     IP számú és egy kincs a <computeroutput>172.21.0.17</computeroutput>
                      IP számú gépen. 
                </para>
                                                
            </sect3>

            </sect2>
            
            <sect2>
                <title>További példák</title>
                
                <para>Találkozni fogunk még számos kisebb-nagyobb labirintus variáns 
                feladattal, ezeket külön nem mutatjuk be itt, mert e feladatok 
                célja csupán valamilyen aktualitásra vagy apróságra, finomságra 
                való rámutatás. Például a 
                <classname>LabirintusAlkalmazás</classname> osztály
                a Java Musztáng 
                verziójától élő néhány GUI-val kapcsolatos újdonságot 
                (alkalmazásunk ikonjának elhelyezése az értesítési területre, 
                indító képernyő a programunkhoz), vagy mondjuk a 
                <classname>GenerikusLabirintus</classname> osztály a - Java Tigris 
                verziójától használható - generikus 
                vagy éppen az iteráló <computeroutput>for</computeroutput>
                ciklus alkalmazását mutatja be.</para>
                
                <para>
                Illetve találkozni fogunk még számos kisebb-nagyobb olyan 
                feladattal, amelyeket valamely, a kézikönyvben érintett
                területtel kapcsolatban
                külön tárgyalunk. Ilyenek például a biológiai tárgyú 
                szimulációs illetve számítási, vagy a matematikai számolási
                (mint például a Mandelbrot halmaz tetszőleges részének
                kinagyításáról szóló, vagy a Pi hexadecimális jegyeit 
                kiszámoló) példák. A következő képet például a 
                kézikönyvhöz készített Mandelbrotos 
                példaprogrammal generáltuk és mentettük el.
                                
                </para>

                <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/szinezes_piros.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A kézikönyvhöz készített példaprogrammal készített Mandelbrot halmaz nagyítás.</phrase>
                        </textobject>
                    </inlinemediaobject>            
                </para>                                                          

            <sect3>
                <title>A további önálló példák könyvjelzői</title>
                
                <para>
                Itt a kézikönyvben szereplő önálló, azaz nem a labirintusos
                esettanulmányok részeiként szereplő példák közül
                emelünk ki néhányat.
                </para>
                
                <para>
                <orderedlist numeration="upperroman">
                    <listitem>
                        <para><emphasis><link linkend="turing_gep">A Turing-féle gépek</link></emphasis>.
                        (Programozás papíron.)
                        </para>
                    </listitem>
                    <listitem>
                        <para>Számrendszerek, bitműveletek</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                            <para><emphasis><link linkend="binaris_dump">Bitműveletek, kezdjük egy bináris dumppal</link></emphasis>.
                                (Csak azoknak, akik szeretik a bitfaragást.)
                                </para>
                            </listitem>
                            <listitem>
                            <para><emphasis><link linkend="exor_titkosito">Kizáró vagyos titkosítás</link></emphasis>.
                                (A táblánál és papíron is jól bemutatható bitműveletes példa, a gyakorlatban használjunk PGP-t!)
                                </para>
                            </listitem>
                            <listitem>
                            <para><emphasis><link linkend="titkosito_gui">A kizáró vagyos titkosítás Swinges felületen</link></emphasis>.
                                (Grafikus felülettel látjuk el az iménti példát.)
                                </para>
                            </listitem>
                            <listitem>
                            <para><emphasis><link linkend="szamrendszer">Számrendszer átváltások</link></emphasis>.
                                (Bármikor szükség lehet rá, például a kézikönyvben a Pi jegyeinél is felhasználjuk majd.)
                                </para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>Véletlenszám generátorok, normális eloszlás</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                            <para><emphasis><link linkend="normalis_generator">Normális, módosított polártranszformációval</link></emphasis>.
                                (Matematikusok első OO osztálya.)
                                </para>
                            </listitem>
                            <listitem>
                            <para><emphasis><link linkend="hisztogram">Hisztogram feladat</link></emphasis>.
                                (Normalitás vizsgálat.)
                                </para>
                            </listitem>
                            <listitem>
                            <para><emphasis><link linkend="galton_program">Galton deszka kísérlet</link></emphasis>.
                                (Szimulációs példa.)
                                </para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>Fraktálok: Mandelbrot halmazok</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                            <para><emphasis><link linkend="mandelbrot_halmaz">Mandelbrot halmaz programja</link></emphasis>.
                                (A szépség mellett GUI, szálkezelési, egér és billentyűzet eseménykezelési példa.)
                                </para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>Pi közelítése</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                            <para><emphasis><link linkend="pi_bev">Gregory-Leibniz formula</link></emphasis>.
                                (Pi/4 = 1 - 1/3 + 1/5 - 1/7 + ... valameddig egy ciklusban.)
                                </para>
                            </listitem>
                            <listitem>
                                <para><emphasis><link linkend="ramanujan_chudnovsky">A Ramanujan és a Chudnovsky közelítő összegek formulái</link></emphasis>.
                                (Hatékonyak, de számolni, a számolással
                                programozási élményt szerezni 
                                a 64 bites lebegőpontos aritmetika nem elegendő.)    
                                </para>
                            </listitem>
                            <listitem>
                                <para><emphasis><link linkend="bbp_algoritmus">BBP (Bailey-Borwein-Plouffe) algoritmust: a Pi hexa jegyeinek számolása</link></emphasis>.
                                (Ezzel az algoritmussal már saját PC gépünkön is nagy élményeket élhetünk át a Pi jegyeinek kutatásában!)    
                                </para>
                            </listitem>                            
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>Sejtautomaták</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                            <para><emphasis><link linkend="conway">Sejtautomata szimuláció programja</link></emphasis>.
                                (A híres Conway-féle életjáték és a Gosper-féle sikló ágyú.)
                                </para>
                            </listitem>
                            <listitem>
                            <para><emphasis><link linkend="orch_or">Az Orch OR sejtautomata szimuláció részét demonstráló programja</link></emphasis>.
                                (Az Orch OR a Penrose-Hameroff-féle tudatmodell rövidítése.)
                                </para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>Genomok, fehérjék</para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                            <para><emphasis><link linkend="pontmatrix">Genomi, aminosav vagy akár tetszőleges szekvenciák összehasonlítása</link></emphasis>.
                                (Az aktualitáson túl egy Swinges, legördülő menüs példa.)
                                </para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                </orderedlist>
                    
                </para>   

                <para>   
                    És persze kombinálhatjuk is a példákat, 
                    mondjuk a genomi szekvenciák összehasonlítására készített
                    pontmátrixos programunkkal összehasonlíthatjuk
                    a Pi hexadecimális kifejtésének első és második ezer jegyét,
                    vagy éppen a Pi ezer jegyét a második emberi kromoszóma
                    első kétezer T, C, A, G jegyével. A programozni tudás 
                    erejét éppen az adja, hogy ha a gépek tudnak válaszolni arra,
                    amire éppen kíváncsiak lettünk, akkor egy program formájában
                    fel tudjuk nekik tenni
                    a kérdésünket.
                </para>   
                
            </sect3>
                                
            <sect3>
                <title>A példák jellege</title>
                
                <para>A példaprogramok oktatási céllal készültek, azaz tipikusan valami 
                olyan tulajdonságot mutatnak, amit velük kapcsolatban a könyvben 
                bemutatunk, kifejtünk. Például a labirintus elosztott változata 
                azt akarja megmutatni, hogy minden szereplő objektum külön számítógépen 
                van. De ennél nem többet, ennek megfelelően nem foglalkozik például  -  az 
                egyébként természetesen felmerülő  -  hálózati terheléssel, szinkronizációs problémákkal, hibakezeléssel, magas szereplő 
                szám esetén a működőképességgel kapcsolatos kérdésekkel.</para>
                <para>Ezért a példáknál magunk adunk meg például továbbfejlesztési 
                feladatokat, tipikusan olyanokat, amiket mi magunk már 
                elkészítettünk vagy úgy gondoljuk, hogy el tudnánk készíteni a
                könyvben tárgyalt részek alapján. De számos esetben megadjuk a 
                megoldásokat, vagy legalább a megoldások lényegi részét.</para>
                
            </sect3>
            <sect3>
                <title>Összefoglalás</title>

                <para>
                    A kézikönyvhöz készített programok tipikusan interaktív jellegűek.
                    A labirintusos esettanulmányok példáira az interaktivitás triviálisan
                    teljesül, hiszen mindig a játékos mozgatja a labirintus hősét.
                    A további programok interaktívak vagy demonstratívak. Az előbbire
                    példaként említhetjük a Mandelbrot halmazokat számoló, nagyító, 
                    színező programokat, az utóbbiakra pedig például az Orch OR modelbelli
                    mikrotubulus sejtautomata üzemének demonstrálását.
                </para>
                
                <para>
                    Néhány interaktív jellegű példa alkalmas lehet arra, hogy
                    más, nem konkrétan informatikai tárgyak oktatásában is 
                    felhasználja a tanár Olvasó. Ilyen például 
                    a matematikai jellegű számítási példák között a Mandelbrot
                    halmaz 
                    z<subscript>n+1</subscript> =
                    z<subscript>n</subscript><superscript>2</superscript> + c
                    iterációs számítási lépéseit grafikusan is megmutató példa.
                    Vagy ilyenek a biológiai jellegű számítási példák között a 
                    genomi szekvenciák összehasonlítására szolgáló példaprogramjaink,
                    amelyeket nemcsak a középiskolai, hanem a felsőoktatásbeli,
                    nem konkrétan informatikai szaktárgyakhoz is felhasználhatunk,
                    hiszen ebben az irodalomban - például 
                    a <citation>BIOINFORMATIKA</citation> vagy
                    <citation>PROTEOMIKA</citation> hivatkozásokban 
                    - tipikus, hogy internetes
                    programok címét adják meg a saját tapasztalatokra vágyóknak.
                </para>                
<!--
                <para>            
                   <inlinemediaobject>
                        <objectinfo>
                            <title>A kézikönyvhöz készített példaprogram felhasználása például a matematika szakkörön.</title>
                        </objectinfo>                       
                        <imageobject>
                            <imagedata fileref="images/mat/mandel_utazas.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A kézikönyvhöz készített példaprogram felhasználása például a matematika szakkörön.</phrase>
                        </textobject>
                    </inlinemediaobject>            
                </para>                                                          
-->                                
                <para>Remélhetőleg, vagy még inkább pontosabban, ha e könyv eléri célját, akkor az Olvasó kénye-kedve szerint tudja majd kombinálni a példákat: ott, ahol nincs grafikus megjelenítés: készíteni tud majd ilyet, vagy ott, ahol nincs önálló időfejlődés, fel tudja ruházni ezzel a példát. Ennek során persze felmerülhetnek további nehézségek, amikre jelen bevezető könyv keretein belül nem térhettünk ki. Hogy csak néhány kombinációt említsünk: a 
                <classname>LabirintusServlet</classname> osztályhoz 
                szeretnénk grafikus megjelenítő appletet vagy a <classname>LabirintusServlet</classname>
                osztályba szeretnénk önálló időfejlődést. 
                Nem konkrétan ez utóbbira, de az ilyen esetekre ajánljuk a 
                <emphasis>Nyékyné Gaizler Judit: Java 2 útikalauz programozóknak</emphasis> 
                <citation>JAVA KÖNYV</citation> című mélyebb szakkönyvet, 
                de természetesen fordulhatnak bátran a szerzőkhöz is a 
                <ulink url="mailto:nbatfai@inf.unideb.hu">nbatfai@inf.unideb.hu</ulink> 
                vagy a 
                <ulink url="mailto:pici@inf.unideb.hu">pici@inf.unideb.hu</ulink>                 
                címre írt, <computeroutput>Javát tanítok Olvasó</computeroutput> 
                tárgyú elektronikus levélben.</para>
                
            </sect3>
            
        <sect3>			
            <title>Platform</title>
            
            <warning>
                <title>A szórakoztató háttér ismerete avagy 
                előfeltételek a további olvasáshoz</title>                
                <para>
                    Ha a kedves Olvasó még nem látta, akkor a kézikönyv
                    feldolgozásának érzelmi megalapozásaként javasoljuk 
                    a Mátrix <citation>MÁTRIX MOZI</citation>
                    trilógia első részének 
                    és a Mi a csudát tudunk a világról? című
                    <citation>KVANTUM MOZI</citation>
                    film 
                    megnézését és átbeszélését az Olvasó környezetével: 
                    a barátokkal, kollégákkal. 
                    Illetve javasolunk még némi számítógépes 
                    játékot, mondjuk például a 
                    DOOM <citation>DOOM JÁTÉK</citation> 
                    FPS játékkal. További szórakoztató - s itt a 
                    szórakoztató alatt
                    természetesen most nem az ismeretterjesztőt
                    értjük - források
                    tekintetében például a 
                    <citation>KAPCSOLAT MOZI</citation> filmet
                    vagy még inkább a <citation>KAPCSOLAT REGÉNY</citation>
                    regényt ajánlhatjuk. Ez utóbbira a 
                    könyv több tartalmi elemében is hivatkozni fogunk.
                </para>
            </warning>
            
            <para>
                Figyeltünk arra, hogy mind a Linux, mind a Windows operációs 
                rendszert használó Olvasók a könyv szöveges magyarázó és
                példaprogramos részeit egyaránt és teljesen egyformán élvezni 
                tudják. Ez persze nem volt 
                túl nehéz, mivel főtémánk a Java, aminek egyik erőssége éppen 
                a platformfüggetlenség. Ez azt jelenti, hogy mindegy milyen 
                operációs rendszer dolgozik alattunk, ha mi Javaban 
                programozunk, programunk változtatás nélkül futni fog mindkét
                platformon.
            </para>

            <tip>
            <title>Operációs rendszer</title>
                <para>
                    Mindazonáltal azt tanácsoljuk az Olvasónak, hogy
                    Windows rendszere mellé telepítsen fel egy Linuxot is, mert
                    a lazábban kapcsolódó olvasmányos részekbe igyekeztünk sok
                    olyan finomságot is beleszőni, amit egy Linux mellett ülve a
                    legizgalmasabb kipróbálni. Mi például a Fedora (Core 5) Linux 
                    operációs rendszert 
                    (<ulink url="http://fedora.redhat.com">http://fedora.redhat.com</ulink>)
                    használjuk, az Olvasónak is ezen rendszer használatát javasoljuk.
                </para>            
            </tip>

            <tip>
            <title>Fedora Linux Core 6</title>
                <para>
                    A kézikönyv írásának vége felé közeledve elérhetővé vált a 
                    <productname>Fedora Core 6</productname>, amire természetesen mi is
                    frissítettünk, így immár Linux választása esetén e 
                    GNU/Linux rendszer használatát javasoljuk  
                    (<ulink url="http://fedora.redhat.com">http://fedora.redhat.com</ulink>).
                </para>            
                <para>                    
                    Megjegyezhetjük, hogy az Fedora ötöshöz hasonlóan a Fedora hatosra is
                    igaz, hogy 32 bites és
                    64 bites rendszerekre egyaránt elérhető az imént megadott címen.
                </para>            
            </tip>

            
            </sect3>			

            <sect3>			
                <title>A példaprogramok szerkezete, kipróbálása és a kézikönyv jelölései</title>

                <para>
                A könyvben szereplő minden programot a szerzők készítettek és 
                le is futtattak tipikusan két gépen: egy Linuxos és egy Windowsos
                PC-n. A szereplő hálózati példák kapcsán fontos kihangsúlyoznunk, hogy
                ezek mindegyike kipróbálható egyetlen, hálózatba nem kapcsolt akár Linuxos,
                akár Windowsos gépen is.
                </para>
                
                <para>
                A kézikönyv számos példájának bemutatása vagy az egyik vagy a másik
                különálló számítógépen történik.
                </para>
                
                <para>            
                   <inlinemediaobject>
                        <objectinfo>
                            <title>A példák különálló gépeken.</title>
                        </objectinfo>                       
                        <imageobject>
                            <imagedata fileref="images/elozetes/gepek1.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A kézikönyv számos példájának bemutatása vagy az egyik vagy a 
                            másik különálló számítógépen történik.</phrase>
                        </textobject>
                    </inlinemediaobject>            
                </para>                                                          

                <para>
                A kézikönyv hálózati példái némelyikének bemutatása két gyors Ethernet hálózati
                kártyával felszerelt és Ethernet kábellel összekötött, a 
                <computeroutput>192.168.1.1</computeroutput> és a 
				<computeroutput>192.168.1.2</computeroutput> fenntartott IP számokkal beállított számítógépen történik. Esetünkben
				az egyik gép Linuxos, a másik Windowsos.
                </para>
                
                <para>            
                   <inlinemediaobject>
                        <objectinfo>
                            <title>A példák két összekapcsolt gépen.</title>
                        </objectinfo>                       
                        <imageobject>
                            <imagedata fileref="images/elozetes/gepek2.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A kézikönyv némely hálózati
                             példájának bemutatása két, Ethernet kábellel 
                             összekapcsolt számítógépen történik.</phrase>
                        </textobject>
                    </inlinemediaobject>            
                </para>                                                          
                
                <tip>
                    <title>Az otthoni két gép összekapcsolása</title>
                    <para>
						Ha az Olvasó már rendelkezik két géppel, amiket az imént említett
						módon szeretne összekapcsolni, akkor a két hálózati kártya
						és a kábel költsége ma már csupán néhány ezer forintnyi költségre
						rúg.
                    </para>
                </tip>                
                
                <para>
                A kézikönyv néhány hálózati példájának bemutatása pedig egy az internethez is
                kapcsolt lokális hálózatban történik.
                </para>
                
                <para>            
                   <inlinemediaobject>
                        <objectinfo>
                            <title>A példák az lokális hálózat két gépen.</title>
                        </objectinfo>                       
                        <imageobject>
                            <imagedata fileref="images/elozetes/gepek3.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A kézikönyv néhány hálózati példája pedig egy az 
                         lokális hálózat gépein történik.</phrase>
                        </textobject>
                    </inlinemediaobject>            
                </para>                                                          
                
                <para>                                            
                A kézikönyvben a futási eredményekkel kapcsolatos betétek szedése 
                tipikusan a 
                
                        <screen>
                            <![CDATA[
[norbi@niobe ~]$
                            ]]>
                        </screen>
                vagy az egészen rövid, egyetlen dollárjel         
                        <screen>
                            <![CDATA[
$
                            ]]>
                        </screen>
                        
                prompttal történik, ha a Linuxos és
                            <screen>
                            <![CDATA[
C:\Documents and Settings\norbi>                            
                            ]]>
                            </screen>                    
                prompttal, ha a Windowsos gépen történt a futás. Ez utóbbit
                néha nyomdatechnikai okokból majd a
                <computeroutput>C:\...&gt;</computeroutput>                    
                rövidített alakban írjuk, feltéve persze, hogy ez 
                a rövidítés az értelmezést nem zavarja. Az előbbinél pedig
                azokban az esetekben, amikor a tárgyalt példában szükséges 
                lehet megkülönböztetnünk,
                hogy éppen melyik gépen dolgozunk, a promptban a szokásos
                módon megkülönböztetjük, feltüntetjük a
                hoszt neveket (mint például alább a 
                <hardware>niobe</hardware> és az 
                <hardware>omega</hardware> neveket) is.
                        <screen>
                            <![CDATA[
[norbi@niobe ~]$ itt a niobe nevű gépen vagyunk
                            ]]>
                        </screen>                                 
                        <screen>
                            <![CDATA[
[norbi@omega ~]$ itt pedig az omega nevű gépen dolgozunk éppen
                            ]]>
                        </screen>                                 
                </para>
                
                <para>
                A kézikönyv a példákkal kapcsolatos forráskód 
                részleteket és teljes forrásprogramokat
                is tartalmaz. A források mindkét esetben bőséges dokumentációval
                vannak ellátva, tehát külön elolvasásuk sem haszontalan.
                A teljes programokat Linux és Windows
                rendszerek alatt is lefordítottuk és futtattuk, 
                tehát ezek kipróbálásával, futtatásával az Olvasónak 
                - ha követi utasításainkat - sem támadhat áthatolhatatlan akadálya,
                főleg azért, mert a kipróbálásról: fordításról, futtatásról,
                használatról mindig külön is szólunk, sőt számos esetben 
                képeket is bemutatunk.
                A teljes forrásprogramokat onnan is felismerheti a kedves Olvasó,
                hogy tipikusan a következő jellegű 
                Java dokumentációs megjegyzésekkel kezdődnek.
                Az alábbi sorok például a Galton deszkás kísérletes szimulációs példánk 
                kapcsán kifejlesztett <classname>GaltonDeszka</classname> osztályunkat
                definiáló <filename>GaltonDeszka.java</filename> forrásállomány első sorai. 
            <programlisting>
                <![CDATA[
/*
 * GaltonDeszka.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A Galton deszka kísérletet szimuláló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */                
                ]]>
            </programlisting>            
                Azt is mutatja, hogy a forráskódot kijelölve azt a 
                <filename>GaltonDeszka.java</filename> forrásállományba kell
                beillesztenie a kedves Olvasónak az önálló felhasználásához,
                kísérletezéshez. 
                </para>
                
				<warning>
                <title>A magyar ékezetes betűk használatáról</title>                
                <para>
                A példaprogramokban igyekeztünk magyar ékezetes betűket használni. 
                Igaz ez a példaprogramokat alkotó osztályok neveire vagy például az osztályokban használt 
                változónevekre. Sajnos e törekvésünk során néhány alkalommal az ékezetes betűk használatából
                adódtak problémáink, ezekben az esetekben majd ékezet nélküli osztálynevekkel találkozik a kedves Olvasó.
                </para>
                </warning>
                
				<important id="api_olvasasa">
                <title>A források olvasásáról</title>                
                <para>
                A Java programozó API programozó, ennek megfelelően úgy kell használnia az
                API dokumentációt, mint például a Linux/UNIX alatti programozónak a 
                programozói kézikönyv - a második szintű manuál - lapjait, amit például
                        <screen>
                            <![CDATA[
[norbi@niobe ~]$ man 2 select
                            ]]>
                        </screen>
                        parancs kiadásával olvashatunk. 
                Mi az API dokumentáció
                használatát annyiban tudjuk segíteni, hogy a forrásokban felhasznált
                osztályok nevét mindig a teljes csomagnévvel minősítve írtuk, így például a 
                <computeroutput>java.net.ServerSocket</computeroutput> az is elárulja,
                hogy az Olvasó a szerver socketeket absztraháló <classname>ServerSocket</classname>
                osztályt a <computeroutput>java.net</computeroutput> csomagban találja meg.
                Az API dokumentáció telepítéséről
            <emphasis><link linkend="api_doksi">A Java dokumentáció, azaz az API doksi letöltése</link></emphasis> című pontban olvashatunk.
                </para>
                </important>
                
                
            </sect3>			
        </sect2>			            
    </sect1>
        
        <sect1>			
            <title>Látványos Ars Poetica</title>
            <blockquote>
                <attribution>Mérő László</attribution>
                <para>„S mivel a játékok szocializációs funkciója alapvető
                jelentőségű, meglehet, hogy éppen az információs ipar játéktermékei
                adják meg a döntő, visszavonhatatlan lökést a homo informaticus
                evolúciójához.”</para>
            </blockquote>
                  
            <para>
                A következő ábra szerkezetével az emberiség tudásának egy 
                lehetséges és persze erősen vitatható elrendezését vázoltuk fel.
            </para>
                
            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/elozetes/arspoetica.png" />
                    </imageobject>
                    <textobject>
                        <phrase>Tudásunk fája: az emberiség tudásának egy elrendezése.</phrase>
                    </textobject>	
                </inlinemediaobject>            
            </para>
                
            <para>                
                A nyilvánvaló visszacsatolások indukálta kérdésekkel - hogy 
                mivel például
                az emberi lényről az Orvostudomány
                 doboz környékén beszélünk, de 
                <emphasis>a
                matematika is az emberek fejében van..., vagy talán inkább a platóni ideák
                világában?</emphasis> - nem foglalkoztunk. 
            </para>
                
            <para>                
                Napjaink Informatika doboza az ábra Matematika dobázának közelében egy
                 fiatal doboz lenne, de ha a madáchi 
                <emphasis>„szellem szemekkel”</emphasis>
                látnánk, akkor el tudjuk képzelni, hogy minden tudásunk egy
                absztrakt, de természetes <emphasis>informatika</emphasis> ágba rajzolható,
                ez a mi ars poeticánk, amit Neumann <citation>GÉP és AGY</citation>
                utolsó könyvének utolsó gondolata inspirál:
                       <blockquote>
                            <attribution>Neumann János</attribution>
                            <para>                
                „Arra is rá kell mutatni, hogy ez az idegrendszeri nyelv 
                nem is csekély valószínűséggel inkább a korábban leírt
                értelemben vett rövid program, mint hosszú program. Meglehet,
                hogy amikor matematikai fejtegetésekkel foglalkozunk, akkor
                egy olyan <emphasis>másodlagos</emphasis> nyelvről tárgyalunk, amely ráépül
                a központi idegrendszer által ténylegesen használt 
                <emphasis>elsődleges</emphasis>
                nyelvre.”</para>
                </blockquote>                
            </para>                
                
            <para>                
               <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/elozetes/arspoetica2.png" />
                    </imageobject>
                    <textobject>
                        <phrase>Tudásunk fája II.</phrase>
                    </textobject>	
                </inlinemediaobject>                  
            </para>                
            
        </sect1>
        
        <!-- A szerzőkről máshová -->
        
    </preface>

<part id="prog_papiron">
    <title>Programozás papíron</title>
    
    <partintro>
        <para>
            Ebben a részben nemcsak fejben, hanem papíron is dolgozunk, de ne
            ijedjünk meg: egyelőre nem azért nem kapcsolunk be gépet, mert
            félünk tőle, hanem mert az itt szereplő gépeket nem lehet
            bekapcsolni, mivel ezek egy platóni világban, pontosabban csak a mi
            képzeletünkben léteznek, működnek. 
        </para>
        <para>
            Továbbá a gyakorlati érdeklődésű Olvasónak is bátran ajánljuk ezt a 
            részt, mert a Turing gépes környezetben való programozás előszobája 
            az algoritmikus információelméletnek. Ami, a mi olvasatunkban,a 
            programozói konstruktív szemlélet manifesztációja a tudományban.
        </para>
        <para>
            A rész befejezéséül az objektumorientált (OO) világ,
            majd a hálózat, az internet programozóknak fontos alapfogalmait
            tekintjük át.
        </para>
    </partintro>
    
    <chapter>

    <chapterinfo>
        <keywordset>
          <keyword>Turing gép</keyword>
          <keyword>univerzális Turing gép</keyword>
          <keyword>Megállási probléma</keyword>
          <keyword>bonyolultság</keyword>
          <keyword>számítási bonyolultság</keyword>
          <keyword>Chaitin Kolmogorov bonyolultság</keyword>
          <keyword>Chaitin gép</keyword>
          <keyword>Chaitin Omega</keyword>
          <keyword>Omega szám</keyword>
          <keyword>Omega valószínűség</keyword>
          <keyword>titkosítás</keyword>          
          <keyword>Pi</keyword>          
          <keyword>Galton deszka</keyword>          
          <keyword>hisztogram</keyword>          
          <keyword>normális eloszlás</keyword>          
          <keyword>harang görbe</keyword>          
          <keyword>harang görbe</keyword>
          <keyword>véletlen</keyword>
          <keyword>véletlen sorozat</keyword>
          <keyword>objektumorientált programozás</keyword>
          <keyword>OO</keyword>
          <keyword>CORBA</keyword>
          <keyword>IDL</keyword>
          <keyword>Java</keyword>
          <keyword>Oak</keyword>
          <keyword>James Gosling</keyword>
          <keyword>John Gage</keyword>
          <keyword>Sun</keyword>
          <keyword>SunWorld</keyword>
          <keyword>Netscape</keyword>
          <keyword>FirstPerson</keyword>          
          <keyword>LEGO</keyword>
          <keyword>Mindstorms</keyword>
          <keyword>robot</keyword>          
          <keyword>James Gosling</keyword>
          <keyword>Java SE</keyword>
          <keyword>Java ME</keyword>          
          <keyword>Tigris</keyword>                            
          <keyword>Delfin</keyword>                            
          <keyword>Musztáng</keyword>                            
          <keyword>Tiger</keyword>                            
          <keyword>Dolphin</keyword>                            
          <keyword>Mustang</keyword>                            
          <keyword>Jávácska</keyword>          
          <keyword>RobIGOR</keyword>          
          <keyword>Fibonacci</keyword>          
          <keyword>gcj</keyword>          
          <keyword>sebesség</keyword>          
          <keyword>socket</keyword>          
          <keyword>internet</keyword>
          <keyword>TCP/IP</keyword>          
        </keywordset>
    </chapterinfo>
   
        <title>A programozásról</title>
            
    <epigraph>
        <attribution>Gregory Chaitin
            <citetitle>META MATH! The Quest for Omega</citetitle>
        </attribution>
        <para>
            „Csak akkor értesz valamit, ha be tudod programozni.
            Te magad és nem valaki más! Ha nem tudod beprogramozni, 
            akkor csak úgy gondolod, hogy érted.”
        </para>
    </epigraph>

    <abstract>
        <para>
            A tudomány fejlődésében egyre nagyobb szerepet kapnak az informatikai
            gondolkodásmódra épülő paradigmák. E jelenség gyökere 
            az informatikai gondolkodásmód erősen konstruktív jellege. 
            Az informatikai ihletésű paradigmák alapfogalma
            a számítások, a számítógépek könnyen kezelhető, precíz modellje a 
            <emphasis>Turing gép</emphasis>.
            Ebben az elméleti programozási fejezetben ezekkel a gondolatbeli
            gépekkel és programozásuk szépségeivel, nehézségeivel ismerkedünk meg.
            Elméleti erőfeszítéseink zárásaként bemutatjuk a Turing gépek több,
            filozofikusan is nagyon izgalmas felhasználását, amik többek között
            a matematika megalapozásának kérdéséhez is elvezethetik a kedves Olvasót. 
            Majd a gyakorlat, 
            a Java programozás felé vesszük az irányt, bevezetve a Java SE, Java ME 
            OO világ 
            és végül az internet programozásának alapfogalmait.
       </para>
    </abstract>

    <highlights>
        <para>
            Ebben az elméletiből-gyakorlati tárgyalásba forduló,
            programozást bevezető részben<itemizedlist>
                <listitem><para>megismerhetjük a számítógépek, számítások elméleti modelljét: a Turing gépet</para></listitem>
                <listitem><para>a Turing gépekhez kapcsolódó legfontosabb eredményeket</para></listitem>                    
                <listitem><para>egy a Turing gépekre épülő bonyolultsági mértéket</para></listitem>                    
                <listitem><para>a végtelen ciklusok elkerülésének Omega valószínűséget</para></listitem>
                <listitem><para>végül az eddigi elméleti erőfeszítéseink koronájaként a Gödel és Chaitin-féle inkompletibilitási tételeket</para></listitem>
                <listitem><para>majd tovább lépve a gyakorlat felé: megismerhetjük a Java SE világát</para></listitem>
                <listitem><para>és a Java ME világát</para></listitem>                    
                <listitem><para>végül az internet és a hálózati programozás alapfogalmait vezetjük be</para></listitem>                                    
            </itemizedlist>                
        </para>                
    </highlights>        
        
    <sect1>        
        <title>A programozás filozófiája</title>
                                
        <blockquote>
            <attribution>David Kushner</attribution>
            <para>
                „Elképzelte, ahogy a kis adatcsomag keresztüláramlik a hálózati kábelen és létrehozza a képernyőn látható tengerészgyalogost.  -  A jobb oldali számítógépre pillantott és figyelte a most külső szemszögből látható karakterét, ahogy átfut a képernyőn. Fantasztikus világot teremtett, most pedig életre keltette.”
            </para>
        </blockquote>
        
        <para>Az előszóban említettük, hogy a programozásra gondolva olykor valami misztikus, mámoros érzés járja 
        át a programozót...</para>
        <para>Foglalkozzunk most tovább kicsit ezzel az érzéssel! Mert foglalkozni kell vele: 
        hogyan lehet a diákokban felépíteni azokat a mentális struktúrákat, 
        amelyek majd rezonálni képesek erre az érzésre? Hol élhetjük hát át ezt az érzést? 
        A Linux különösen sok alkalmat ad rá: például 
        a kernelfordításnál - a kernelfordítás leírását lásd 
        a <citation>PROGRAMOZÓ PÁTERNOSZTER JEGYZET</citation>-ben - 
        amikor a C források éppen fordulnak és tudjuk, hogy néhány perc 
        múlva már ezzel az éppen most lefordított kernellel fogjuk újra bebootolni 
        gépünket, hogy az általunk, éppen most, a rendszerre szabott szoftver vezérelje 
        azt. De sokszor még gép közelébe sem kell mennünk, hogy átéljük a 
        szóban forgó élményt. Elég beülni a moziba vagy betenni a dvd lemezt és 
        megnézni az életünkben felvirradt információs-programozói civilizáció 
        csúcstermékét, az immár kultuszfilmet  -  programozóknak pedig kötelező 
        szakmai mozit  -  a Mátrix 
        <citation>MÁTRIX MOZI</citation>
        trilógiát. Ennek az alkotásnak 
        a gyökereitől elvitathatatlan, hogy a virtuális valóságon 
        keresztül az informatikába nyúlnak.</para>
        
        <para>
            Az információs-programozói civilizáció kialakulásával párhuzamosan 
            egyre mélyebbre és mélyebbre nyúlnak az informatika fájának gyökerei is. Az Alan Turing által képzeletben, Neumann János vezetésével gyakorlatban létrehozott, a gondolkodás formalizált lépéseit imitáló gépek utódainak 
            mai hekkerei (hackerei) már az emberi tudatot, a kvantumfizikai valóságot akarják programozni... 
        </para>
        <para>Kezdjük hát  -  hogy stílszerűek legyünk  -  kedves Olvasó, 
        <emphasis>„menjünk fel adásszintre”!</emphasis></para>
        
        <sect2>
            <title>A programozás alapjai</title>
            
            <blockquote>
                <attribution>Stanislas Dehaene</attribution>
                <para>
                „Valóban a matematika nyelvén írták a világegyetemet, mint azt Galilei gondolta? Én hajlamosabb vagyok azt hinni, hogy inkább ez az egyetlen nyelv, amin megpróbálhatjuk elolvasni.”</para>
            </blockquote>
            
            <para>Mi hát az a nyelv, amit a ma programozójának beszélnie kell? 
                A legalapvetőbb és egyben az átlagos programozó számára garantáltan
                a legeslegfelhasználhatatlanabb nyelv a Turing gépeké. 
                Mindig 
                megnevettethetik az érdeklődő Olvasót azok a viccek, amik
                poéntartalma a: 
                <emphasis>„Hol van a Turing gép kiállítva?”</emphasis> 
                beugratós kérdés                
                variánsa. Mert ezek a gépek csupán a matematikai képzeletünkben 
                léteznek. De csak azért ne becsüljük le ezeket a konstrukciókat, 
                mert mint írtuk, az iparban nem felhasználhatók. 
                Neumann ENIAC (Elektronikus Numerikus Integráló és Számológép) 
                gépéhez - ami a maga idejében ipari és tudományos 
                területről egyaránt érkező, 
                számos numerikus jellegű feladatot oldott meg - ma már nem 
                találnánk programozót, mert a gépek és programozásuk időközben
                annyira megváltozott. Nem így a Turing gépek, azok ma is                 
                ugyanazok és ugyanúgy programozandók, mint ahogyan Turing 
                annak idején megálmodta és programozta 
                <citation>TURING CIKK</citation>                
                őket.
            </para>
            
            <note>
                <title>A <emphasis>„Hol van a Turing gép kiállítva?”</emphasis> kérdés története</title>
                <para>
                    A Debreceni Egyetem helyi legendáriuma ezt a kérdést Szabó József 
                    professzor úr kedvelt, tréfás beugratós, államvizsgán elhangzó
                    kérdéseként jegyzi.
                    A Juhász Istvánnal történő közös vizsgáztatásakor
                    történt meg az az eset, amikor a hallgató azt felelte: „Otthon az iskolámban”. Ugyanis egy levelezős általános iskolai tanár Juhász István biztatására megépített két fizikai reprezentációt is, amelyen a gyerekek nagy lelkesedéssel „Turing-programoztak”
                    <citation>TURING GÉP REPREZENTÁCIÓ</citation>.
                </para>
            </note>            
            
            <sect3>
                <title>Algoritmikus kérdések</title>
                
                <blockquote>
                    <attribution>Wigner Jenő</attribution>
                    <para>
                    „Bele kell majd nyugodnunk abba a ténybe, hogy értelmünk erőfeszítései nem adhatnak olyan teljes képet a világról, amilyet elérni  -  erőfeszítésektől mentesen, könnyű elmélkedéssel  -  a görögök álma volt.”</para>
                </blockquote>
                
                <para>A következő néhány pontban leverünk gondolkodásunk sodrába néhány 
                olyan mentális cölöpöt, melyekbe kapaszkodva meg tudjuk vetni lábunkat, 
                ha filozofálni támad kedvünk a programozásról magáról. Megismerjük 
                az univerzális Turing gépeket és a megállási, azaz a végtelen
                ciklusok elkerülésének problematikáját, továbbá egy 
                immár tisztán a programozásra épülő, 
                mindenféle bonyolultságokat összehasonlítani 
                képes fogalmat: a Chaitin-Kolmogorov-Solomonoff bonyolultságot. Végül
                a programozás orientált információelmélet inkompletibilitási tételeit
                mutatjuk be.
                Aki programozó akar lenni, 
                annak ezeket a fogalmakat nem árt ismerni. Aki pedig komolyan akar 
                hekkelni a témában, annak ezeket a fogalmakat ismerni kell, hát 
                még annak, aki - e pont bevezető idézetének értelmében - görög akar lenni! Ez utóbbi tréfás tagmondatot 
                az inspirálja, hogy véleményünk szerint egy átlagos programozó 
                a véletlen sorozatok témában rövid idő alatt, 
                szemléletében is mély tudásra tehet szert, 
                még hasonló tudás megszerzése a hegy matematikai statisztikai oldalán 
                 mászva 
                nagyon nagy nehézségekkel járna számára
                (a metaforikusan említett hegy 
                statisztikai ösvénynek a leírását a <citation>KNUTH 2. KÖNYV</citation>
                könyvben olvashatja a matematikai érdeklődésű Olvasó).
                </para>
                
                <sect4 id="turing_gep">
                    <title>A Turing-féle gépek</title>

                    <blockquote>
                        <attribution>Arthur C. Clarke</attribution>
                        <para>
                        „Az egyik legjellemzőbb emberi vonás a kíváncsiság. A végtelenségig nem dacolhatsz vele.”</para>
                    </blockquote>                    
                    
                    <para>
                        A Turing gépeket matematikailag egyszerűen, szépen és pontosan le lehet írni, most mégis inkább egy rajzot készítünk, mert azt feltételezzük, hogy ez az első találkozásunk ezekkel a gépekkel.
                        Íme legyen az első Turing hardverünk a következő!
                    </para>
                    
                    <para>                    
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/turing_gep_1.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az első Turing hardverünk.</phrase>
                            </textobject>	
                        </inlinemediaobject>                        
                    </para>
                    
                    <para>                    
                        Bemutatott hardverünk leírása: a memória 
                        végtelen sok cellából áll, jelen Turing hardverünkben egy memóriacella három értéket hordozhat. A # jelöli, hogy üres a cella és lehet még benne a 0 vagy az 1 számjegy. A vezérlőegység képes beolvasni és írni az I/O fej alatti memória cellát és az állapot regiszterét, továbbá jobbra és balra lépkedni, de akár helyben is maradni.                        
                    </para>
                    
                    <para>Jöjjön a szoftver! A Turing gépet 
                    programozhatjuk szövegesen vagy grafikusan. 
                    Egy példán keresztül lássuk először a szöveges módot:
                        <orderedlist>
                            <listitem>
                                <para>Ha Lépked állapotban vagyok és 1-et olvasok, akkor 1-et írok, Lépked állapotban maradok és jobbra lépek! Röviden: (Lépked, 1) -&gt; (Lépked, 1, -&gt;)</para>
                            </listitem>
                            <listitem>
                                <para>Ha Lépked állapotban vagyok és 0-t olvasok, akkor 0-t írok, Lépked állapotban maradok és jobbra lépek! Röviden: (Lépked, 0) -&gt; (Lépked, 0, -&gt;)</para>
                            </listitem>
                            <listitem>
                                <para>Ha Lépked állapotban vagyok és #-et olvasok, akkor #-et írok, Lépked állapotban maradok és jobbra lépek! Röviden: (Lépked, #) -&gt; (Lépked, #, -&gt;)</para>
                            </listitem>
                            <listitem>
                                <para>Kezdetben legyek Lépked állapotban, az input szó első betűjén állva!</para>
                            </listitem>
                        </orderedlist>
                    </para>
                    
                    <para>
                        Az utasítások általános formája a Turing gép utasításciklusának alábbi
                        (végrehajtása előtt) -&gt; (végrehajtása után) formájában megadva a következő:                    
                    </para>
                    <para>                    
                        <computeroutput>
                            (állapotban vagyok, mit olvasok) -&gt; (állapotban leszek, mit írok, merre lépek)
                        </computeroutput>
                    </para>
                    
                    <para>A program megadásának grafikus módja egy gráf, az
                    úgynevezett állapot-átmenet gráf megadása. A gráf 
                    csúcsai a gép lehetséges állapotai, élei a következő
                    alakúak.                    
                    
                    </para>
                    
                    <para>                                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/turing_gep_graf.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Turing gép szoftverének megadása grafikusan.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        A „program gráf” működése:
                        megnézzük, hogy milyen állapotban vagyunk és éppen mit olvasunk, majd az állapotunknak megfelelő csúcsból az ilyen (mit olvasunk, , ) alakú címkével jelzett kivezető élt keresünk és azon megyünk tovább. Ha esetleg nincs ilyen él az állapotunknak megfelelő csúcsból, akkor a gép megáll.                        
                    </para>

                    <para>                    
                        Adjuk meg most az imént szereplő, szövegesen leírt
                        szoftvert grafikus formában!
                    </para>
                                        
                    <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/turing_gep_1s.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az első Turing gépünk szoftvere.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        Jelen példánkban az ötödik lépés után már mindig 
                        a (#, #, -&gt;) élen utazunk tovább ugyanoda és 
                        mindig ugyanazt, a # jelet olvassuk ott újra, tehát ... 
                    </para>
                    
                    <para>Tehát mit csinál ez a program? Kövessük végig gondolatban, azaz futtassuk le! Remélem nem futtattuk órákig, mert bizonyára tapasztaltuk, hogy a program soha nem áll le, ez bizony végiglépked az input szó betűin, majd tovább az üres jeleken, s amit olvas azt visszaírja... 
                    ez egy végtelen ciklus: egy olyan szituáció amikor a gép soha nem áll le. </para>
                    
                    <para>
                        Nézzünk még egy példát, most a hardver legyen egészen hasonló, mint az előző gépbe épített, de immár egy állapottal bővebb az állapotaink halmaza:
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/turing_gep_2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A második Turing gépünk hardvere.</phrase>
                            </textobject>	
                        </inlinemediaobject>                    
                    </para>
                    
                    <para>A szoftver is legyen hasonló, mégpedig grafikus alakban
                    megadva a következő.
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/turing_gep_2s.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A második Turing gépünk szoftvere.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                        
                    </para>
                    
                    <para>
                        Mit csinál a gép? Végigmegy az inputon és a végére ír egy nullát. A szalagon példaként álló 101 szóból az 1010 szót készíti el. Az 11 szóból az 110 szót, 
                    </para>
                    <para>
                    az 1100110101101111001111111111 szóból 
                    </para>
                    <para>
                    az 11001101011011110011111111110 szót, azaz minden bemenő bináris szó végéhez hozzáfűz egy nullát, tehát kettővel szorozza az input szót: például 101 = 5, 1010 = 10. Az új nulla beírásakor átmegy a Vég állapotba, ahol aztán meg is áll, mert nincs olyan programutasítás, ami most alkalmazható lenne, hiszen ebből az állapotból semmilyen él nem vezet ki (szövegesen: nincs olyan programsor, ami arra válaszolna, mit kell csinálni a vezérlésnek, ha Vég állapotban van és # betűt olvas, 
                    így tanácstalanságában a gép megáll).
                    </para>
                    
                    <para>Készítsünk egy harmadik gépet is, további továbbfejlesztésként: 
                    ha az üres szó van induláskor a szalagon, azaz, ha input nélkül futtatjuk a gépet, akkor ne csináljon semmit, illetve ha esetleg vannak a bináris szó előtt vezető nullák, akkor azokat törölje le. Egyébként ugyanúgy kettővel szorozzon!
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/turing_gep_3.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A harmadik Turing gépünk hardvere.</phrase>
                            </textobject>	
                        </inlinemediaobject>                    
                    </para>
                    
                    <para>E harmadik gép szoftvere:
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/turing_gep_3s.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A harmadik Turing gépünk szoftvere.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                      
                    </para>
                    
                    <para>
                        Negyedik gyakorló gépünk üzemeljen kicsit más jelleggel, legyen feladata az input szóról eldönteni, hogy rendelkezik-e valamilyen tulajdonsággal. Döntse el, hogy az inputként binárisan lekódolt szám kettővel osztható-e. Szokás szerint minden azzal kezdődik, hogy a programozó kitalálja az algoritmust: igen a válasz, ha a szám bináris kódja a 0 jeggyel végződik, nem, ha az 1 számjeggyel, vagy nincs input szó.
                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/turing_gep_4.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A negyedik Turing gépünk hardvere.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                        
                    </para>
                    
                    <para>A szoftvert úgy szervezzük, hogy a gép az Elfogadó állapotában álljon meg, 
                    ha az input szó osztható kettővel, illetve ellenkezőleg, 
                    az Elutasító állapotában álljon meg, ha nem osztható. A szoftver legyen tehát a 
                    következő:
                    
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/turing_gep_4s.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A negyedik Turing gépünk szoftvere.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                                          
                    </para>
                    
                    <sect5>
                        <title>Az univerzális Turing gépek</title>
                        
                        <para>A fenti három példa már jól mutatja, hogy minden feladatra külön Turing-féle számítógépet kell konstruálnunk. Meg kell adnunk, hogy milyen betűk lehetnek a szalagon, milyen állapotokban lehet a gép, mi a kezdő és végállapota - ezek voltak a hardver kérdések - és milyen 
                            (állapot, olvasott) -&gt; (állapot, írni, lépésirány) 
                            programutasításai vannak - ezek voltak a felmerülő 
                            szoftveres kérdések. Egy nagyon fontos, alapvető, de 
                            most bizonyítás nélkül ismertetett tétel azt mondja,
                            hogy létezik olyan Turing gép, ami képes bármely 
                            más Turing-féle gépet szimulálni. (A bizonyítás szó kapcsán
                            rámutathatunk, hogy ezen a bizonyításon a megfelelő
                            Turing gép megkonstruálását kell érteni!) 
                            Visszatérve a szimulációs tételhez, ez azt jelenti, 
                            hogy ezt a speciális Turing gépet egy másik Turing 
                            gép és e másik Turing gép inputjából készített 
                            inputtal indítva ugyanazt az eredményt fogja 
                            produkálni, ugyanúgy fog működni, mint önmagában 
                            futtatva a másik Turing gép az inputjával. 
                            Ezeket a speciális Turing gépeket univerzális 
                            Turing gépeknek nevezzük. Ezek a mi mai számítógépeink 
                            megfelelő, elméleti modelljei, mert innentől nem 
                            kell minden feladathoz külön Turing gép, hanem veszünk egy univerzális Turing gépet és annak inputként (tehát adatként) beadhatunk egy megfelelően lekódolt Turing gépet (mint végrehajtandó programot) és annak inputját (mint adatot). 
                        </para>
                        
                        <para>Az egyszerű Turing gépet rajzban így festettük le:
                        </para>
                        
                        <para>                        
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/algelm/ugep1.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Az egyszerű Turing gép rajza.</phrase>
                                </textobject>	
                            </inlinemediaobject>                                        
                            
                        </para>
                        <para>Ennek megfelelően az Univerzális Turing gépeket pedig így rajzolhatjuk le:
                        </para>
                        
                        <para>                        
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/algelm/ugep2.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Az univerzális Turing gép rajza.</phrase>
                                </textobject>	
                            </inlinemediaobject>                                        
                            
                        </para>
                        <para>Mindkét géptípus esetén a továbbiak során röviden majd azt is rajzoljuk, hogy
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/algelm/ugep3.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>A gépek rövidített jelölése további rajzainkban.</phrase>
                                </textobject>	
                            </inlinemediaobject>                                        
                            
                        </para>
                        <para>Ami alatt azt értjük, hogy a T gép szalagján az x szó az input, 
                        az U gép szalagján pedig egy T gép és a T gép x inputjának 
                        egyesítésével előálló szó az input.</para>
                        
                    </sect5>
                    
                </sect4>
                
                <sect4>
                    <title>A Turing gép piac</title>

                    <blockquote>
                        <attribution>
                            David Hilbert
							<citetitle>
								<citation>STEWART KÖNYV</citation>
							</citetitle>
                        </attribution>
                        <para>
                            „Senki sem űzhet ki minket a Cantor által teremtett paradicsomból”
                        </para>
                    </blockquote>    
                    
                    <para>
                        Miért bírnak alapvető fontossággal a Turing-féle gépek? Mert tapasztalataink alapján úgy gondoljuk, hogy azokat a feladatokat lehet digitális számítógéppel, tehát valamilyen programozási nyelven megírt algoritmussal megoldani, amit Turing géppel is meg lehet oldani és megfordítva: amely feladatokat nem tudunk Turing géppel megoldani, azt algoritmussal, azaz valamely digitális számítógépre valamilyen nyelven megírt semmilyen programmal sem tudunk megoldani. 
                        Ezt a tapasztalatunkat nevezzük <emphasis>Church-Turing tézisnek</emphasis>.
                        A tézissel kapcsolatban további olvasmányként a 
                        <citation>DRAGÁLIN KÖNYV</citation> logika vagy az 
                        <citation>ALGORITMUSOK KÖNYV</citation>, illetve a <citation>LOVÁSZ KÖNYV</citation> 
                        algoritmuselméleti 
                        tankönyveket ajánljuk.
                    </para>
                    <para>
                        Tehát amit meg tudok írni C-ben vagy Javaban, azt elvben Turing géppel is meg tudnám csinálni, ki tudnám számítani. Meglehet, hogy ennek a megfelelő Turing gépnek az elkészítése hatalmas fáradtság lenne, mint ahogyan például a megoldást adó x86 assembly nyelvű program változatnak megírása is jóval nagyobb munka lenne az eredeti C vagy Java változat megírásánál. Futási ideje is hihetetlenül megnőne, lévén a Turing gép a mi fejünkben működik, magam interpretálom, játszom le sorban a gép működésének lépéseit... de a lényeg, hogy elvben nincs különbség a Java nyelvű és a Turing program között. Azért a programozói fizetés tekintetében inkább a Java nyelv gyakorlására hangolnám a tipikus Olvasót, semmint a Turing programozásra.
                    </para>
                    
                </sect4>
                
                <sect4 id="megallas">
                    <title>Végtelen ciklus, avagy a megállás problémája</title>
                    
                    <blockquote>
                        <attribution>Madách Imre</attribution>
                        <literallayout>
                            „Ne kérdd
                            Tovább a titkot, mit jótékonyan
                            Takart el istenkéz vágyó szemedtől.
                            Ha látnád, a földön múlékonyan
                            Pihen csak lelked, s túl örök idő vár:
                            Erény nem volna itt szenvedni többé.
                            Ha látnád, a por lelkedet felissza:
                            Mi sarkantyúzna, nagy eszmék miatt”                    
                        </literallayout>
                    </blockquote>
                    
                    <para>A végtelen ciklusok felbukkanása két területen 
                    különösen gyakori, ezek a területek a szerver oldali 
                    programozás és az algoritmusokról szóló elméleti vizsgálatok. Ebben a pontban még ez utóbbival foglalkozunk: építünk egy megépíthetetlen Turing komputert! 
                    </para>
                    <para>Tegyük fel, hogy van egy olyan algoritmusunk  -  azaz a Church-Turing tézis értelmében van egy olyan Turing gépünk  -  ami egy másik algoritmusról, azaz Turing gépről meg tudja mondani, 
                    hogy megáll-e majd. Tehát, hogy nem kerül végtelen ciklusba. 
                    Nevezzük ezt a feltételezett speciális gépet M gépnek és felépítése legyen ilyen:
                    </para>
                    <para>                    
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/megall1.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A megállást eldöntő gép működése.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                        
                    </para>
                    
                    <para>Ez az M gép az inputjaként kódolva megkapott tetszőleges T Turing gépről el tudja dönteni, hogy az meg fog-e állni vagy végtelen ciklusba fog esni. Ezt tételeztük fel, hogy van ilyen M (Megállást megvizsgálni tudó) gép. Nézzük meg az M gép működését egy konkrét T gépre: </para>
                    <orderedlist numeration="lowerroman">
                        <listitem>
                            <para>ha a T gép megálló gép, akkor az M a kékkel jelölt úton működik és előbb-utóbb az elfogadó állapotában áll meg</para>
                        </listitem>
                        <listitem>
                            <para>ha a T gép végtelen ciklusba eső gép, akkor az M a pirossal jelölt úton működik és előbb-utóbb az elutasító állapotában áll meg. </para>
                        </listitem>
                    </orderedlist>
                                         
                    <para>Ennek a feltételezetten létező M gépnek a felhasználásával építsük meg a még nagyobb E gépet a következő tervrajz alapján!
                    </para>
                    <para>                                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/megall2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A megállást eldöntő gép feltételezett továbbfejlesztésének működése.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            
                    </para>
                    
                    <para>Játsszuk végig az E (Ellentmondó gép) működését egy tetszőlegesen választott, konkrét T inputra: </para>
                    <orderedlist numeration="lowerroman">
                        <listitem>
                            <para>ha a T gép megálló gép, akkor az M a kékkel jelölt úton működik és
                             előbb-utóbb az elfogadó állapotába megy, ahonnan bármit olvas, visszaírja, helyben 
                            marad a fej és átmegy a gép a végtelen ciklus állapotba, ahogyan a neve is utalja: 
                            bármit olvas, visszaírja, helyben marad a fej, azaz ez egy végtelen ciklus! 
                            Tehát nem áll meg az E gép.</para>
                        </listitem>
                        <listitem>
                            <para>ha a T gép végtelen ciklusba eső gép, akkor az M a pirossal jelölt úton működik és előbb-utóbb az elutasító állapotába megy, ahonnan bármit olvas, visszaírja, helyben marad a fej és átmegy a gép a Megáll állapotába, ahogy mint neve is erre utal megáll. Tehát megáll az E gép.</para>
                        </listitem>
                    </orderedlist>
                    
                    <para>Jöjjön most a trükk: hogy működik az E gép, ha a saját maga lekódolása az inputja? Tehát ha az E gépet az T=E inputtal indítjuk el?</para>
                    <orderedlist numeration="lowerroman">                         
                        <listitem>
                            <para><emphasis>Ha az E gép megálló gép,</emphasis> akkor az M a kékkel jelölt 
                            úton működik és előbb-utóbb az elfogadó állapotába megy, ahonnan bármit olvas, 
                            visszaírja, helyben marad a fej és átmegy a gép a végtelen ciklus állapotba, ahogyan a neve is utalja: bármit olvas, visszaírja, helyben marad a fej, azaz ez egy végtelen ciklus!
                            <emphasis>Tehát nem áll meg az E gép, hanem végtelen ciklusba esik.</emphasis></para>
                        </listitem>
                        <listitem>
                            <para><emphasis>Ha az E gép végtelen ciklusba eső gép,</emphasis> akkor az M a pirossal jelölt úton működik és előbb-utóbb az elutasító állapotába megy, ahonnan bármit olvas, visszaírja, helyben marad a fej és átmegy a gép a Megáll állapotába, ahogy mint neve is erre utal megáll.
                            <emphasis>Tehát megáll az E gép.</emphasis></para>
                        </listitem>
                    </orderedlist>
                    
                    <para>Emeljük ki az eredményt:
                        
                        <orderedlist numeration="lowerroman">
                            <listitem>
                                <para><emphasis>Ha az E gép megálló gép, akkor nem áll meg az E gép, hanem végtelen ciklusba esik.</emphasis></para>
                            </listitem>
                            <listitem>
                                <para><emphasis>Ha az E gép végtelen ciklusba eső gép, akkor megáll az E gép.</emphasis></para>
                            </listitem>
                        </orderedlist>
                    </para>
                    
                    <para>Hoppá! Döbbenetes, nem igaz? Jó kis ellentmondás, ez Turing nagy felfedezése, hogy a megállási probléma nem dönthető el! Mert az ellentmondásnak csak az lehet a feloldása, hogy a feltételezett M gépünk nem létezhet! Az E gép már csupán egy 
                    légvár vagy még inkább csak egy álomkép volt, mert alkatrésze az M (Megállást megvizsgálni tudó) gép nem létezhet, mert ha létezne, abból az imént demonstrált ellentmondás következne. Tehát nincs olyan algoritmus, ami meg tudná mondani, hogy az inputjaként kapott tetszőleges Turing gép megáll-e vagy végtelen ciklusba esik. Ez nem azt jelenti, hogy a
                        
                        <programlisting>
                            <![CDATA[
#include <stdio.h>
int
main(void)
{
  printf("Hello, Vilag!\n");
  return 0;
}                            
                            ]]>
                        </programlisting>
                        
                        C programról nem tudom kijelenteni, hogy megáll, hiszen hogyne állna meg.
                    </para>
                    
                    <para>S nem azt jelenti, hogy a 
                        
                        <programlisting>
                            <![CDATA[
int
main(void)
{
  for(;;)
    ;
}                            
                            ]]>
                        </programlisting>
                        
                        C programról nem tudom kijelenteni, hogy végtelen ciklus, hiszen hogyne lenne az. Hanem azt jelenti, hogy nincs olyan algoritmus, ami a fenti két programról és ezekkel együtt tetszőleges programról meg tudná mondani, hogy meg fog-e állni vagy végtelen ciklusba esik. Tehát nincs olyan program, aminek a bemenetéül megadva a fenti két program egyikét, 
                        vagy egy tetszőleges más programot, a program lefutna és kiírná, hogy meg fog-e állni az inputként kapott program vagy végtelen ciklusba esik.                         
                    </para>
                    
                </sect4>
                
                <sect4 id="bonyolultsag">
                    <title>A Chaitin-Kolmogorov bonyolultság</title>
                    
                    <blockquote>
                        <attribution>MÁTRIX</attribution>
                        <para>„Kövesd a fehér nyulat!” </para>
                    </blockquote>                    

                    <warning>
                        <title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>
                        <para>
                            Ebben a pontban felhasználunk néhány Java nyelvű programot. 
                            Ezek igen egyszerűek, de annak, aki még nem ismeri a 
                            Java nyelvet, meglehet, teljesen olvashatatlanok, 
                            ismeretlen jelentésűek. Fontos, hogy ők még véletlenül se tekintsenek úgy ezekre a programokra, mint Java bevezetésre, mint az első Java programjaikra, mert ezek nem erre a célra készültek. Most csupán annyi a fontos, hogy a program mit ír ki és hány karakterből áll. Az előbbit mi leírjuk, az utóbbit könnyen megszámolhatja a kezdő Olvasó is, természetesen a program bármilyen feldolgozása, megértése nélkül. 
                        </para>
                    </warning>
                    
               <example>
                    <title>Első sorozat: 1000 nulla</title>                    
                    
                    <para>Tekintsük a következő 1000 darab nullából álló mondatot!</para>
                    
                    <screen>
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000
                    </screen>
                    
                    <para>Nézzünk most meg az <classname>ElsőSorozat1</classname>
                    nevű programot, ami éppen ezt a sztringet nyomtatja ki:
                        
                        <programlisting>
                            <![CDATA[
public class ElsőSorozat1 {
    
    public static void main(String[] args) {
        
        System.out.print("000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        0000000000");
        
    }    
}                            
                            ]]>
                        </programlisting>
                        
                    </para>
                    
                    <para>Ez a program 1082 karakterből áll (az egyszerűség kedvéért a szóközöket nem számoljuk).</para>
                    
               </example> 
               <example>
                    <title>Első sorozat, máshogy: 1000 nulla</title>                    
               
                    <para>                    
                    Nézzünk meg az <classname>ElsőSorozat2</classname>
                    nevű programot, ami szintén ugyanezt a sztringet nyomtatja ki:
                        
                        <programlisting>
                            <![CDATA[
public class ElsőSorozat2 {
    
    public static void main(String[] args) {

        for(int i=0; i<1000; ++i)
            System.out.print(0);

    }
}                                   
                            ]]>
                        </programlisting>
                        
                    </para>
                    
                    <para>Ez a program már csupán 103 karakterből áll. 
                    Ebben az egyszerű esetben könnyen látható, hogy néhány karakterrel 
                    rövidebb Java forrásprogramot is lehetne készíteni
                     - de ezt általában nem lehet tudni - nekünk mindenesetre most 
                     ez a legrövidebb
                    olyan programunk, ami kinyomtatja az 1000 darab nullát. </para>

               </example> 
               <example>
                    <title>Második sorozat: 01010101 ...</title>                    
                                        
                    <para>Tekintsük az újabb 1000 darab karakterből álló mondatot:</para>
                    
                    <screen>
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
0101010101010101010101010101010101010101
                    </screen>
                    
                    <para>Ezt a sztringet nyomtatja ki a 
                    <classname>MásodikSorozat1</classname> nevű program:
                        
                        <programlisting>
                            <![CDATA[
public class MásodikSorozat1 {
    
    public static void main(String[] args) {

        for(int i=0; i<500; ++i)
            System.out.print("01");

    }
}                            
                            ]]>
                        </programlisting>                    
                        
                    </para>
                    
                    <para>Ez a program 108 karakterből áll.</para>
                    
               </example> 
               <example>
                    <title>Harmadik sorozat: 00000000001 ... 10000000000</title>                    
                    
                    <para>Tekintsük a harmadik 1000 darab karakterből álló mondatot:</para>
                    <screen>
00000000001111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111110000000000
                    </screen>
                    <para>Ezt a sztringet nyomtatja ki a 
                    <classname>HarmadikSorozat1</classname> nevű program:
                        
                        <programlisting>
                            <![CDATA[
public class HarmadikSorozat1 {
    
    public static void main(String[] args) {
        
        System.out.print("0000000000");

        for(int i = 0; i<980; ++i)
            System.out.print("1");
        
        System.out.print("0000000000");
        
    }
}                            
                            ]]>
                        </programlisting>                    
                        
                    </para>
                    
                    <para>Ez a program 170 karakterből áll.</para>
                    
               </example> 
               <example>
                    <title>Negyedik sorozat: egyre több 1 jegy két nulla között</title>                    
                    
                    <para>Tekintsük a negyedik 1000 darab karakterből álló mondatot, 0 számjegyek között egyre több 1 számjegy van:</para>
                    <screen>
00101101110111101111101111110111111101111111101111111110111111111101111111111101
11111111111011111111111110111111111111110111111111111111011111111111111110111111
11111111111011111111111111111101111111111111111111011111111111111111111011111111
11111111111110111111111111111111111101111111111111111111111101111111111111111111
11111011111111111111111111111110111111111111111111111111110111111111111111111111
11111101111111111111111111111111111011111111111111111111111111111011111111111111
11111111111111110111111111111111111111111111111101111111111111111111111111111111
10111111111111111111111111111111111011111111111111111111111111111111110111111111
11111111111111111111111111011111111111111111111111111111111111101111111111111111
11111111111111111111101111111111111111111111111111111111111101111111111111111111
11111111111111111111011111111111111111111111111111111111111110111111111111111111
11111111111111111111111011111111111111111111111111111111111111111101111111111111
1111111111111111111111111111111111111111
                    </screen>
                    
                    <para>Ezt a sztringet nyomtatja ki a 
                    <classname>NegyedikSorozat1</classname> nevű program:
                        
                        <programlisting>
                            <![CDATA[
 public class NegyedikSorozat1 {
    
    public static void main(String[] args) {
        
        for(int i=0; i<44; ++i) {
            
            System.out.print(0);
            
            for(int j=0; j<i; ++j)
                System.out.print(1);
            
        }

        System.out.print("1111111111");
        
    }
}                           
                            ]]>
                        </programlisting>                    
                        
                    </para>
                    
                    <para>Ez a program 177 karakterből áll.</para>

               </example> 
               <example>
                    <title>Ötödik sorozat: pszeudo véletlen</title>                    
                    
                    
                    <para>Tekintsük az ötödik 1000 darab karakterből álló, meglehetősen rendszertelennek tűnő mondatot:</para>
                    <screen>
01011010000010010000111000111110111100010100100111101001000000010100100011101010
01111111010000001001000011011000101011110010011010100010010000010110011001000101
01100110010001101001110000110101110011111011010001101110001010010000001110011110
00101001001111100100111101101111000110111011010011110000101001010000111110000100
01110110011100101011000000011011111011011101101110110110000101010110011000100111
00111010110001111010011110100000011110101011100001101100001111001001010101000000
01111111101100000100001000001000000011111000101010111111000000010001111101110100
11010001011010011111010100111010100110101101011011110011001101011011011101101111
00110111000100101011111111111111000001010111100110100101001101111011001000100100
10111011000111101110000110010011010100110111101011001011101011011110110100100011
10001111100010100010111111100100010010111010000001110001101010101000001100100100
10011110000110110111001111110101101011110101100011001100001011010100001111111010
0000100111011101010100101101001110010001
                    </screen>
                    
                    <para>Ezt a sztringet nyomtatja ki az 
                    <classname>ÖtödikSorozat1</classname> nevű program:
                        
                        <programlisting>
                            <![CDATA[
 public class ÖtödikSorozat1 {
    
    public static void main(String[] args) {
        
        System.out.print("010110100000100100001110001111101111000101001001111010
        010000000101001000111010100111111101000000100100001101100010101111001001
        101010001001000001011001100100010101100110010001101001110000110101110011
        111011010001101110001010010000001110011110001010010011111001001111011011
        110001101110110100111100001010010100001111100001000111011001110010101100
        000001101111101101110110111011011000010101011001100010011100111010110001
        111010011110100000011110101011100001101100001111001001010101000000011111
        111011000001000010000010000000111110001010101111110000000100011111011101
        001101000101101001111101010011101010011010110101101111001100110101101101
        110110111100110111000100101011111111111111000001010111100110100101001101
        111011001000100100101110110001111011100001100100110101001101111010110010
        111010110111101101001000111000111110001010001011111110010001001011101000
        000111000110101010100000110010010010011110000110110111001111110101101011
        110101100011001100001011010100001111111010000010011101110101010010110100
        1110010001");
        
    }
}                           
                            ]]>
                        </programlisting>                    
                        
                    </para>
                    
                    <para>Ez a program 1084 karakterből áll.</para>
                    
               </example> 
                    
                    <para>Összegezzük eredményeinket!</para>
                                        
                    <table frame="all"><title>A bonyolultságmérő programok összefoglalása.</title>
                        <tgroup cols="3">
                            <thead>
                                <row>
                                    <entry>
                                        <para>SOROZAT</para>
                                    </entry>
                                    <entry>
                                        <para>PROGRAM</para>
                                    </entry>
                                    <entry>
                                        <para>MÉRET</para>
                                    </entry>
                                </row>                                
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                        <para>Első sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>ElsőSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>1082</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para> </para>                                         
                                    </entry>
                                    <entry>
                                        <para>ElsőSorozat2</para>
                                    </entry>
                                    <entry>
                                        <para>103</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Második sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>MásodikSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>108</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Harmadik sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>HarmadikSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>170</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Negyedik sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>NegyedikSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>177</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Ötödik sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>ÖtödikSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>1084</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                                        
                    <para>Chaitin után azt a sorozatot tekintjük kevésbé bonyolultnak, amit rövidebb programmal sikerült generálni. E definíció alapján az iménti sorozatok egyre bonyolultabbak voltak. Bár az elsőre is adtunk egy 1082 karakteres programot, de rögtön utána találtunk egy csupán 103 karakteres programot. Intuíciónkkal jó összhangban van ez a megközelítés, mert az utolsó sorozatra nemigen tudunk az 1084 hosszú programnál rövidebbet írni, mert nincs benne olyan szabályosság, amit beprogramozva tömörítést érhetnénk el.</para>

               <example>
                    <title>Bármely sorozat: egy másoló program</title>                    
                    
                    <para>Vagy mégis? Tekintsük most meg a következő másoló programot!</para>

                        <programlisting>
                            <![CDATA[
public class TetszőlegesSorozat1 {
    
    public static void main(String[] args) throws Exception {
        
        int i = 0;
        while((i=System.in.read()) != -1)
            System.out.printf("%c", i);

    }    
}
                            ]]>
                        </programlisting>                    
                    
                    <para>Működése a szokásos: abban áll, hogy a bemenetét a kimenetére másolja. Így ezzel is ki tudom nyomtatni bármelyik sorozatot! A program hossza pedig csak 147 betű! </para>
                    <para>A program inputjaként megkapva az ötödik sorozatot:</para>
     
                    <screen>
                            <![CDATA[
C:\...> echo 0101101000001001000011100011111011110001010010011110100100000001010
01000111010100111111101000000100100001101100010101111001001101010001001000001011
00110010001010110011001000110100111000011010111001111101101000110111000101001000
00011100111100010100100111110010011110110111100011011101101001111000010100101000
01111100001000111011001110010101100000001101111101101110110111011011000010101011
00110001001110011101011000111101001111010000001111010101110000110110000111100100
10101010000000111111110110000010000100000100000001111100010101011111100000001000
11111011101001101000101101001111101010011101010011010110101101111001100110101101
10111011011110011011100010010101111111111111100000101011110011010010100110111101
10010001001001011101100011110111000011001001101010011011110101100101110101101111
01101001000111000111110001010001011111110010001001011101000000111000110101010100
00011001001001001111000011011011100111111010110101111010110001100110000101101010
00011111110100000100111011101010100101101001110010001|java TetszőlegesSorozat1
                            ]]>
                    </screen>
                    
                    <para>Ha megnyomva az entert lefuttatjuk, akkor kiírja az ötödik sorozatunkat. 
                    Ezért a fenti bonyolultság definíciónkat ki kell bővítenünk, mert emlékezzünk
                    vissza, most egy 147 karakteres programmal és egy kis trükkel - nevezetesen, hogy
                    inputként adtuk meg a kívánt sorozatot - sikerült generálnunk az ötödik
                    sorozatunkat.</para>

               </example>
                    
                    <para>Egy x sorozat 
                    <emphasis>Chaitin-Kolmogorov bonyolultságának</emphasis>
                    annak a program kódjának és inputjának 
                    az együttes hosszát nevezzük, ami 
                    program kinyomtatja x-et és az ilyen programok között 
                    a legkisebb. 
                    Ennek megfelelően korábbi összefoglaló táblázatunk most az alábbi alakot ölti.</para>

                    <table frame="all">
                        <title>A bonyolultságmérő programok és bemenetük együttes összefoglalása.</title>
                        <tgroup cols="5" align="left" colsep="1" rowsep="1">
                            <thead>
                                <row>
                                    <entry>
                                        <para>SOROZAT</para>
                                    </entry>
                                    <entry>
                                        <para>PROGRAM</para>
                                    </entry>
                                    <entry>
                                        <para>KÓD MÉRET</para>
                                    </entry>
                                    <entry>
                                        <para>INPUT</para>
                                        <para>MÉRET</para>
                                    </entry>
                                    <entry>
                                        <para>A bonyolultság felső becslése</para>
                                    </entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                        <para>Első sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>ElsőSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>1082</para>
                                    </entry>
                                    <entry>
                                        <para>0</para>
                                    </entry>
                                    <entry>
                                        <para>1082</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                         
                                    </entry>
                                    <entry>
                                        <para>ElsőSorozat2</para>
                                    </entry>
                                    <entry>
                                        <para>103</para>
                                    </entry>
                                    <entry>
                                        <para>0</para>
                                    </entry>
                                    <entry>
                                        <para>103</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                         
                                    </entry>
                                    <entry>
                                        <para>TetszőlegesSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>147</para>
                                    </entry>
                                    <entry>
                                        <para>1000</para>
                                    </entry>
                                    <entry>
                                        <para>1147</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Második sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>MásodikSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>108</para>
                                    </entry>
                                    <entry>
                                        <para>0</para>
                                    </entry>
                                    <entry>
                                        <para>108</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                         
                                    </entry>
                                    <entry>
                                        <para>TetszőlegesSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>147</para>
                                    </entry>
                                    <entry>
                                        <para>1000</para>
                                    </entry>
                                    <entry>
                                        <para>1147</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Harmadik sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>HarmadikSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>170</para>
                                    </entry>
                                    <entry>
                                        <para>0</para>
                                    </entry>
                                    <entry>
                                        <para>170</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                         
                                    </entry>
                                    <entry>
                                        <para>TetszőlegesSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>147</para>
                                    </entry>
                                    <entry>
                                        <para>1000</para>
                                    </entry>
                                    <entry>
                                        <para>1147</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Negyedik sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>NegyedikSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>177</para>
                                    </entry>
                                    <entry>
                                        <para>0</para>
                                    </entry>
                                    <entry>
                                        <para>177</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                         
                                    </entry>
                                    <entry>
                                        <para>TetszőlegesSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>147</para>
                                    </entry>
                                    <entry>
                                        <para>1000</para>
                                    </entry>
                                    <entry>
                                        <para>1147</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Ötödik sorozat</para>
                                    </entry>
                                    <entry>
                                        <para>ÖtödikSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>1084</para>
                                    </entry>
                                    <entry>
                                        <para>0</para>
                                    </entry>
                                    <entry>
                                        <para>1084</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                         
                                    </entry>
                                    <entry>
                                        <para>TetszőlegesSorozat1</para>
                                    </entry>
                                    <entry>
                                        <para>147</para>
                                    </entry>
                                    <entry>
                                        <para>1000</para>
                                    </entry>
                                    <entry>
                                        <para>1147</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                    
                    <para>Helyreállt tehát a világ rendje, miután a program kódjának 
                    és inputjának együttes hosszát tekintettük a 
                    bonyolultság definíció alapjának. 
                    Azt vegyük észre, hogy nem bonyolultságról, hanem a bonyolultság felső becsléséről beszélünk: azaz egy olyan számról, aminél a valódi bonyolultság kisebb, esetleg egyenlő lehet. Mert ugye jöhet egy 
                    nálunk nagyobb hekker, aki még rövidebben megírja...</para>
                    <para>Miért jó nekünk ez a bonyolultság fogalom? Mert rá építve értelmesen tudjuk definiálni, hogy mit jelent véletlen sorozatnak lenni. De a fenti Java nyelvű, intuitív megalapozás után mindenekelőtt 
                    pontosabban definiáljuk a Chaitin-Kolmogorov bonyolultságot.
                    </para>
                    <para>Egy x sorozat <emphasis>Chaitin-Kolmogorov
                    bonyolultságának</emphasis>
                    annak a Turing gépnek (T) és inputjának (y) az együttes hosszát nevezzük, ami kiszámolja x-et az Univerzális Turing gépen és az ilyenek között a legrövidebb.
                    </para>
                    
                    <para>                    
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/ck_bonyolultsag1.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az U gép a T algoritmusból és a T y bemenetéből kiszámítja az x szót.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                    
                    </para>
                    <para>Itt a legrövidebb nem a futási időre vonatkozik, hanem, ahogy a Java példáknál is láttuk, a programok és az input együttes hosszára. Egészen konkrétan ez annyit jelent, hogy megszámoljuk az U gép szalagján az induláskor az input, azaz a T és az y 0 és 1 jegyekkel való megadása, lekódolása mennyi cellát foglal el.</para>
                    <para>A Chaitin-Kolmogorov bonyolultság egyébként programozóknak nagyon szemléletes: a vizsgált sorozat bonyolultsága csakis kisebb vagy egyenlő lehet annak az algoritmusnak (Turing gépnek) és az algoritmus bemenetének együttes hosszánál, amely algoritmus produkálni tudja ezt a sorozatot.</para>
                    <para>De micsoda fájdalom annak az Olvasónak, 
                    aki máris program írását tervezte arra, hogy kiszámolja a Chaitin-Kolmogorov bonyolultságot, 
                    például az alábbi példa mintájára.
                    </para>
                    
                    <para>                                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/ck_bonyolultsag2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A feltételezett program, bemenetül például a Bibliával.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                    </para>                                        
                    <para>                                                            
                        Mert fájdalom, de könnyen 
                        belátható - amit a következő példában meg is teszünk - 
                        hogy nem létezik olyan Turing gép, ami 
                        ezt képes lenne megtenni, ebből már tudjuk, hogy 
                        nincs olyan algoritmus, ami képes lenne ezt megtenni, 
                        tehát hasztalan lenne ilyen program írásával 
                        próbálkozni! (Nyilván ennek a lehetetlenségnek nincs 
                        köze ahhoz, hogy a példa bemenet a Biblia volt :)
                   </para>

                   
                   <warning>
                    <title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>                           
                       <para>
                           A következő állítás bizonyításaként
                           szereplő Java programot csak fussa át a kezdő Olvasó,
                           hogy szeme szokja a Java nyelvet.
                           Ha eközben a megértésben bármi 
                           zavar támadna - s a teljesen kezdőknek nyilván támadni fog - akkor
                           most bátran hagyja ki, s az utána szereplő ábrán
                           győződjön meg az állítás igazságáról.
                       </para>
                   </warning>                       
                                      
                   <example>
                       <title>A Chaitin-Kolmogorov bonyolultság nem kiszámítható!</title>
                   <para>
                       Programozóknak ez annyira fájdalmas megállapítás, 
                       hogy a kedves Olvasó meggyőzésére
                       magunk is belátjuk ezt az állítást, bizonyításaként megadjuk
                       a <citation>LOVÁSZ KÖNYV</citation> ugyanezen bizonyítását
                       megadó Pascal program Java változatát.
                   </para>
                       
                   <para>
                       Tegyük fel tehát, hogy van olyan algoritmus, ami kiszámolja a 
                       Chaitin-Kolmogorov bonyolultságot, ha ezt beprogramozza az
                       Olvasó, akkor a következő kódhoz hasonlót készít.
                   </para>

                    <programlisting>
                            <![CDATA[
public class ChaitinKolmogorov {

    /** A bonyolultság() függvényben lévő bekommentezett rész mérete. */
    public static final int BONYOLULTSÁG_FGV_HOSSZA = 10000;
    
    public static void main(String[] args) {
        
        int i=0;
        String sorozat = null;
        
        while(true) {
            
            sorozat = Integer.toBinaryString(i++);
            if(bonyolultság(sorozat) > 10 * BONYOLULTSÁG_FGV_HOSSZA)
                break;
            
        }
        
        System.out.println(sorozat);
    }
    
    public static long bonyolultság(String sorozat) {
        
        long bonyolultság = 0;
        
        /*
         * Itt van lekódolva az az algoritmus, ami
         * feltevésünk szerint létezik és kiszámítja
         * a paraméterként kapott sorozat bonyolultságát.
         * Ennek a résznek a hossza legyen mondjuk
         * 10000, tízezer betű.
         */
        
        return bonyolultság;
    }
    
}
                            ]]>
                        </programlisting>                    

                        <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/ck_bonyolultsag3.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A feltételezett Chaitin-Kolmogorov bonyolultságot kiszámító program.</phrase>
                            </textobject>	
                        </inlinemediaobject>                        
                        </para>
                        
                       <para>
                        Ha meglenne a program, akkor fordítanánk, futtatnánk...
                        Feltevésünk értelmében megvan, tehát képzeljük el, hogy
                        futtatjuk: amikor megáll, akkor kiír egy olyan szót,
                        aminek a bonyolultsága &gt; 100000, hiszen a <function>main</function>
                        függvény
                        végtelen ciklusából akkor ugrunk ki a 
                        <computeroutput>break</computeroutput> utasítással,
                        amikor ez a feltétel teljesül. De hiszen ez a program
                        input nélkül futott, mérete 10000+360 betű, a 
                        <function>bonyolultság()</function>
                        függvényének bekommentezett része helyetti valódi rész
                        mérete + a maradék többi. Tehát 10360 karakteres programmal 
                        kiszámoltuk (kiírtuk) ezt a sorozatot, ezért bonyolultsága
                        ennél csak kisebb egyenlő lehet. Hoppá! Döbbenetes, 
                        nem igaz? Jó kis ellentmondás, ami lehetetlenné teszi
                        feltevésünk helyességét, tehát annak ellenkezője igaz, 
                        vagyis, hogy
                        nem létezik olyan algoritmus, amivel tetszőleges szóról
                        kiszámolhatnánk a szó bonyolultságát.
                       </para>
                        
                   </example>
                   
                   <example>
                       <title>A Chaitin-Kolmogorov bonyolultság gyakorlati alkalmazásai</title>
                       
                        <para>
                            A Chaitin-Kolmogorov bonyolultság több nagyon 
                            érdekes gyakorlati alkalmazásáról olvashatunk például a
                            <citation>VITÁNYI HASONLÓSÁG CIKK</citation> cikkben.
                            Itt a szerzők a Chaitin-Kolmogorov bonyolultságból
                            egy távolság fogalmat, a hasonlósági metrikát származtatják,
                            aminek rögtön bemutatják két gyakorlati alkalmazását is. 
                            Az első alkalmazás során 20 faj mitokondriális 
                            DNS-e alapján filogenetikai
                            fát építenek, s a kapott eredményt a hagyományos módszerek
                            tükrében is bemutatják. A másikban 52 emberi nyelvet 
                            hasonlítanak össze és ugyancsak bemutatják az eredményeket
                            összefoglaló, a tárgyalt nyelvekre vonatkozó filogenetikai fát.
                            Érdekességként megjegyezhetjük, hogy vizsgált nyelvek
                            között találjuk anyanyelvünket is.
                            A cikkben megvizsgált nyelvek összehasonlítását az ENSZ 
                            <ulink url="http://www.un.org/Overview/rights.html">weblapján</ulink>                            
                            a szóban forgó nyelveken megtalálható 
                            <emphasis>Az Emberi Jogok Egyetemes Nyilatkozatának</emphasis>
                            fordításai alapján, ezeket a fordításokat korpuszonak
                            tekintve végezték el.
                        </para>
                        
                        <para>
                            A <citation>HANGYÁK és KOLMOGOROV CIKK</citation>
                            cikkben a szerzők hangyákkal hajtanak végre egy
                            kísérletet. Az élelemhez vezető utat egy bináris
                            fa formájában teszik lehetővé a hangyáknak, tehát
                            a kísérleti elrendezésben a hangyák nyelvén a 
                            <computeroutput>LLRL</computeroutput> azt jelenthetné,
                            hogy először fordulj balra, majd megint balra, aztán
                            jobbra végül balra, hogy elérd a táplálékot. A gyakorló
                            hangyászok megnyugtatására mondhatjuk, hogy a szerzők
                            az egész
                            kísérleti berendezést egy vízzel teli kádba helyezték,
                            így megakadályozták, hogy a hangyák levágják a kanyarokat.
                            A kísérleti eredmények mutatják, hogy a bonyolultabb
                            utakról a felfedező hangyának több időre van szüksége,
                            hogy a többiekkel a táplálék forrás helyéről szóló,
                            feltételezetten <computeroutput>LLRL</computeroutput> 
                            jellegű szerkezettel bíró információt megossza.
                            
                        </para>
                        
                        <para>
                            A mobil játékfejlesztés egy 
                            formális modelljének megadására használják fel 
                            a bonyolultságot a <citation>MOBIL JÁTÉK ÉLMÉNY</citation>
                            cikkben. 
                            A szerzők által javasolt modellben a 
                            (számítógépes) játék egy a játék fejlesztője és a játék
                            felhasználója közötti kommunikációs csatorna.
                            Grafikusan ezt a Shannon eredeti 
                            <citation>SHANNON INFÓELM CIKK</citation>
                            és Benczúr által
                            némileg módosított 
                            <citation>BENCZÚR CIKK</citation>
                            ismert séma alábbi átalakításával szemléltethetjük:                          
                          </para>
                          <para>
                                <inlinemediaobject>
                                    <imageobject>
                                        <imagedata fileref="images/prog/model.png" />
                                    </imageobject>
                                    <textobject>
                                        <phrase>A játék a fejlesztő és a játékos közötti kommunikációs csatorna.</phrase>
                                    </textobject>	
                                </inlinemediaobject>                                                                                          
                         </para>                            
                         <para>
                             A hivatkozott cikkben a szerzők definíciót adnak a jó játékra és
                             megmutatják, hogy a jó játékok nyelve nem rekurzív, azaz
                             nincs olyan általános mechanisztikus eljárás, amivel
                             el lehetne dönteni tetszőleges játékról, hogy jó lesz-e.
                         </para>
                         
                   </example>
                                      
                   <sect5 id="feladat_01">
                       <title>0, 1 feladatok</title>
                                              
                       <warning>
                        <title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>                           
                           <para>
                               A következő Java nyelvű példák mindenféle
                               egyszerű gyakorlatok a 0 és az 1 jegyekkel, 
                               bitekkel.
                               Az első átvált kettes számrendszerbe, a második
                               egy bitműveleteket használó bináris dump 
                               (megmutatja a bájtok bitjeit), a harmadik
                               egy ugyancsak bitműveletes titkosító példa.
                               A negyedik egy
                               számrendszer átváltásos példa.
                               Az ötödik pedig egy Turing gépet kódol le egy 0 és 
                               1 jegyekből álló sorozattá. 
                           </para>
                           <para>                               
                               Ezen példák forrásait csupán fussa át a kezdő Olvasó,
                               hogy szeme szokja a Java nyelvet.
                               Ha eközben a források megértésében bármi 
                               zavar támadna - és a teljesen kezdőknél nyilvánvalóan támadni fog - akkor
                               most bátran hagyja ki őket, s
                               ha majd első labirintusos Java programjaink 
                               kipróbálásához érkezik az anyag feldolgozásában, 
                               az után térjen vissza ide és írja meg (próbálja ki)
                               ezeket a programokat.
                           </para>
                           <para>                               
							   Megjegyezhetjük, hogy ebben a Programozás papíron című részben
							   általában is elegendő a szereplő forrásokra csak egy pillantást
							   vetni és inkább a programok használatát, működését
							    megfigyelni: hogyan indítjuk, milyen bemenettel fut,
							   mit ír ki a képernyőre stb. Természetesen mindezt nem egy gép előtt
							   kipróbálva, hanem az általunk a kézikönyvbe illesztett néha Linuxos,
							   néha Windowsos 
							   pillanatfelvételeket megfigyelve.
                           </para>
                       </warning>
                                                  
                       <example>
                           <title>Átváltás binárisba</title>
                        <para>Már többször szóba került a 0, 1 jegyekkel 
                        való lekódolás. Lépjünk ebbe az irányba 
                        egy picikét! Lássuk azt a Java 
                        programot, ami a bemenetét 0, 1 sorozattá 
                        alakítja. Ezt a programot a korábbi 
                        <filename>TetszőlegesSorozat1</filename> program 
                        továbbfejlesztéseként fejlesszük ki! 
                        Következik néhány megoldás, a kezdő Olvasó ezeket, 
                        ahogy megbeszéltük, rövid átfutás után most egyszerűen át
                        is ugorhatja! 
                        (Mert ez nemhogy nem OO programozás bevezető példa, de majd még bitfaragásba is fajul...)</para>

                            <programlisting>
                            <![CDATA[
public class NullaEgy {
    
    public NullaEgy() {
        
        int i = 0;
        try {
            
            while((i=System.in.read()) != -1)
                System.out.printf("%s", Integer.toBinaryString(i));
            
        } catch(java.io.IOException e) {
            
            System.out.println("Hiba az olvasáskor, kilépek. " + e);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        new NullaEgy();
        
    }    
}
                            ]]>
                            </programlisting>                    

                        <para>Bájtonként olvassuk a program bemenetét, 
                        amit a Java programozó számára a 
                        <computeroutput>System.in</computeroutput> objektum
                        reprezentál. Ennek az objektumnak a 
                        <function>read()</function> módszere egy bájtot
                        olvas be, azaz a beolvasás eredménye egy 
                        00000000<subscript>(bináris)</subscript> (0) és  
                        11111111<subscript>(bináris)</subscript> (255) közé eső szám.
                        Ha viszont már nem lehet mit olvasni a 
                        <computeroutput>System.in</computeroutput> 
                        bemenet objektumról, akkor a                         
                        <function>read()</function>
                        függvénye ezt a -1 érték visszaadásával jelzi.
                        Ezt azért tudja megtenni, mert a 
                        <function>read()</function>
                        függvény int típusú értéket ad vissza, ami
                        nem csupán a 0-tól 255-ig tartó intervallumba
                        eső számokat képes hordozni, hanem ennél jóval-jóval
                        nagyobb tartományt, a negatív 
                        -2<superscript>31</superscript>-től 
                        (ami szokásosan kiírva -2147483648) 
                        egészen a 
                        2<superscript>31</superscript>-1-ig 
                        (ami kiírva 2147483647).
                        </para>
                        
                        <para>
                        A program <computeroutput>while</computeroutput> ciklusa törzsének egyetlen
                        magányos utasítása nem csinál mást, mint
                        egyszerűen kiírja a -1 számtól különböző 
                        beolvasott számot kettes 
                        számrendszerben az 
                        <classname>Integer</classname> osztály
                        statikus <function>toBinaryString(egészet vár)</function>
                        bináris sztringet visszaadó 
                        (az iménti bizonyítás forrásában már használt) 
                        függvényével. 
                        </para>
                        
                        <para>                        
                        De a bitfaragókat ez a program nem elégíti 
                        ki, több okból sem: a kapott 0,1 bináris 
                        sorozatot nem lehet visszaalakítani  -  
                        meg tudja mondani a kedves Olvasó, hogy miért nem? 
                        Ha nem, akkor próbálja 
                        megtenni mondjuk a 
                        <computeroutput>012abc</computeroutput> betűket
                        tartalmazó <filename>bemenet.txt</filename>
                        állománnyal! A bemenetet triviálisan úgy tudjuk megadni, 
                        hogy kiadjuk a <command>java NullaEgy</command>
                        parancsot, ami elindítja Java programunkat, majd 
                        begépeljük a <userinput>012abc</userinput> inputot
                        és entert nyomunk. De ennél jóval elegánsabb, ha a 
                        <filename>bemenet.txt</filename> állomány tartalmát
                        parancssorból küldjük programunk bemenetére. Két
                        módot mutatunk erre, az elsőben a &lt; jel szemléletesen
                        mutatja az irányítást. Az Olvasó, ha gép előtt ülne, akkor 
                        (a fenti tartalmú <filename>NullaEgy.java</filename> forrásállomány
                        létrehozása, majd lefordítása után) ezt láthatná egy 
                        parancsablakában:
                        
                       <screen>
                            <![CDATA[
C:\...> java NullaEgy < bemenet.txt
110000110001110010110000111000101100011                            
                            ]]>
                        </screen>                        

                        másik lehetőség a | (csővezeték jel) használata, ami
                        a bal oldalán lévő parancs kimenetét a jobb oldalán
                        lévő bemenetére (cső)vezeti:
                        
                       <screen>
                            <![CDATA[
C:\...> type bemenet.txt|java NullaEgy
110000110001110010110000111000101100011
                            ]]>
                        </screen>                        
                        
                        Most a lényeghez visszatérve: ha 8 bitenként vissza akarjuk váltani
                        a kapott 
                        <computeroutput>110000110001110010110000111000101100011</computeroutput>
                        kimenetet, akkor gondban vagyunk, mert ez csak 39 jegy,
                        nekünk pedig az átváltáshoz 6x8 jegy kellene. A problémát az
                        okozta, hogy az átváltott bináris számok nem voltak 8 jeggyel
                        kiírva, hanem mindig csak annyival, amekkora az adott szám volt:
                        
                       <screen>
                            <![CDATA[
0 48 110000
1 49 110001
2 50 110010
a 97 1100001
b 98 1100010
c 99 1100011                            
                            ]]>
                        </screen>                        
                        
                        ezért nem tudnánk ezt a kódolást dekódolni, mert honnan
                        tudnánk, hogy az elejétől elindulva éppen 6, 7 vagy nyolc
                        jegyenként kéne visszaváltani a bitmintákat?
                        </para>
                        
                        <para>                                                
                        A másik ok, ami miatt a bitfaragókat nem elégíti ki a
                        tárgyalt program, hogy 
                        az <classname>Integer</classname> osztály 
                        statikus metódusának hívásával túl
                        egyszerűen jutnak a bináris számhoz, 
                        ezért írnak egy jobbat bitműveletekkel...
                        </para>
                        </example>

							 <note>
								<title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>                           
								   <para>
									   Ha az előző forrást átugrottuk, akkor a most
									   következő <classname>NullaEgyDump</classname> forrás
									   kihagyása még indokoltabb.
								   </para>
								   <para>
								   Aki viszont már nem kezdő és bele akar gabalyodni, annak 
								   is csak annyi iránymutatást adunk, hogy az <varname>egye</varname>
								   változóba a 
								   <computeroutput>00000000000000000000000010000000</computeroutput>
								   mintát az éppen vizsgált bájttal beéselve tesszük, aminek 
								   eredménye a   
								   <computeroutput>00000000000000000000000000000000</computeroutput>, 
								   ha a vizsgált bájt balról első bitje 0 és 
								   <computeroutput>00000000000000000000000010000000</computeroutput>, 
								   ha a vizsgált bájt balról első bitje 1. Aztán az 
								   <varname>egye</varname> változó bitmintáját jobbra tologatjuk,
								   a vizsgált bájt bitjeit pedig balra...								   
								   </para>
							   </note>                            


                        <example id="binaris_dump">
                            <title>Bitműveletek, kezdjük egy bináris dumppal</title>
                            <para>
                                Tehát ott tartottunk, hogy írunk egy
                                jobbat bitműveletekkel!
                            </para>
                                                        
                            <programlisting>
                            <![CDATA[
public class NullaEgyDump {
    
    public NullaEgyDump() {
                
        try {
            
            byte [] buffer = new byte[1];
            
            while(System.in.read(buffer) != -1) {
                
                for(int i=0; i<8; ++i) {

                    int egye = buffer[0] & 0x00000080;
                    
                    if((egye>>>7) == 1)
                        System.out.print(1);
                    else
                        System.out.print(0);

                    buffer[0] <<= 1;
                }
            }
            
        } catch(java.io.IOException e) {
            
            System.out.println("Hiba az olvasáskor, kilépek. " + e);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        new NullaEgyDump();
        
    }
    
}
                            ]]>
                            </programlisting>                    
                        
                        <para>Ez már egy igazi dump jellegű program lett: a bemenetét bájtonként veszi és kiírja a bájt nyolc bitjét. Próbáljuk ki így:</para>

                        <screen>
                            <![CDATA[
C:\...> java NullaEgyDump < NullaEgyDump.class
11001010111111101011101010111110000000000000000000000000001100100000000001000001
00001010000000000001000000000000000111010000100100000000000111100000000000011111
00001010000000000010000000000000001000010000100100000000000111100000000000100010
...
                            ]]>
                        </screen>
                        <para>azaz beadva neki inputként a saját class állományát! 
                        Ellenőrizzük, hogy jó-e a kimenet! Az első 4x2x4 jegyet, 
                        ami a 
                        <computeroutput>11001010111111101011101010111110</computeroutput>, tegyük át hexába, 
                        ha az eredmény nem ugyanaz, mint a 
                        <emphasis><link linkend="bitfarago_feladat">Bitfaragó feladat</link></emphasis> 
                        című feladat megoldása, 
                        akkor <emphasis>„még van kanál”</emphasis> <citation>MÁTRIX MOZI</citation>,
                        azaz még dolgozzunk a megoldáson!</para>

                        </example>
                        
                        <para>Az utolsó 0,1 feladatként megírunk majd egy olyan 
                        programot, ami egy Turing gépet alakít át egy 
                        bináris szóvá, de előtte időzzünk még
                        kicsit a bitműveleteknél, a következő
                        klasszikus példánál!</para>
                        
                        <example id="exor_titkosito">
                            <title>Titkosítás kizáró vaggyal</title>
                            
                           <blockquote>
                                <attribution>Kernighan-Plauger
                                    <citetitle>A programozás magasiskolája</citetitle>
                                </attribution>
                                <para>
                                    „...ez a módszer az egyik legrégibb és
                                    legismertebb. Hacsak a kulcs nem nagyon
                                    hosszú, a CIA vagy az NSA várhatóan egy
                                    napon belül megfejti file-unkat.”
                                </para>
                            </blockquote>                            
                            
                            <para>
                                A kizáró vagyos titkosítás során a titkosítandó 
                                szöveg bájtjait lefedjük a titkosító kulcs bájtjaival
                                és az egymás alá eső biteken végrehajtunk egy
                                kizáró vagy műveletet. A kizáró vagy 1 értéket ad, 
                                ha a két bit
                                különböző és 0 értéket, ha megegyező.
                            </para>
                            
                            <para>
                                <inlinemediaobject>
                                    <imageobject>
                                        <imagedata fileref="images/prog/exor.png" />
                                    </imageobject>
                                    <textobject>
                                        <phrase>Kizáró vagyos titkosítás.</phrase>
                                    </textobject>	
                                </inlinemediaobject>                                                            
                              
                            </para>
                            <para>
                                                                
                                <screen>
                                        <![CDATA[
 11001011 - a tiszta szöveg egy bájtja
^10101100 - a kulcs bájtja
---------
 01100111 - kódolt szöveg, amit
^10101100 - újra beexorozzuk kulccsal
---------
 11001011 - az eredeti tiszta szöveg
                                        ]]>
                                </screen>
                                
                                a <citation>KERNIGHAN PROG KÖNYV</citation>-ben 
                                részletesen ismertetett eljárás érdekessége,
                                hogy a titkosítás újbóli végrehajtásával visszakapjuk
                                az eredeti szöveget. Mi ezt az algoritmust az
                                <classname>ExorTitkosító</classname> osztályban 
                                valósítottuk meg. S alább bemutatjuk ennek a
                                programnak egy felhasználását. Ha az Olvasó lefordítaná,
                                majd elindítaná 
                                az <userinput>alma</userinput>
                                parancssor-argumentummal, a program kimenetét pedig
                                átirányítaná a <filename>titkosított.szöveg</filename>
                                állományba, miközben a program indulása után annak
                                 bemenetére gépelné be a 
                                titkosítandó 
                                
                               <screen>
                                        <![CDATA[
Ez titkosítva lesz!
Titkosítva, bizony!
                                        ]]>
                                </screen>
                                                                
                                szöveget, akkor ezt látná:
                                
                                <screen>
                                        <![CDATA[
[norbi@niobe ~]$ javac ExorTitkosító.java
[norbi@niobe ~]$ java ExorTitkosító alma > titkosított.szöveg
Ez titkosítva lesz!
Titkosítva, bizony!
[norbi@niobe ~]$ more titkosított.szöveg
$LLk5
AALk
[norbi@niobe ~]$ java ExorTitkosító alma < titkosított.szöveg
Ez titkosítva lesz!
Titkosítva, bizony!                                                                                
                                        ]]>
                                </screen>

							 <note>
								<title>A Windows parancssorból dolgozóknak</title>
								
								<para>
								A Windows parancssorból dolgozó kedves Olvasó teljesen a
								Linux esetén mutatottak mintájára járhat el:
								
                                <screen>
                                        <![CDATA[
C:\...> javac ExorTitkosító.java
C:\...> java ExorTitkosító alma > titkosított.szöveg
Ez titkos lesz!

C:\...> type titkosított.szöveg
...olvashatatlan...Llk
C:\...> java ExorTitkosító alma < titkosított.szöveg
Ez titkos lesz!

C:\...>                                         
                                        ]]>
                                </screen>
								
								</para>
								
								</note>
                                
                                A titkosított szöveg láthatóan emberi fogyasztásra 
                                alkalmatlan. A dekódoláshoz nem kell mást tennie
                                az Olvasónak, mint újra futtatni a programot ugyanazzal
                                a kulccsal, de most bemenetként az iménti futtatáskor
                                elkészített titkosított szöveget beleirányítva
                                (<computeroutput>java ExorTitkosító alma &lt; titkosított.szöveg</computeroutput>)
                                . Az
                                eredmény a sztenderd kimeneten jelentkezik, azaz, amint
                                fent látta az Olvasó, a képernyőn látható.
                                
                                <programlisting>
                                <![CDATA[
public class ExorTitkosító {
    
    public ExorTitkosító(String kulcsSzöveg,
            java.io.InputStream bejövőCsatorna,
            java.io.OutputStream kimenőCsatorna)
            throws java.io.IOException {
        
        byte [] kulcs = kulcsSzöveg.getBytes();
        byte [] buffer = new byte[256];
        int kulcsIndex = 0;
        int olvasottBájtok = 0;

        while((olvasottBájtok =
                bejövőCsatorna.read(buffer)) != -1) {
            
            for(int i=0; i<olvasottBájtok; ++i) {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            kimenőCsatorna.write(buffer, 0, olvasottBájtok);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        try {
            
            new ExorTitkosító(args[0], System.in, System.out);
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();
            
        }
        
    }
    
}

                                ]]>
                                </programlisting>

                                A külső <computeroutput>while</computeroutput> 
                                ciklus buffer tömbönként addig olvassa a bemenetet, amíg csak 
                                tudja. A belső <computeroutput>for</computeroutput> ciklusban helyezzük rá a kulcsot a beolvasott bájtokra a
                                <varname>kulcsIndex</varname> változó segítségével, majd végrehajtjuk a kizáró vagy műveletet,
                                az eredmény a <varname>buffer</varname> tömbben keletkezik, amit végül a kimenetre írunk.
                                
                                <programlisting>
                                <![CDATA[
        while((olvasottBájtok =
                bejövőCsatorna.read(buffer)) != -1) {
            
            for(int i=0; i<olvasottBájtok; ++i) {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            kimenőCsatorna.write(buffer, 0, olvasottBájtok);
            
        }
        
                                ]]>
                                </programlisting>
                                                                
                            </para>
                            
                        </example>
                        
                        <example>
                            <title>Kizáró vagyos titkosítás grafikusan</title>
                            <para>    
                                Az iménti példát lássuk el grafikus felülettel! Egy ilyen felület
                                kinézetére láthatunk példát a Jávácska portál 
                                <ulink url="http://javacska.lib.unideb.hu">Jávácska titkosítójánál.</ulink>
                                Jelen saját megoldásunkat mi a 
                                <emphasis><link linkend="titkosito_gui">Bepillantás a GUI programozásba</link></emphasis>
                                című fejezetünkben adjuk meg. A példa érdekessége, hogy Swinges
                                grafikus felületet és legördülő menüt használ.
                            </para>    
                                
                        </example>

                        <example id="szamrendszer">
                            <title>Számrendszer átváltások</title>

                            <para>
                            A következő <classname>TörtÁtváltó</classname> osztály
                            törteket vált át valamilyen számrendszerbe. Például
                            megmondja, hogy a tízes számrendszerbeli 
                            5*16<superscript>-1</superscript>
                            + 0*16<superscript>-2</superscript>
                            + 15*16<superscript>-3</superscript>
                            = 0,316162109375 hexában 0.50F amint ezt a
                            következő, a <function>tízesből16osba()</function>
                            függvényben beprogramozott algoritmus 
                            - <emphasis>szorzok 16-tal, az eredmény egész
                            része a hexa számjegy, az eredmény törtrészét
                            megint
                            szorzom és így tovább, amíg a törtrész el
                            nem fogy</emphasis> -
                            adja:
                            
                                <screen>
                                0.316162109375 * 16 =  5.05859375
                                0.05859375     * 16 =  0.9375
                                0.9375         * 16 = 15.0
                                </screen>
                            
                                Az egész részek a helyes sorrendben
                                keletkeznek, leolvasva: 50F, tehát
                                0,316162109375<subscript>decimális</subscript>
                                = 0.50F<subscript>hexadecimális</subscript>
                                
                                </para>
                            <para>    
                                <programlisting>
                                <![CDATA[
public class TörtÁtváltó {
    
    public static String tízesből16osba(double tört) {
    
        StringBuffer sb = new StringBuffer();
        
        int számrendszer = 16;        
        
        Character hexaJegyek[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        
        while(tört != 0.0d) {
            
            int jegy = (int) Math.floor(számrendszer*tört);
            
            if(jegy<10)
                sb.append(jegy);
            else
                sb.append(hexaJegyek[jegy-10]);
            
            tört = (számrendszer*tört) - Math.floor(számrendszer*tört);
        }
        
        return sb.toString();
    }
    
    public static void main(String[] args) {
        
        double tört =
                + 0  * (1.0/16.0)
                + 15 * (1.0/(16.0*16.0))
                + 2  * (1.0/(16.0*16.0*16.0))
                + 10 * (1.0/(16.0*16.0*16.0*16.0))
                + 5 *  (1.0/(16.0*16.0*16.0*16.0*16.0));
        
        System.out.println(tört);
        System.out.println(TörtÁtváltó.tízesből16osba(tört));
        System.out.println(TörtÁtváltó.tízesbőlKettesbe(tört));
    }    
}
                                ]]>
                                </programlisting>
                                
                                Ha a kedves Olvasó fordítaná és futtatná a 
                                programot, akkor a következőket látná:
                                
                                <screen>
                                <![CDATA[
C:\...> javac TörtÁtváltó.java
C:\...> java TörtÁtváltó
0.05923938751220703
0F2A5                                
                                ]]>
                                </screen>

                            </para>    
                            
                            
                            <para>                                    
                                
                                A <function>tízesből16osba()</function> függvényben használt
                                kódot a 
                                <emphasis><link linkend="pi_jegyei">A Pi jegyeinek nyomában</link></emphasis>
                                című pont <classname>PiBBP</classname> osztályában
                                használjuk majd fel, ahol a Pi hexadecimális törtkifejtését
                                állítjuk elő.
                                
                            </para>    
                            
                        </example>

                        <example>
                            <title>A TörtÁtváltó osztály kiegészítése</title>

                            <para>                                    
                            Az iménti <classname>TörtÁtváltó</classname> osztályhoz
                            írjunk egy <function>tízesbőlKettesbe()</function>
                            függvényt!
                            
                                <programlisting>
                                <![CDATA[
    public static String tízesbőlKettesbe(double tört) {
    
        StringBuffer sb = new StringBuffer();
        
        int számrendszer = 2;        
        
        while(tört != 0.0d) {
            
            int jegy = (int) Math.floor(számrendszer*tört);
            
            if(jegy<10)
                sb.append(jegy);
            
            tört = (számrendszer*tört) - Math.floor(számrendszer*tört);
        }
        
        return sb.toString();
    }    
                                ]]>
                                </programlisting>
                    
                                A bővítést elvégezve újrafordítás
                                és futtatás után ezt látná az
                                Olvasó:
                                
                                <screen>
                                <![CDATA[
C:\...> javac TörtÁtváltó.java
C:\...> java TörtÁtváltó
0.05923938751220703
0F2A5                           
00001111001010100101
                                ]]>
                                </screen>
                                
                                ellenőrizve: 4 bitenként binárisból
                                hexába váltva valóban 0000 = 0,
                                1111 = F, 0010 = 2, 1010 = A, 0101 = 5.
                                
                            </para>                                
                            
                        </example>
                                                
                        <example>
                            <title>Turing gépek kódolása</title>

                            <para>    
                            Például az <citation>ALGORITMUSOK KÖNYV</citation>
                            206. oldalán javasolt kódolás alapján készítsünk
                            egy olyan programot, ami egy Turing gépet 0 és 1
                            jegyekből álló sorozattá alakít!
                            </para>    
                                
                        </example>
                                                
                        <para>
                            Barangoljunk a véletlen 0 és 1 jegyek birodalmában!
                            A következő pontban véletlen sorozatokkal találkozunk,
                            a reá következőben pedig leleplezzük, hogy ezek mégsem
                            véletlenek!                            
                        </para>
                
                </sect5>
                                                
                <sect5>
                    <title>Véletlen 0, 1 sorozatok</title>

                        <para> 
                            A következő program előállít egy véges 
                            véletlen sorozatot, egészen pontosan példányosít egy 
                            <classname>Random</classname> objektumot, 
                            majd egy ciklusban elkér tőle 1000 darab 0 vagy 1 számot, amiket
                            egyébként a program a generálásuk után
                            azonnal ki is ír a sztenderd kimenetére.
                            
                                <programlisting>
                                <![CDATA[
public class VéletlenSorozat {
    
    public static void main(String[] args) {
        
        java.util.Random generátor = new java.util.Random(42);
        
        for(int i=0; i<1000; ++i)
            System.out.print(generátor.nextInt(2));
        
    }
    
}                                
                                ]]>
                                </programlisting>
                    
                                Futtassuk le kétszer egymás után a programot,
                                a kimeneteket irányítsuk át az 
                                <filename>első.sorozat</filename> és a 
                                <filename>második.sorozat</filename> állományba, majd
                                hasonlítsuk össze, hogy a két állomány különbözik-e:
                    
                       <screen>
                            <![CDATA[
[norbi@niobe ~]$ javac VéletlenSorozat.java
[norbi@niobe ~]$ java VéletlenSorozat > első.sorozat
[norbi@niobe ~]$ java VéletlenSorozat > második.sorozat
[norbi@niobe ~]$ diff első.sorozat második.sorozat
[norbi@niobe ~]$ 
                            ]]>
                        </screen>                                 
                        
                            láthatóan 
                            a <application>diff</application> program nem jelentette
                            (lefutott és üzenet nélkül visszaadta a promptot), 
                            hogy különböznek,
                            tehát megegyeznek. Ez meglepő! Lehet ugyanaz
                            az eredmény a második futásnál, ha a sorozat véletlen?
                            Igen, mert ezek a sorozatok nem valódi véletlenek, hanem
                            egy algoritmus produkálta számok. Ezeknek az algoritmusoknak
                            (kongruencia generátoroknak) fontos tulajdonsága, 
                            hogy egy idő után elkezdik ismételni a
                            generált számokat. Minél nagyobb ez az idő, annál jobbnak
                            tartjuk a generáló
                            algoritmust. 
                        </para>
                        <para>    
                            A <classname>Random</classname> objektum készítésekor 
                            átadott 42 szám azt mondja meg, hogy a generáló algoritmus
                            milyen állapotból induljon. Mivel mindkét futásnál a 
                            42 szerepelt, így már nem meglepő, hogy mindkét futásra
                            ugyanazt a számsorozatot generálta a programunk.
                        </para>
                    
                        <example>
                            <title>Kongruencia generátorok</title>
                            
                            <para>
                            Az x<subscript>t+1</subscript> =
                            a*x<subscript>t</subscript> + b (mod m)
                            sorozatot kongruencia generátornak nevezzük.
                            Az y mod m y maradékos osztását jelenti az m
                            értékkel, azaz <computeroutput>y % m</computeroutput>. 
                            Látványosan úgy értelmezhetjük, hogy az y
                            értéket le kell tekergetnünk egy m órabeosztást
                            tartalmazó
                            csak kismutatós órán és az eredmény az, ahol a mutató megállt. 
                            Például 49 mod 12 = 1.                            
                            </para>

                            <para>
                                Mennyi a periódusa a  
                            Az x<subscript>t+1</subscript> =
                            7*x<subscript>t</subscript> + 9 (mod 11)                                
                            generátornak például a 42 értékkel indítva?
                            </para>

                            <para>
                                Ha a kedves Olvasó nem akarja 
                                papírral, ceruzával számolgatni,
                                akkor a következő kis programot írná meg:
                                
                                <programlisting>
                                <![CDATA[
public class KongruenciaGenerátor {
    
    int aktuális;
    int a = 7;
    int b = 9;
    int m = 11;
    
    public KongruenciaGenerátor(int első) {
        
        aktuális = első;
        
    }
    
    public int következő() {
        
        aktuális = (a*aktuális + b) % m;
        return aktuális;
    }
    
    public static void main(String[] args) {
        
        KongruenciaGenerátor g = new KongruenciaGenerátor(42);
        for(int i=0; i<100; ++i) {
            System.out.print(g.következő());
            System.out.print(" ");
        }
        
    }
    
}
                                ]]>
                                </programlisting>
 
                                amit ha lefordítana és futtatna, akkor
                                az alábbi eredményeket kapná:
                                
                       <screen>
                            <![CDATA[
C:\...>javac KongruenciaGenerátor.java
C:\...>java KongruenciaGenerátor
6 7 3 8 10 2 1 5 0 9 6 7 3 8 10 2 1 5 0 9 6 7 3 8 10 2 1 5 0 9 6 7 3 8 10 2 1 5
0 9 6 7 3 8 10 2 1 5 0 9 6 7 3 8 10 2 1 5 0 9 6 7 3 8 10 2 1 5 0 9 6 7 3 8 10 2
1 5 0 9 6 7 3 8 10 2 1 5 0 9 6 7 3 8 10 2 1 5 0 9
                                ]]>
                        </screen>                                 
                                ahonnan látható, hogy a periódus az alábbi
                       <screen>
                            <![CDATA[
6 7 3 8 10 2 1 5 0 9
                                ]]>
                        </screen>                                 
                                hossza tehát 10.
                            </para>
                            
                            <para>
                                Magában a JDK-ban is kongruencia generátort
                                építettek be az egyenletes eloszlású számok
                                generálására. A JDK sikeres telepítés után a 
                                JDK könyvtárában találhatjuk 
                                az <filename>src.zip</filename> nevű állományt, 
                                amiben megtaláljuk a Java SE OO világ összes 
                                osztályának forráskódját, így a 
                                <classname>Random</classname> osztályét is.
                                Itt a  
                                <filename>java/util/Random.java</filename> 
                                forrást kinyitva nézzük meg, hogy milyen
                                értékkel lesz inicializálva a generátor, azaz
                                honnan lesz indítva, ha a <classname>Random</classname>
                                osztály paraméter nélküli konstruktorát hívjuk, azaz 
                                <computeroutput>new java.util.Random()</computeroutput>
                                formában példányosítunk.
                                
                            </para>
                                                        
                        </example>
                        
							 <note>
								<title>Tanács a Javaban nem kezdő és türelmetlen Olvasóknak</title>                           
								   <para>
								   Ha a kedves Olvasó azonnal meg akarja válaszolni 
								   az iménti kérdést és ennek megfelelően azonnal
								   telepíteni akarja a JDK-t, azaz
								   a Java fejlesztői környezetet a gépére, akkor
                <emphasis><link linkend="telepites">A Java telepítése gépünkre</link></emphasis>
                című pontban talál segítséget.
								   </para>
								   </note>
								   
                        <example id="galton_kiserlet">
                            <title>Galton deszka kísérlet</title>
                            
                            <para>
                                Látványos feladat olyan grafikus szimulációs
                                programot írni, mely demonstrálja a például a
                                <citation>RÉNYI VALSÉG KÖNYV</citation> könyvben
                                leírt Galton deszkás kísérletet. A
                                függelékben ezt a 
                                <emphasis><link linkend="galton_program">Galton deszka kísérlet programja</link></emphasis>
                                című pontban mi is megtesszük majd, most 
                                csupán a kísérletet ismertetjük és 
                                egy előzetes pillantást vetünk
                                a programunkkal szimulált két különböző
                                Galton utáni kísérleti elrendezésre.
                            </para>

                            <para>                            
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/mat/gauss1.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Galton deszkás programunk egy kimenete.</phrase>
                                </textobject>	
                            </inlinemediaobject>                                       
                            </para>

                            <para>                            
                                A kísérleti elrendezésben deszkasorokat készítünk.
                                Az első sorba egy deszkát, a másodikba kettőt, 
                                a harmadikba hármat, s így tovább teszünk. A
                                deszkákat pontosan úgy helyezzük el, hogy a felülről
                                ráeső golyó 50-50 százalék eséllyel essen tovább
                                a deszka bal vagy jobb oldalán, az alatta lévő
                                következő deszka sorra. A kísérlet során arra vagyunk
                                kíváncsiak, hogy a berendezésbe beejtett golyók a 
                                sorokon átesve hová érkeznek?
                            </para>

                            <para>                            
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/mat/gauss2.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Galton deszkás programunk egy másik kísérleti elrendezéséhez tartozó kimenete.</phrase>
                                </textobject>	
                            </inlinemediaobject>                                       
                            </para>

                            <para>                            
                                A zöld oszlopokkal kirajzolt hisztogram mutatja,
                                hogy az adott helyre mennyi golyó esett a kísérlet
                                végrehajtása 
                                során. Mi most empirikusan mutattuk meg, a hivatkozott
                                <citation>RÉNYI VALSÉG KÖNYV</citation> könyvben pedig
                                teoretikusan mutatja meg a szerző, hogy határátmenetben,
                                azaz ha végtelen sok golyót ejtenénk be a kísérleti
                                elrendezésbe, akkor a kialakuló 
                                hisztogram alakja a híres
                                Gauss-féle harang görbe alakját rajzolná ki. 
                                A véletlennel
                                kapcsolatos jelenségeknél a harang görbe
                                megjelenése a normális eloszlás felbukkanására utal.
                            </para>
                                                        
                            <para>
                                A normális eloszlásnál jegyezhetjük meg, hogy
                                matematika szakos hallgatóknak/tanároknak
                                remek OO bevezető példa lehet egy alább itt is
                                bemutatásra kerülő
                                polártranszformációs normális generátor megírása
                                Javaban. 
                                Miért?
                                Mert programjuk megírása után a 
                                JDK fent említett <filename>src.zip</filename> 
                                állományában a 
                                <filename>java/util/Random.java</filename> 
                                forrásban megnézhetik, hogy magában a JDK-ban is
                                hasonlóan oldották meg a feladatot a Sun
                                programozói! Ezért ennek a generátornak a 
                                megírását magunk is megtesszük
                                most a következő pontban.
                            </para>
                                                        
                            <para id="normalis_generator">
                            A <citation>VÉLETLEN KÖNYV</citation> 98. oldala vagy a 
                            <citation>KNUTH 2. KÖNYV</citation> 128. oldala alapján
                            készítsük el a módosított polármódszeres
                            algoritmust Javaban, avagy - Javaban kezdőként - csupán 
                            figyeljük meg 
                            az elkészítését! 
                            Az algoritmus matematikai háttere most számunkra
                            lényegtelen, fontos viszont az eljárás azon 
                            jellemzője, hogy 
                            egy számítási lépés két normális eloszlású számot
                            állít elő, tehát minden páratlanadik meghíváskor nem
                            kell számolnunk, csupán az előző lépés másik
                            számát visszaadnunk. Hogy páros vagy páratlan
                            lépésben hívtuk-e meg a megfelelő számítást
                            elvégző <function>következő()</function>
                            függvényt, a <varname>nincsTárolt</varname> logikai
                            változóval jelöljük. Igaz értéke azt jelenti, hogy
                            <varname>tárolt</varname> lebegőpontos változóban
                            el van tárolva a visszaadandó szám. (Jelen tárgyalásunkban
                            a <function>következő()</function> függvényben 
                            implementált matematikai eljárás, a módosított
                            polármódszer további tulajdonságai teljesen 
                            érdektelenek.)
                            
                                <programlisting>
                                <![CDATA[
public class PolárGenerátor {
    
    boolean nincsTárolt = true;
    double tárolt;
    
    public PolárGenerátor() {
        
        nincsTárolt = true;
        
    }
    
    public double következő() {
        
        if(nincsTárolt) {
            
            double u1, u2, v1, v2, w;
            do {
                u1 = Math.random();
                u2 = Math.random();
                
                v1 = 2*u1 - 1;
                v2 = 2*u2 - 1;
                
                w = v1*v1 + v2*v2;
                
            } while(w > 1);
            
            double r = Math.sqrt((-2*Math.log(w))/w);
            
            tárolt = r*v2;
            nincsTárolt = !nincsTárolt;
            
            return r*v1;
            
        } else {
            nincsTárolt = !nincsTárolt;
            return tárolt;
        }
    }
    
    public static void main(String[] args) {
        
        PolárGenerátor g = new PolárGenerátor();
        
        for(int i=0; i<10; ++i)
            System.out.println(g.következő());
        
    }
    
}
                                ]]>
                                </programlisting>
                            
                                Most osztályunkat összevethetjük a
                                JDK fent említett <filename>src.zip</filename> 
                                állományában a 
                                <filename>java/util/Random.java</filename> 
                                forrásban implementált megoldással, ahol a 
                                <function>nextGaussian()</function>
                                függvény törzsét és a kapcsolódó (felette
                                definiált)
                                <varname>haveNextNextGaussian</varname>
                                és <varname>nextNextGaussian</varname> 
                                példánytagokat tanulmányozzuk!
                                </para>
                                                                
                                <para>
                                Ha az Olvasó a programot lefordítaná és futtatná,
                                akkor például a következő kimenetet kaphatná:
                                
                               <screen>
                                    <![CDATA[
-0.7302435745349951
0.3398973333782606
-0.1745186408410782
-0.6733291138289893
-0.7141255333702377
0.8105205642319349
-0.2166963741203095
-0.6100935726625737
-0.0061257158500475665
0.09213084665478943                                    
                                        ]]>
                                </screen>                                 
                            
                            </para>
                                                        
                        </example>
                        
                    <warning>
                        <title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>
                        <para>
                        A következő feladat forrásában a Javaban kezdő kedves Olvasóknak elég a 
                        <computeroutput>/**</computeroutput> és  
                        <computeroutput>*/</computeroutput>
                         közötti dokumentációs és a 
                         <computeroutput>/* */</computeroutput> közötti, vagy a 
                        <computeroutput>//</computeroutput>
                         mögötti megjegyzéseket átolvasnia.
                        </para>
                    </warning>
                    
                        <example id="hisztogram">
                            <title>Hisztogram feladat</title>

                            <para>
                                Az, hogy a generált számok normális eloszlásúak,
                                szemléletesen annyit tesz, hogy a számokból
                                épített hisztogram a haranggörbe alakjához hasonlatos.
                                A hisztogram oszlopok olyan rendszere, ahol 
                                egy oszlop magassága azt mutatja, hogy az oszlop
                                szélességébe a vizsgált számok közül mennyi esett.
                                Például az imént generált 10 szám 
                                a -1, 0 és a 0, 1 intervallumok felett elhelyezkedő
                                egységnyi
                                széles két doboz között úgy oszlik meg, hogy az
                                elsőbe 7, a másodikba 3 szám esik, az ennek
                                megfelelő hisztogram grafikonja a következő alakú.
                            </para>

                            <para>
                         <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/mat/hisztogramm2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>10 generált normális hisztogramja.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            
                        
                        </para>
                            
                            
                            <para>
                                A következő ábrán 100000 
                                generált normális szám egy hisztogramját
                                mutatjuk be.
                            </para>
                            
                            <para>
                         <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/mat/hisztogramm.png" />
                            </imageobject>
                            <textobject>
                                <phrase>100000 generált normális hisztogramja.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            
                        
                        </para>

                        <para>
                            Vessünk egy pillantást a kézikönyvnek arra az osztályára,
                            mellyel a szereplő hisztogram képeket
                            készítettük, próbáljuk meg végigolvasni a 
                            forráskódot! De közben vigyázzunk, hogy 
                            most még ne bonyolódjunk a részletek 
                            boncolgatásába! Szorítkozzunk inkább a
                            dokumentációs megjegyzések értelmezésére,
                            semmint az implementált függvények
                            törzsének részletes vizsgálatára.
                        </para>
                            
                                                        
                                <programlisting>
                                <![CDATA[
public class Hisztogram {
    /** A feldolgozandó értékek alsó határa. */
    protected double min;
    /** A feldolgozandó értékek felső határa. */
    protected double max;
    /** A hisztogram dobozai. */
    protected int [] dobozok;
    /**
     * Létrehoz egy <code>Hisztogram</code> objektumot.
     *
     * @param      min      a feldolgozandó értékek alsó határa.
     * @param      max      a feldolgozandó értékek felső határa.
     * @param      méret    a hisztogram dobozainak száma.
     */    
    public Hisztogram(double min, double max, int méret) {
        // Példánytagok aktualizálása:
        this.min = min;
        this.max = max;
        // Létrehozzuk a megfelelő méretű hisztogrammot.
        dobozok = new int[méret];
        // Paranoiás stílus: végigzongorázzuk a tömb elemeit
        for(int i=0; i<dobozok.length; ++i)
            // és nullázzuk a hisztogram dobozainak tartalmat:
            dobozok[i] = 0;
    }
    /**
     * A kapott érték melyik dobozba esik?
     *
     * <pre>
     *           0.    1.                      dobozok.length-1
     * ---------|-----|-----|-----|-----|-----|-----|-----------
     *         min            |                    max
     *                      érték
     * </pre>
     *
     * @param érték a hisztogram megfelelő dobozába
     */
    public void betesz(double érték) {
        
        ++dobozok[(int)((érték-min)/((max-min)/dobozok.length))];
        
    }
    /**
     * Kirajzolja a hisztogrammot.
     *
     * @return BufferedImage    a hisztogram grafikonjának képe. 
     */
    public java.awt.image.BufferedImage grafikon() {
        
        int képSzélesség = 300;
        int dobozSzélesség = 300/dobozok.length;
        
        int maxDobozÉrték = 0;
        for(int i=0; i<dobozok.length; ++i)
            if(dobozok[i] > maxDobozÉrték)
                maxDobozÉrték = dobozok[i];
        
        int képMagasság = 300;
        
        java.awt.image.BufferedImage grafikon =
                new java.awt.image.BufferedImage(
                képSzélesség,
                képMagasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB
                );
        
        java.awt.Graphics g = grafikon.getGraphics();
        
        // Kép törlése: fehérrel
        g.setColor(java.awt.Color.WHITE);
        // lemeszelünk egy képernyőnyi méretű téglalapot:
        g.fillRect(0, 0, grafikon.getWidth(), grafikon.getHeight());
        
        for(int i=0; i<dobozok.length; ++i) {
            
            // Egy doboz kirajzolása
            g.setColor(java.awt.Color.YELLOW);
            if(maxDobozÉrték/képMagasság != 0)
                g.fillRect(i*dobozSzélesség,
                        képMagasság-dobozok[i]/(maxDobozÉrték/képMagasság),
                        képSzélesség/dobozok.length,
                        dobozok[i]/(maxDobozÉrték/képMagasság));
            else
                g.fillRect(i*dobozSzélesség,
                        képMagasság-dobozok[i]*(képMagasság/maxDobozÉrték),
                        képSzélesség/dobozok.length,
                        dobozok[i]*(képMagasság/maxDobozÉrték));
            // Esztétikus a doboz bekeretezése
            g.setColor(java.awt.Color.LIGHT_GRAY);
            if(maxDobozÉrték/képMagasság != 0)
                g.drawRect(i*dobozSzélesség,
                        képMagasság-dobozok[i]/(maxDobozÉrték/képMagasság),
                        képSzélesség/dobozok.length,
                        dobozok[i]/(maxDobozÉrték/képMagasság));
            else
                g.drawRect(i*dobozSzélesség,
                        képMagasság-dobozok[i]*(képMagasság/maxDobozÉrték),
                        képSzélesség/dobozok.length,
                        dobozok[i]*(képMagasság/maxDobozÉrték));
        }
        
        g.dispose();
        
        return grafikon;
    }
    /**
     * Példányosít egy hisztogram objektumot, akinek továbbítja a
     * bemenetről olvasott számokat, végül kimenti a hisztogramot.
     */        
    public static void main(String[] args) throws Exception {

        // Feltesszük, hogy korábban már megállapítottuk 
        // a bejövő számok minimumát és maximumát, ezek
        // a most csak becsült -4.5, 4.5
        Hisztogram h = new Hisztogram(-4.5, 4.5, 40);
        
        java.io.BufferedReader inputCsatorna =
                new java.io.BufferedReader(
                new java.io.InputStreamReader(System.in));
        
        String sor = null;
        // Olvassuk a bemenetet, amíg tudjuk
        while((sor = inputCsatorna.readLine()) != null)
            // az olvasott számot továbbitjuk a 
            // hisztogram objektumnak:
            h.betesz(Double.parseDouble(sor));
        
        // A számok feldolgozása után egy képállományba írjuk
        // ki az elkészített hisztorgramm grafikonját:
        javax.imageio.ImageIO.write(h.grafikon(), "png",
                new java.io.File("hisztogram.png"));        
    }    
}

                                ]]>
                                </programlisting>
                                                        
            <para>
                Ha az Olvasó módosítaná az előző pont
                <classname>PolárGenerátor</classname>
                osztályának indító <function>main()</function> 
                módszerében a ciklust, hogy 100000 normálist
                állítson elő, s az osztály fordítása után 
                kimenetét a <filename>100000.normális</filename>
                állományba irányítaná, amit pedig inputként irányítana
                a futtatott 
                <classname>Hisztogram</classname> objektumba:
                

                                
                               <screen>
                                    <![CDATA[
C:\...> java PolárGenerátor >100000.normális
C:\...> java Hisztogram < 100000.normális
                                        ]]>
                                </screen>                                 

                                akkor a példa bevezetésében mutatott
                                ábra haranggörbe hisztogramját kapná a
                                program által generált
                                a <filename>hisztogram.png</filename>
                                állományban.                                
            </para>
                                
                            
                        </example>
                        
                   <warning>
                        <title>Feladat a Javaban nem kezdő Olvasóknak</title>
                        <para>
                        Az iménti <classname>Hisztogram</classname>
                        osztály <function>betesz(double érték)</function>
                        módszerét módosítsuk úgy, hogy dobjon egy 
                        <classname>RosszÉrtékException</classname> saját
                        kivétel objektumot, ha az aktuális paraméterként
                        kapott <varname>érték</varname> kisebb, mint a 
                        hisztogram <varname>min</varname> vagy nagyobb,
                        mint a <varname>max</varname> értéke. A kivétel
                        objektumba üzenetként csomagoljuk be, hogy éppen melyik
                        szituáció következett be.                         
                        </para>
                        <para>
                            A Javaban kezdő Olvasó akkor készítse el ezt a 
                            feladatot, ha a kapcsolódó kivételkezelési 
                            bevezető részeket már feldolgozta!
                        </para>
                    </warning>                        
                        
                        <example>
                            <title>Fej vagy írás varázslat</title>
                            
                            <para>
                                A
                                <citation>VÉLETLEN VÉLETLEN</citation> könyvben
                                javasolt játék a véletlennel a 
                                következő: a tanulók egy részétől azt kérjük,
                                hogy írjanak papírra egy 200 elemből álló 
                                0, 1 sorozatot úgy, hogy a sorozat minden tagját
                                egy érme feldobásával állítják elő. A tanulók
                                másik csoportja ugyancsak 200 elemű 0, 1 sorozatot
                                készít, de ők fejből írják. S csodák csodája a 
                                tanár megtekintve a sorozatokat - kis hibával - 
                                megmondja, hogy
                                mely sorozatok alapulnak valódi pénzfeldobáson. 
                                Módszere,
                                hogy azokról a sorozatokról mondja ezt, 
                                melyekben van egymást követő legalább
                                6 darab nulla vagy egy, mert a fejből generáló
                                tanuló ennyi azonos jegyet egymás után már nem 
                                tekint véletlennek. 
                            </para>
                            
                            <para>
                                Íme egy példa a pénzérmével való dobás alapján
                                képzett sorozatra: 
                                <screen>
11110010010010111101001110010001110011101100111100
00110011001101110111000101001111110001001001001100
10100111011100100111000100000011101101001000010011
11011000011111000101101010001001111010010011000010                                    
                                </screen>                                
                            </para>
                            
                            <para>
                                S egy másik a fejből véletlennek generált/titulált
                                alapon
                                képzett sorozatra: 
                                <screen>
01110010110100110101000010110010110100101011110101
10011001010101101001001000110101010100100101101001
11001100011001111011011110100010110010111010100101
10000110101110110100001101010110111010101101010011
                                </screen>
                            </para>
                            
                        </example>
                            
                        <para>
                            Az eddigi és még néhány elkövetkező, algoritmuselméleti ihletésű pontokat a 
                            <emphasis>„Nem fontos a pontosság, csak azt tudjuk, hogyan lehet elérni”</emphasis> 
                            - ezt a tanácsot adta számtalanszor egyetemünk logika vagy mesterséges intelligencia kurzusain hallgatóinak Dragálin Albert professzor úr -
                            gondolat jegyében bontottuk ki. Azoknak, akik az érintett alapfogalmak teljesen pontos tárgyalását keresik 
                            a <citation>ALGORITMUSOK KÖNYV</citation> vagy a <citation>LOVÁSZ KÖNYV</citation> 
                            könyveket ajánljuk.
                        </para>
                    
                </sect5>
                        
                </sect4>
                                
                <sect4 id="veletlen">
                    <title>Tényleg véletlen 0, 1 sorozatok</title>

                    <para>
                        Vizsgálódjunk kicsit tovább az 1000 bit hosszúságú bináris 
                        szavak között! Egy bites szóból 2 van, a 0 és az 1. Két bites szóból 
                        2x2 darab, a 00, 01, 10, 11. Három bites szóból 2x2x2, 2<superscript>8</superscript>,
                        négy bitesből 2x2x2x2, 2<superscript>4</superscript>, ... láthatóan végül
                        1000 bites szóból 2<superscript>1000</superscript> darab van; ez jó sok,
                        jóval több, mint búzaszem a sakktáblán.
                    </para>                    
                    
                    <para>
                        Vajon mennyi 1000 bites szó Chaitin-Kolmogorov bonyolultsága kisebb
                        990-nél és mennyié nagyobb?
                    </para>
                    
                    <para>                        
                        A 990-nél kisebb bonyolultságúak, a korábban kimondott definíciónk alapján,
                        azok a szavak lehetnek, melyeket 990-nél
                        rövidebb bemenetből ki tudunk számítani egy univerzális Turing
                        géppel
                    </para>
                    <para>                          
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/ezerszo2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Ha a T algoritmus és i inputja együttes hossza kisebb 990-nél.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            
                        
                        ahol a T algoritmus és i inputja együttes hossza kisebb 990-nél. Könnyen, erősen
                        felülről tudjuk becsülni az ilyen 990 bitnél rövidebb univerzális Turing gép
                        bemeneteket. Mert 990-nél rövidebb bitminta összesen lehet 2 darab 1 bites +
                        4 darab 2 bites + 8 darab 3 bites + ... + 2<superscript>989</superscript> darab
                        989 bites = 2<superscript>990</superscript> -1 darab összesen. A -1 bemenetet még nagylelkűen
                        hozzácsapva, számoljunk 2<superscript>990</superscript> darabbal.
                    </para>                    

                    <para>                    
                        Tehát maximum 2<superscript>990</superscript> darab szó lehet 990-nél
                        egyszerűbb és ennek megfelelően 
                        2<superscript>1000</superscript> / 2<superscript>990</superscript> = 1024,
                        azaz körülbelül maximum 1000-szer több olyan szó van, ami pedig 990-nél
                        bonyolultabb. Összefoglalva az 1000 bit hosszúságú bináris szavak
                        minimum 99.9 százaléka 990-nél nagyobb bonyolultságú!
                    </para>                    

                    <para>                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/ezerszo.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Hány 990-nél egyszerűbb és bonyolultabb 1000 bites szó van?</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            
                    </para>
                                        
                    <para>                    
                        Ugyanezzel a gondolatmenettel láthatnánk be, hogy az 1000
                        bit hosszúságú szavak között a 999-nél egyszerűbb szavak
                        maximum 2<superscript>1000</superscript>-1-en vannak, tehát
                        legalább egy szónak lennie kell, ami bonyolultsága &gt;= 1000.
                    </para>                    

                    <sect5>
                        <title>Végtelen és véletlen 0, 1 sorozatok</title>

                        <para>
                            Ebben a pontban megmutatjuk, hogy a megismert Chaitin-Kolmogorov
                            bonyolultság fogalmunkkal miként tudjuk úgy definiálni a 
                            végtelen véletlen sorozat fogalmát, hogy intuíciónk közben
                            meg ne hökkenne. Mert meg lenne hökkenve? Döntse el önmaga a 
                            kedves Olvasó, gondoljon arra, hogy betesszük egy urnába az
                            összes 1000 bit hosszúságú 0, 1 sorozatot. Ekkor a korábbi
                            <emphasis><link linkend="bonyolultsag">A Chaitin-Kolmogorov bonyolultság</link></emphasis>
                            című pont második sorozatát kihúzni ugyanolyan valószínű, mint az
                            ötödiket, mert mindkét esetben arról van szó, hogy a kihúzott
                            sorozat bitjeinek
                            az egyik esetben pont annak kell lenni, mint a második vagy a
                            másik esetben pont annak, mint az ötödik sorozatban a biteknek.
                            Ez a nézőpont szemléletünkkel jól megfér. De mindemellett
                            az ötödik sorozatot természetesen véletlennek tekintjük, míg az
                            másodikról lerí, hogy teljesen triviálisan szabályos, hogy is
                            lehetne hát véletlen! - mondja a szemléletünk. A két szemléletében
                            ellentétes megközelítés szülheti meg meghökkenésünket.
                        </para>
                        
                        <example>
                            <title>Egy szabályos sorozat</title>
                            
                        <para>
                            Készítsünk egy olyan programot, ami bemenetén kapott n
                            számig kiírja a 
                            <emphasis><link linkend="bonyolultsag">A Chaitin-Kolmogorov bonyolultság</link></emphasis>
                            című pont második sorozatát!
                            
                            <programlisting>
                            <![CDATA[
public class BinárisSorozat {
    
    public static void main(String[] args) {
        
        int db = 0;
        try {
            
            db = Integer.parseInt(args[0]);
            
        } catch(NumberFormatException e) {
            
            db = 100;
            
        }
        
        for(int i=0; i<db; ++i)
            System.out.print(i%2);
        
    }
}
                            ]]>
                            </programlisting>
                            
                            A program a bemenő n számot az első parancssor argumentumaként
                            <varname>args[0]</varname> szöveges tömbelemben várja, 
                            majd ebből az 
                            <classname>Integer</classname> osztály statikus 
                            <function>parseInt()</function> módszerével számot csinál, majd e számig
                            felváltva 0 és 1 jegyeket ír ki. Ha a kedves Olvasó lefordítaná
                            és futtatná a programot, akkor a következőt kapná:
                            
                           <screen>
                                <![CDATA[
[norbi@niobe ~]$ javac BinárisSorozat.java
[norbi@niobe ~]$ java BinárisSorozat 1
0
                                ]]>
                           </screen>                                     

                           A program 185 betű, az inputja 1 betű, összesen 186 betű.
                           Ha most a kedves Olvasó az n=10 értékkel futtatná, akkor
                           a következő kimenethez jutna:
                           
                           <screen>
                                <![CDATA[
[norbi@niobe ~]$ java BinárisSorozat 10
0101010101
                                ]]>
                           </screen>
                           
                           A program 185 betű, az inputja 2 betű, összesen 187 betű.
                           Az n=100 értékkel indítva:
                           
                           <screen>
                                <![CDATA[
[norbi@niobe ~]$ java BinárisSorozat 100
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101

                                ]]>
                           </screen>                                     
                           
                           A program 185 betű, az inputja 3 betű, összesen 188 betű.                           
                           Ezerrel indítva:
                           
                           <screen>
                                <![CDATA[
[norbi@niobe ~]$ java BinárisSorozat 1000
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
01010101010101010101010101010101010101010101010101010101010101010101010101010101
0101010101010101010101010101010101010101010101010101010101010101010101010101010
10101010101010101010101010101010101010101                                
                                ]]>
                           </screen>                                     
                            
                           A program 185 betű, az inputja 4 betű, ez összesen 189 betű.
                                                      
                        </para>
                        </example>
                        
                    <para>Összegezzük eredményeinket!</para>
                                        
                    <table frame="all"><title>A 01-et ismétlő bináris sorozat kezdőrészeinek vizsgálata.</title>
                        <tgroup cols="3">
                            <thead>
                                <row>
                                    <entry>
                                        <para>HOSSZ</para>
                                    </entry>
                                    <entry>
                                        <para>BONYOLULTSÁG</para>
                                    </entry>
                                    <entry>
                                        <para>A KETTŐ HÁNYADOSA</para>
                                    </entry>
                                </row>                                
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                        <para>1</para>
                                    </entry>
                                    <entry>
                                        <para>186</para>
                                    </entry>
                                    <entry>
                                        <para>186</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>10</para>                                         
                                    </entry>
                                    <entry>
                                        <para>187</para>
                                    </entry>
                                    <entry>
                                        <para>18.7</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>100</para>
                                    </entry>
                                    <entry>
                                        <para>188</para>
                                    </entry>
                                    <entry>
                                        <para>1.88</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>1000</para>
                                    </entry>
                                    <entry>
                                        <para>189</para>
                                    </entry>
                                    <entry>
                                        <para>0.189</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>10000000</para>
                                    </entry>
                                    <entry>
                                        <para>193</para>
                                    </entry>
                                    <entry>
                                        <para>0.00000193</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                        
                    <para>
                    Jól láthatóan minél hosszabb a generált sorozat, annál inkább
                    közel kerül a nullához a hányados, azaz a hányados nullához
                    tart, ha a sorozat n hossza a végtelenbe. Az iménti empirikus
                    megalapozás után ebben biztosak lehetünk, hiszen a bonyolultság,
                    a program és inputja együttes hossza általánosan írva 
                    185 + lg(n) + 1, mert a 185 karakteres programot ebben a 
                    formában futtattuk:
                    
                    <screen>
                                <![CDATA[
[norbi@niobe ~]$ java BinárisSorozat n
                                ]]>
                    </screen>                                     
                    
                    ahol a parancssorban átadott n input szám leírásához
                    lg(n) + 1 számjegy szükséges. A (185 + lg(n) + 1)/n pedig
                    zérushoz tart, az n tart végtelen esetén.
                    </para>
                    
                    <para>
                        Ez azt jelenti, hogy a vizsgált sorozat hosszának növelésével a 
                        sorozat bonyolultsága nem tud lépést tartani.
                    </para>
                    
                    <para>
                        Egy végtelen sorozatot akkor nevezünk 
                        <emphasis>véletlennek</emphasis>, ha a 
                        rá vonatkozó fenti hányados nem zérushoz, hanem az egyhez
                        tart. Tehát, ha a vizsgált sorozat hosszának növelésével
                        egyforma mértékben növekedik a sorozat bonyolultsága is!
                    </para>
                    
                    <para>
                        Példánkból általánosíthatunk is: ha van olyan algoritmus,
                        ami az n szám inputtal előállítja a sorozat első n betűjét, 
                        akkor a sorozat nem lehet véletlen. Mert például H-val jelölve
                        ennek az algoritmusnak a hosszát, a (H + lg(n) +1)/n hányados
                        ugyanúgy, mint fenti példánkban,
                        a nullához fog tartani, ha n tart a végtelenhez.
                    </para>
                    
                        <example>   
                            <title>Véletlenszám generátorok</title>

                            <para>
                            Az előző bekezdés általánosításának
                            tükrében gondoljuk át, véletlen-e a következő
                            program által generált véletlen sorozat?
                            
                                <programlisting>
                                <![CDATA[
public class PszeudoVéletlen {
    
   public static void main(String[] args) {
        
        java.util.Random generátor = new java.util.Random();
        
        for(;;)
            System.out.print(generátor.nextInt(2));
        
    }
        
}                                
                                ]]>
                                </programlisting>
                                
                                    Természetesen nem, mert az egy korábbi
                                    példában szereplő 
                                    <classname>VéletlenSorozat</classname>
                                    osztályt úgy módosítva, hogy nem 1000,
                                    hanem parancssorban kapott n számig
                                    nyomtat és feltéve, hogy a 
                                    <classname>java.util.Random</classname>
                                    generátor például
                                    éppen a 42-vel inicializálódott a 
                                    jelen paraméter nélküli konstruktor hívás
                                    mögött, elő tudjuk állítani éppen ennek
                                    a sorozatnak a
                                    kezdő részeit. S a fentiekhez hasonló
                                    számítással megkapjuk, hogy a vizsgálandó
                                    hányados a nullához tart.
                                </para>
                                
                        </example>                    
                    
                    
                        <example>
                            <title>Egy másik szabályos sorozat</title>
                            
                            <para>
                                Vizsgáljuk meg, hogy véletlen sorozat-e
                                a 
                                <emphasis><link linkend="bonyolultsag">A Chaitin-Kolmogorov bonyolultság</link></emphasis>
                                című pont negyedik sorozata mintájára képzett végtelen sorozat.    
                            </para>
                            
                        </example>
                    
                        <example>
                            <title>Egy nem véletlen, de bonyolultabb sorozat</title>
                            
                        <para>
                            Próbáljunk meg egy olyan sorozatot „készíteni”,
                            melyre a vizsgált hányados nem nullához tart!
                            Ennek a célnak megfelelően a következő
                            <classname>FéligVéletlen</classname> osztályt
                            úgy alakítottuk ki, hogy a sorozat felét,
                            a második karakterét is inputként kéri be.
                            S a felhasználót arra kérjük, a program
                            kérésére 0 vagy 1 jegyet írjon be, annak
                            megfelelően, hogy közben feldobott érméje fej vagy
                            írás-e. Továbbá arra is figyelni kell, hogy a
                            mindig ugyanazt a kezdő részt adjuk be a 
                            program kérésére, azaz az Olvasónak a 
                            feldobott érme eredményeket meg kell
                            jegyeznie, s mindig csak az új pozícióra kell
                            újra dobni.
                                                                                    
                            <programlisting>
                            <![CDATA[
public class FéligVéletlen {
    
    public static void main(String[] args) throws Exception {
        
        int db = Integer.parseInt(args[0]);
        
        int [] sorozat = new int [db];
        
        int fele = db/2;
        
        java.io.BufferedReader inputCsatorna =
                new java.io.BufferedReader(
                new java.io.InputStreamReader(System.in));
        
        for(int i=0; i<db; ++i)
            if(i%2 == 1){
            
            System.out.print("Az "+i+". tag: ");
            String sor = inputCsatorna.readLine();
            sorozat[i] = Integer.parseInt(sor);
            
            } else
                sorozat[i] = 0;
        
        System.out.println();
        for(int i=0; i<db; ++i)
            System.out.print(sorozat[i]);
        
    }
}

                            ]]>
                            </programlisting>
                            
                            A program 469 betű hosszú.                        
                        </para>

                        <para>

                            Ha a kedves Olvasó lefordítaná és futtatva a 
                            programot elvégezne néhány próba futtatást, akkor
                            az alábbiakat kaphatná:
                            
                        <screen>
                                <![CDATA[
C:\...> javac FéligVéletlen.java

C:\...> java FéligVéletlen 1
0

C:\...> java FéligVéletlen 2
Az 1. tag: 1

01

C:\...> java FéligVéletlen 3
Az 1. tag: 1

010

C:\...> java FéligVéletlen 4
Az 1. tag: 1
Az 3. tag: 0

0100

C:\...> java FéligVéletlen 10
Az 1. tag: 1
Az 3. tag: 0
Az 5. tag: 1
Az 7. tag: 1
Az 9. tag: 0

0100010100
                              
                                ]]>
                        </screen>                                     
                        </para>
         
                        </example>
                        
                        <para>
                            Mit mondhatunk a vizsgált sorozat véletlenségéről?
                    Összegezzük eredményeinket!</para>
                     
                    <table frame="all"><title>A félig véletlen bináris sorozat kezdőrészeinek vizsgálata.</title>
                        <tgroup cols="3">
                            <thead>
                                <row>
                                    <entry>
                                        <para>HOSSZ</para>
                                    </entry>
                                    <entry>
                                        <para>BONYOLULTSÁG</para>
                                    </entry>
                                    <entry>
                                        <para>A KETTŐ HÁNYADOSA</para>
                                    </entry>
                                </row>                                
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                        <para>1</para>
                                    </entry>
                                    <entry>
                                        <para>469</para>
                                    </entry>
                                    <entry>
                                        <para>469</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>10</para>                                         
                                    </entry>
                                    <entry>
                                        <para>469+10+2</para>
                                    </entry>
                                    <entry>
                                        <para>48.1</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>100</para>
                                    </entry>
                                    <entry>
                                        <para>469+50+3</para>
                                    </entry>
                                    <entry>
                                        <para>5.22</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>1000</para>
                                    </entry>
                                    <entry>
                                        <para>469+500+4</para>
                                    </entry>
                                    <entry>
                                        <para>0.973</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>10000</para>
                                    </entry>
                                    <entry>
                                        <para>469+5000+5</para>
                                    </entry>
                                    <entry>
                                        <para>0.5474</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>10000000</para>
                                    </entry>
                                    <entry>
                                        <para>469+5000000+8</para>
                                    </entry>
                                    <entry>
                                        <para>0.5000477</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                    <entry>
                                        <para>...</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>

                        <para>
                        láthatóan 0.5-höz tartunk és valóban a
                        (469 + n/2 + lg(n) + 1)/n kifejezés, az n tart a végtelenhez
                        határátmenet esetén az 1/2-hez tart.
                        </para>
                        
                    </sect5>
                    
                </sect4>
                                        
                <sect4 id="omega">
                    <title>A megállási Omega valószínűség</title>
                    
                    <blockquote>
                        <attribution>Madách Imre</attribution>
                        <literallayout>
                            „ÁDÁM 
                            Úgyis nem ront-e majd el a halál?
                            A FÖLD SZELLEMÉNEK SZAVA 
                            A vén hazugság e hiú szavát ne mondd, 
                            ne mondd itt a szellemvilágban.
                            Egész természet átborzadna tőle.
                            Szentelt pecsét az, feltartá az Úr
                            Magának. A tudás almája sem
                            Törhette azt fel.”                    
                        </literallayout>
                    </blockquote>

                    <para>
                        Korábban már láttuk (programoztuk), hogy Turing gépeinket
                        megadhatjuk csupán a 0 és az 1 jegyek leírásával. Tegyük fel,
                        hogy a világon összesen 10 Turing gép van és ezeket a 
                        következő biráris sorozatokkal „kódoltuk”.
                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/omega1.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az összes, 10 Turing gép bináris kódja.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            

                        </para>
                        <para>
                        
                        Ezek a kódok mindamellett, hogy csak szimbolikusak - mivel ilyen
                        kevés bittel természetesen nem menne a lekódolásuk - nagyon speciálisak, mert
                        figyeljük meg, hogy egyik kódszó sem kezdődik egy másik kódszóval.
                        Az ilyen kódolást nevezzük prefixnek. Ami a programozóknak
                        egyébként természetes, mert a programok prefix kódok, 
                        hiszen egyik program sem kezdődik egy másikkal:

                        </para>
                        <para>
                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/omega2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Egyik program sem kezdődik egy másikkal.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            
                                                
                    </para>
                    
                    <para>
                        Ha a kedves Olvasó megpróbálna egy ilyen
                        felépítésű
                            <programlisting>
                            <![CDATA[
public class Program {

}

}
                            ]]>
                            </programlisting>
                            
                            programot lefordítani, akkor az alábbi
                            fordítási hibát kapná:
                            
                            <screen>
                            <![CDATA[

C:\...> javac Program.java
Program.java:5: class, interface, or enum expected
}
^
Program.java:6: reached end of file while parsing
^
2 errors
                            ]]>
                            </screen>
                            
                    </para>
                    
                    <para>
                        Tegyük fel továbbá, hogy a 10 gép közül az alábbi 4 megáll, 6
                        gép
                        viszont nem áll meg, azaz végtelen ciklusba esik.
                    </para>
                    
                    
                    <para>                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/omega3.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az összes, 10 Turing gép közül 4 áll meg, 6 végtelen ciklus.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            
                        
                    </para>
                    
                    <sect5>
                        <title>Chaitin gépek</title>

                        <para>
                            A Turing gépek prefix kódolása azért fontos
                            számunkra, mert a Kraft-Fánó-McMillan 
                            egyenlőtlenségből 
                            <citation>DEMETROVICS KÖNYV</citation> tudjuk, hogy
                            prefix kódokra teljesül. A hivatkozott
                            egyenlőtlenség pontosan azt fejezi ki, hogy
                            a kódszó<subscript>1</subscript>, 
                            kódszó<subscript>2</subscript>, ...
                            kódszó<subscript>n</subscript> n kódszóból álló 
                            prefix kódra a 
                            </para>
                            
                            <para>
                            2<superscript>|kódszó<subscript>1</subscript>|</superscript> 
                            +
                            2<superscript>|kódszó<subscript>2</subscript>|</superscript> 
                            + ... +
                            2<superscript>|kódszó<subscript>n</subscript>|</superscript> 
                            &lt;= 1 teljesül.
                            </para>
                            <para>
                            A mi esetünkben a kód a 01, 000, 001, 101, 100, 
                            1100, 1101, 1110, 11110, 11111, az egyenlőtlenségbeli
                            összeg értéke pedig
                            </para>
                            
                            <para>
                            2<superscript>-2</superscript>
                            +4*2<superscript>-3</superscript>
                            +3*2<superscript>-4</superscript>
                            +2*2<superscript>-5</superscript> = 1
                            </para>
                            
                            <para>
                                Tehát az egyenlőtlenség - mint ahogyan tudtuk is 
                                - valóban nem sérül példánkban sem. Mivel az
                                összeg értéke mindig a 0 és az 1 közé esik, ezért 
                                valószínűségnek tekinthetjük.
                            </para>

                            <para>
                                A Turing gépek megállási valószínűségének nevezzük azt a
                                fenti típusú összeget, amelyben az összegzést a 
                                megálló gépek kódjára végezzük el. Elképzelt, 10
                                gépes világunkban tehát a megállás 
                                valószínűsége 
                            </para>
                            <para>
                            2*2<superscript>-3</superscript>
                            +2<superscript>-4</superscript>
                            +2<superscript>-5</superscript> = 0,34375
                            </para>
                    
                            <para>
                            A prefix Turing gépek (Chaitin gépek) világában ezt a 
                            megállási valószínűséget Omegának nevezzük.                              
                            (<citation>CHAITIN OMEGA</citation>, 
                            <citation>JAVA PROG és OMEGA</citation> és lásd még az
                            irodalomjegyzék számos Omegával kapcsolatos bejegyzését.)
                            </para>
                            
                        <example>
                            <title>A Chaitin-féle Omega konstans ismeretében meg tudnánk oldani a megállási problémát!</title>
                    <para>                        
                    A <citation>PARADOXON KÖNYV</citation> könyvben bemutatott
                    kapcsolódó gondolatmenet alapján ebben a példában bemutatjuk, hogy Omega
                    ismeretében meg tudnánk oldani a megállási problémát.
                    </para>
                    
                    <para>                        
                            Vizsgáljunk egy tetszőlegesen megválasztott
                            H bit hosszúságú programot! Az alábbi táblázat
                            segítségével megmutatjuk, hogy a Chaitin-féle
                            megállási Omega konstans ismeretében meg tudnánk
                            mondani, hogy tetszőleges program megáll-e, azaz
                            meg tudnánk oldani a megállási problémát, ami
                            lehetetlen! Tehát nem ismerhetjük meg a 
                            konstanst, az Omegának őriznie kell titkait az
                            ember előtt...
                            </para>
                    <para>                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/omega.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A Chaitin konstans ismeretében meg tudnánk oldani a megállási problémát.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            
                        
                            </para>
                            
                    <para>  
                        A vízszintes tengelyen a programok szerepelnek 
                        hosszuk szerint, a függőlegesen a futási idő.
                        Minden időpillanatban elkezdjük futtatni az egy
                        bittel hosszabb programokat. A kísérlet közben
                        megálló programok 2<superscript>-hosszuk</superscript>
                        értékkel növelik meg az Omega értékét, egészen 
                        pontosan OMEGA<subscript>N</subscript> jelölje 
                        az N. időpillanatig megálló vizsgált, azaz
                        maximum N hosszú gépek
                        hosszával növelt összeget. Nyilván
                        OMEGA<subscript>N</subscript> 
                        &lt;= 
                        OMEGA<subscript>N+1</subscript>, ami alapján 
                        menjünk addig előre az idővel, amikor az 
                        OMEGA<subscript>N</subscript> monoton közelítés
                        már 1/2<superscript>H</superscript> értéknél
                        közelebb van az OMEGA határértékhez. Következzen
                        ez be például a t=M időpillanatban. Tehát
                        ekkor az OMEGA-OMEGA<subscript>M</subscript> 
                        &lt; 
                        2<superscript>-H</superscript>. És most jön
                        a trükk: ha a vizsgált H hosszú program eddig 
                        nem állt meg, akkor (most már, azaz véges sok
                        lépés után) tudjuk, hogy már nem is fog megállni,
                        mert ha megállna, akkor 2<superscript>-H</superscript>
                        értékkel növelné meg az Omega approximációját,
                        azaz ebben a megállás valamikori időpillanatában
                        OMEGA<subscript>valamikori</subscript> 
                        &gt;=
                        OMEGA<subscript>M</subscript> + 2<superscript>-H</superscript> 
                        &gt; 
                        OMEGA - 2<superscript>-H</superscript> + 2<superscript>-H</superscript>
                        = OMEGA. Hoppá! Döbbenetes, nem igaz? Jó kis ellentmondás, 
                        miszerint az alulról közelítő 
                        OMEGA<subscript>valamikori</subscript> átlépte az OMEGA értéket!
                    </para>
                        
                    </example>                            

                    <para>
                        Az Omega számnak számos további érdekes 
                        tulajdonsága is van, például ha a tizedes
                        kifejtését egy számjegyekből 
                        álló betűsorozatnak tekintjük, akkor ez a 
                        sorozat véletlen. Szemben például a Pi
                        konstanssal, ami ugyan nem gyöke egyetlen
                        egyenletnek sem, de végtelen sorokkal
                        tömören leírható, a Pi tizedes kifejtésének 
                        bármely 
                        jegyei tetszőleges pontossággal meghatározhatók.
                        
                    </para>
                            
                        <example id="pi_bev">
                            <title>A Pi közelítése</title>
                            
                            <para>
                                Az alábbi példa kapcsán javasoljuk
                                elolvasni a <citation>KAPCSOLAT REGÉNY</citation>
                                regényt, mely végén a Pi jegyeivel színezett
                                történet erős érzelmi motivációt adhat. A
                                hivatkozott <citation>KAPCSOLAT MOZI</citation>
                                filmet is bátran ajánljuk az Olvasónak, de 
                                ebből a feldolgozásból
                                sajnos a könyv kapcsán említett Pi 
                                konstanssal kapcsolatos részek
                                teljesen hiányoznak.
                            </para>

                            <para>
                                A Pi pontos értékével való ismerkedést
                                kezdjük a 
                                Gregory-Leibniz formula bemutatásával.                             
                            </para>
                            
                            <para>
                            <programlisting>
                            <![CDATA[
public class Pi {
    
    double közelítőÉrték;
    
    public Pi(long n) {
        
        double p = 0;
        
        // Gregory-Leibniz formula:
        // Pi/4 = 1 - 1/3 + 1/5 - 1/7 + ... + (1-(i%2)*2)/(2*i+1) + ...
        
        for(long i=0; i<n; ++i)
            p += (double)(1-(i%2)*2)/(2*i+1);
        
        közelítőÉrték = 4*p;
    }
    
    public static void main(String[] args) {
        
        long n = 1;
        while(true) {
            n *= 10;
            Pi pi = new Pi(n);
            System.out.println("pi ~ Pi(n) = " + pi.közelítőÉrték 
                    + ", n = " + n 
                    + ", Math.PI/Pi(n) = " 
                    + (Math.PI / pi.közelítőÉrték));            
        }
    }    
}
                            ]]>
                            </programlisting>

                            Ha az Olvasó fordítaná és futtatná a programot, akkor
                            a következő kimenetét kapná:
                            
                            <screen>
                            <![CDATA[
[norbi@niobe ~]$ javac Pi.java
[norbi@niobe ~]$ java Pi
pi ~ Pi(n) = 3.0418396189294032, n = 10, Math.PI/Pi(n) = 1.0327936535639899
pi ~ Pi(n) = 3.1315929035585537, n = 100, Math.PI/Pi(n) = 1.0031931832582315
pi ~ Pi(n) = 3.140592653839794, n = 1000, Math.PI/Pi(n) = 1.0003184111600008
pi ~ Pi(n) = 3.1414926535900345, n = 10000, Math.PI/Pi(n) = 1.0000318320017856
pi ~ Pi(n) = 3.1415826535897198, n = 100000, Math.PI/Pi(n) = 1.0000031831090173
pi ~ Pi(n) = 3.1415916535897743, n = 1000000, Math.PI/Pi(n) = 1.0000003183099935
pi ~ Pi(n) = 3.1415925535897915, n = 10000000, Math.PI/Pi(n) = 1.00000003183099
pi ~ Pi(n) = 3.141592643589326, n = 100000000, Math.PI/Pi(n) = 1.0000000031832477
pi ~ Pi(n) = 3.1415926525880504, n = 1000000000, Math.PI/Pi(n) = 1.0000000003188645
pi ~ Pi(n) = 3.141592653488346, n = 10000000000, Math.PI/Pi(n) = 1.0000000000322917
pi ~ Pi(n) = 3.141592653578537, n = 100000000000, Math.PI/Pi(n) = 1.000000000003583
                            ]]>
                            </screen>
                            
                            egészen addig, amíg egy <keycap>Ctrl+c</keycap>
                            nyomásával meg nem
                            állítja a végtelen ciklusban számoló programot.
                            (Ameddig mi a program futását engedtük, a 
                            Pi(n) = <emphasis>3.1415926535</emphasis>78537
                            10 tizedesig pontos eredményig jutottunk.)
                            </para>

                            <para>
                                A képzeletbeli futtatás előtt próbálja elképzelni, 
                                megbecsülni az egyre növekvő 
                                <computeroutput>n = n * 10</computeroutput>
                                mellett a <function>Pi(long n)</function>
                                konstruktor időbonyolultságát, azaz futási
                                idejét, majd vesse össze elképzeléseit a 
                                futtatás során szerzett „izometrikus”
                                tapasztalataival!                                
                            </para>

                            <para>
                                A már Javaban nem kezdő Olvasó első javítási ötlete bizonyára
                                az, hogy a közelítéshez nem készítene
                                külön <classname>Pi</classname> objektumokat
                                és azok <function>Pi(long n)</function>
                                konstruktorában nem kezdené mindig elölről az
                                összegzést, hanem inkább az alábbi módon
                                szervezné át az osztály kódját.
                            </para>
                            
                            <para>
                            <programlisting>
                            <![CDATA[
public class Pi {
    
    double közelítőÉrték;
    long meddigSzámoltuk;
 
    public Pi() {
        
        közelítőÉrték = 0;
        meddigSzámoltuk = 0;
    }
    
    public double közelítés(long n) {
        
        double p = 0;
        
        // Gregory-Leibniz formula:
        // Pi/4 = 1 - 1/3 + 1/5 - 1/7 + ... + (1-(i%2)*2)/(2*i+1) + ...
                        
        for(long i=meddigSzámoltuk; i<n; ++i)
            p += (double)(1-(i%2)*2)/(2*i+1);
        
        if(n > meddigSzámoltuk) {
            
            közelítőÉrték = 4*(közelítőÉrték/4 + p);            
            meddigSzámoltuk = n;        
        }            
        
        return közelítőÉrték;
    }
    
    public static void main(String[] args) {
        
        long n = 1;
        Pi pi = new Pi();
        while(true) {
            n *= 10;
            System.out.println("pi ~ Pi(n) = " + pi.közelítés(n)
                    + ", n = " + n 
                    + ", Math.PI/Pi(n) = " 
                    + (Math.PI / pi.közelítés(n)));            
        }
    }    
}
                            ]]>
                            </programlisting>   
                            </para>                            
                                                        
                        </example>
                        
                            <tip>
                            <title>A Pi jegyeinek nyomában</title>
                            <para>
                                Ha az Olvasó futtatná a most
                                vázolt programot, akkor tapasztalhatná,
                                hogy az említett <citation>KAPCSOLAT REGÉNY</citation>
                                olvasásának befejezésekor keletkezett
                                lelkesítő feszültségét ezekkel
                                bizony nem tudta levezetni-átvezetni
                                a Pi jegyeinek
                                önálló keresésében. Ha a kedves Olvasó
                                valóban így érezne, akkor
                                <emphasis><link linkend="pi_jegyei">A Pi jegyeinek nyomában</link></emphasis>                                 
                                matematikai témájú programozási mellékletünket és például a
                                <citation>PI KÖNYV</citation> könyvet
                                ajánljuk figyelmébe. Itt és most csak az iménti 
                                <classname>Pi</classname> osztályunk két kiterjesztését
                                mutatjuk be, a 
                                <classname>RamanujanPi</classname> osztályban
                                a hivatkozott 
                                <citation>PI KÖNYV</citation> alapján a Ramanujantól
                                származó, még a 
                                <classname>ChudnovskyPi</classname> osztályban, ugyancsak a 
                                hivatkozott <citation>PI KÖNYV</citation> alapján a 
                                Chudnovsky-féle Ramanujan típusú formulát mutatjuk be.
                            </para>
                            </tip>

                            <example id="ramanujan_chudnovsky">
                            <title>A Ramanujan és a Chudnovsky közelítő összegek formulái</title>
                            
                            <para>
                            <programlisting>
                            <![CDATA[
public class RamanujanPi extends Pi {
    
    double pTár = 0.0;
    
    public double közelítés(long n) {
        
        double p = 0.0;
        double sz = (2.0 * Math.sqrt(2.0)) / 9801.0;
        
        for(long k=meddigSzámoltuk; k<n; ++k)
            p += (f(4*k)*(1103.0 + 26390.0*k))
            / (Math.pow(f(k), 4.0) * Math.pow(396.0, 4.0*k));
        
        if(n > meddigSzámoltuk) {
            pTár += p;
            közelítőÉrték = 1.0/(sz*pTár);
            meddigSzámoltuk = n;
        }
        
        return közelítőÉrték;
    }
    
    /** k!, azaz k faktoriális kistámítása */
    public double f(long k) {
        
        double f = 1.0;
        
        for(long l=1; l<k; ++l)
            f *= l;
        
        return f;
    }
    
    public static void main(String[] args) {
        
        RamanujanPi pi = new RamanujanPi();
        
        for(int n=2; n<5; ++n) {
            System.out.println("pi ~ Pi(n) = " + pi.közelítés(n)
            + ", n = " + n
                    + ", Math.PI/Pi(n) = "
                    + (Math.PI / pi.közelítés(n)));
        }
    }
}                            
                            ]]>
                            </programlisting>   

                            Ha az Olvasó fordítaná és futtatná a programot, akkor
                            a következő kimenetét láthatná:
                            
                            <screen>
                            <![CDATA[
[norbi@niobe ~]$ javac RamanujanPi.java
[norbi@niobe ~]$ java RamanujanPi
pi ~ Pi(n) = 3.141592710907427, n = 2, Math.PI/Pi(n) = 0.9999999817552309
pi ~ Pi(n) = 3.1415927109074255, n = 3, Math.PI/Pi(n) = 0.9999999817552313
pi ~ Pi(n) = 3.1415927109074255, n = 4, Math.PI/Pi(n) = 0.9999999817552313                            
                            ]]>
                            </screen>
                                                        
                            Érdekességként megjegyezhetjük, hogy ugyanaz az 
                            R. W. Gosper, akinek „sikló ágyú”
                            nevű sejtautomata élőlényét bemutatjuk a 
                            <emphasis><link linkend="siklo_agyu">Az R. W. Gosper-féle sikló ágyú élőlény bemutatása</link></emphasis>                             
                            című táblázatban, 1985-ben erre a formulára alapozva,
                            17.526.200 tizedesjegyig határozta meg a Pi értékét.
                            </para>                            
                            
                            <para>                            
                            Mivel mi csupán a 64 bites lebegőpontos aritmetikát
                            használjuk, csak a fent idézett számítást tudjuk futtatni,
                            azaz a                             
                            Pi(n) = <emphasis>3.141592</emphasis>710907427
                            6 tizedesig pontos eredményig jutottunk.
                            </para>                            

                            <para>
                            <programlisting>
                            <![CDATA[
public class ChudnovskyPi extends RamanujanPi {
    
    public double közelítés(long n) {
        
        double p = 0.0;
        
        for(long k=meddigSzámoltuk; k<n; ++k)
            p += ((1-(k%2)*2)*f(6*k)*(13591409 + 545140134*k))
            /(f(3*k)*Math.pow(f(k), 3.0)*Math.pow(640320, 3*k+3.0/2.0));
        
        if(n > meddigSzámoltuk) {
            pTár += p;
            közelítőÉrték = 1.0/(12.0*pTár);
            meddigSzámoltuk = n;
        }
        
        return közelítőÉrték;
    }
    
    public static void main(String[] args) {
        
        ChudnovskyPi pi = new ChudnovskyPi();
        
        for(int n=2; n<5; ++n) {
            System.out.println("pi ~ Pi(n) = " + pi.közelítés(n)
            + ", n = " + n
                    + ", Math.PI/Pi(n) = "
                    + (Math.PI / pi.közelítés(n)));
        }    
    }
}
                            ]]>
                            </programlisting>   
                            
                            Ha az Olvasó fordítaná és futtatná a programot, akkor
                            a következő kimenetét láthatná:
                            
                            <screen>
                            <![CDATA[
[norbi@niobe ~]$ javac ChudnovskyPi.java
[norbi@niobe ~]$ java ChudnovskyPi
pi ~ Pi(n) = 3.141592653589764, n = 2, Math.PI/Pi(n) = 1.0000000000000093
pi ~ Pi(n) = 3.141592653589764, n = 3, Math.PI/Pi(n) = 1.0000000000000093
pi ~ Pi(n) = 3.141592653589764, n = 4, Math.PI/Pi(n) = 1.0000000000000093                            
                            ]]>
                            </screen>                            
                            
                            (Mivel mi csupán a 64 bites lebegőpontos aritmetikát
                            használjuk, csak a fent idézett számítást tudjuk futtatni,
                            azaz a                             
                            Pi(n) = <emphasis>3.1415926535897</emphasis>64
                            13 tizedesig pontos eredményig jutottunk.)                            
                            </para>                            
                            
                            </example>

                            <para>                            
                                <emphasis><link linkend="pi_jegyei">A Pi jegyeinek nyomában</link></emphasis>                                 
                                matematikai témájú programozási mellékletünk Pi jegyeit
                                boncoló részében már olyan osztályokat is tárgyalunk,
                                amelyekkel a 64 bites lebegőpontos aritmetikát használva
                                is remek programozási élményeket gyűjthetünk. Most
                                csupán ízelítőül vágjuk be ide a 
                                <classname>PiBBP</classname> osztályunkkal kiszámolt
                                1000 darab számjegyét a Pi hexadecimális kifejtésének, a
                                kifejtés 1000001.
                                jegyétől.
                        <screen>
                            <![CDATA[
[norbi@niobe ~]$ javac PiBBP.java
[norbi@niobe ~]$ java PiBBP
6C65E52CB459350050E4BB178F4C67A0FCF7BF27206290FBE70F93B828CD939C475C728F2FDB0CB9
23CF52C40D631D4DB2E98340AA25A6F07DB685C0A9C04F3F6E667CFD6E1764C83ECA94E79661FC18
0E6AEF581987E79E13278712CB01255E8CE4D9E048F782D756370548FB0778323CF2074C2716D121
639F1DD5A31EF6C242676B3783AD528852CCA52A9B4F999C526B0750859AEEC9CE6635B30996A210
CD419D5FD47A4E7AAF906E26A4CCF99A2E493BBB5E7D5E0B94F15196DA8CD1A0C57FE03A629B2D58
42317C173D163EA8717B46930EE0FE82FEC4B01016F155FB446AA6958EAD9265EC0C914CB84755DD
1BCE5100C23804D67A787BEC57CD7D8E190B3F55E3D2558927215504F141AC8B0BA836F7781E1966
4EFA8B22BEB3816A70F7210E4784A1F37762361286448CD051BCE3A4CE156D70CDBA256C1A36C386
48633C8F13A53405795635084A2DEAF3B9066BC3863BB07447DDDBDE5644034A6893E3E1CFDB3696
31BAA4240D93F17F667F7C51ABF076F7C1BB35DECC240153F4817A579CBD1DAC895E8555929D1ADA
3C787A0BF2881BBC44C4BE505E91FE5A28B9BA47D4845B7639239AD71D8B63BF9D23B2CC88C9D39C
033B0482F5F801D778BBB734EA8B1BE878D129514BFA5C4A6D60E80CF4B14A2A5673992B18397230
54BD44F767B03245F2873973EF6D84B2B96EFC9A
                            ]]>
                      </screen>            
                                            
                            </para>                            
                            
                            
                    </sect5>
                    
                </sect4>

                <sect4>
                    <title>Eldönthetetlenség a formális axiomatikus elméletekben</title>

                    <blockquote>
                        <attribution>Madách Imre</attribution>
                        <literallayout>
                            „ANGYALOK KARA
                            Szabadon bűn és erény közt
                            Választani, mily nagy eszme,”                    
                        </literallayout>
                    </blockquote>
                    
                    <para>
                        A tudás fájának gyümölcséből fogyasztva megadatott,
                        hogy dönthessünk igazság és hamisság között, de a döntés
                        nem egyszerű. Az axiomatikus módszer ezt segíti. Néhány
                        elfogadott igazságból, mechanikus levezetési szabályok
                        segítségével további igazságokat gyártunk. Saját mindennapi
                        döntéseinkben többször, másokéban meg még jóval többször 
                        vélünk észre venni részrehajlást. Ebben az értelemben az 
                        axiomatikus
                        módszer egy instant eljárás: „csak felöntjük
                        vízzel”, azaz levezetünk; miközben a döntés
                        objektív marad, nem függ az érvelőtől, a levezetést
                        végzőtől, azaz a <quote>bárki ezt hozta volna ki, így én 
                        magam is erre az eredményre jutottam volna</quote> megközelítés
                        megadja az objektivitás élményét. Ehhez a levezetéshez
                        persze az emberi beszéd túlságosan is árnyalatgazdag
                        - ezt elfogadni elég a választási kampányok sokszor
                        végtelennek tűnő meddő dialógus-párbeszédeire gondolni,
                        ahol megszokott, hogy az A állítást és annak tagadását is
                        minden különösebb nehézség nélkül bizonyítják a jelöltek - 
                        ezért a levezetéseket egy speciális nyelven, egy matematikai
                        logikai nyelven kell elvégeznünk. 
                    </para>
                    
                    <para>
                        A matematikai logikai nyelvek nagyon közel állnak a 
                        programozók gondolkodásához, akik ezért könnyen tudják
                        beszélni, pontosabban írni és olvasni is. Tekintsünk 
                        meg egy konkrét 
                        arról szóló 
                        példát, hogyan beszélünk egy ilyen matematikai 
                        logikai nyelven, ami legyen a 
                        <citation>DRAGÁLIN KÖNYV</citation> könyvben ismertetett
                        Ar nyelv.  
                    </para>
                    
                    <example>
                        <title>Az Ar klasszikus elsőrendű matematikai logikai nyelv</title>
                        
                        <para>
                            A hivatkozott <citation>DRAGÁLIN KÖNYV</citation> Ar nyelv a számok világabeli pontos
                            állítások leírását teszi lehetővé, segítségével a 
                            számokra vonatkozó állításokat lehet formalizálni.
                            <orderedlist numeration="upperroman">
                                <listitem>
                                    <para>
                                    Az Ar típusos nyelv, egyetlen típusa a szám típus, 
                                    a szám típusú változók nevei betűkből álló azonosítók, 
                                    de tipikusan az egyetlen betűből álló változóneveket
                                    szoktuk használni: a, b, c, ..., x, y, z, ...
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                    Az Ar nyelvben egyetlen konstans, a 0 szimbólummal
                                    jelölt konstans van.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                    Az Ar nyelvben a szavak felépítésére
                                    három függvény szolgál, ezeket a S(), 
                                    +(,), *(,) szimbólumok jelölik. A változónevek
                                    és a konstans egyszerű szavak, a függvények
                                    segítségével ezekből összetett szavak építhetők
                                    az alábbiak szerint
                                    <orderedlist numeration="lowerroman">
                                        <listitem>
                                            <para>
                                            az Sszó szó egy összetett szó (S a szó értékének
                                            eggyel való növelése) 
                                            </para>
                                        </listitem>
                                        <listitem>
                                            <para>
                                            a szó+másikszó szó egy összetett szó
                                            </para>
                                        </listitem>
                                        <listitem>
                                            <para>
                                            a szó*másikszó egy összetett szó
                                            </para>
                                        </listitem>                                        
                                    </orderedlist> 
                                    Például az SS0, S(0+S0),
                                            S(0+S0)*SS0  összetett szavak.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                    Az Ar nyelv állításai vagy 
                                    mondatai (szó = másikszó) alakúak.
                                    A mondatokból összetett mondatok alkothatók az
                                    ÉS, a VAGY, a NEM és a KÖVETKEZIK 
                                    logikai jelekkel, az
                                    egzisztenciális (LÉTEZIK) és az univerzális
                                    (MINDEN) kvantorok segítségével.
                                    Például a LÉTEZIKc (a+c=b) ÉS (!(a=b)) Ar nyelvű
                                    állítás
                                    felolvasva: 
                                    <emphasis>van olyan
                                    c, amit az a változóhoz adva b-t ad, azaz 
                                    a &lt; c</emphasis>.
                                    </para>
                                </listitem>
                            </orderedlist>
                                    
                            Az Ar nyelven pontosan meg tudjuk fogalmazni a számok
                            világabeli állításainkat. Írjuk fel például egy Ar
                            nyelvű mondat formájában, az 
                            (a &lt; b) := (LÉTEZIKc (a+c=b) ÉS (!(a=b)))
                            , hogy 
                            <itemizedlist>
                                <listitem>
                                    <para>
                                    <emphasis>minden számnál van nagyobb</emphasis>:
                                     MINDENx (LÉTEZIKy(x &lt; y))
                                    </para>                                    
                                </listitem>
                                <listitem>
                                    <para>
                                    <emphasis>van olyan szám, aminél nincs 
                                    nagyobb</emphasis>:
                                    LÉTEZIKy (MINDENx (x &lt; y))
                                    </para>                                    
                                </listitem>
                                <listitem>
                                    <para>
                                    <emphasis>a számok végtelen sokan vannak</emphasis>:
                                     MINDENx (LÉTEZIKy(x &lt; y))
                                    </para>                                    
                                </listitem>
                                <listitem>
                                    <para>
                                    <emphasis>véges sok szám van</emphasis>:
                                    LÉTEZIKy (MINDENx (x &lt; y))
                                    </para>                                    
                                </listitem>                                
                            </itemizedlist>
                                    
                        </para>
                        
                    </example>

                    <example>
                        <title>Saját terület formalizálása</title>
                            
                            <para>
                                Programozóként a formalizálással kapcsolatban
                                az automatikus tételbizonyítás egy izgalmas
                                terület, ahol olyan programokat tudunk írni, 
                                amelyek képesek formulák igazságának vagy
                                hamisságának mechanisztikus eldöntésére. Ehhez 
                                első lépés a vizsgált terület formalizálása, melynek
                                során ki kell alakítanunk egy nyelvet, amin tárgyalhatjuk
                                a vizsgált területet. Most példaként foglalkozzunk a 
                                programokkal! 
                                Egyetlen típusunk legyen a program típus, 
                                a program típusú változók nevei betűkből álló azonosítók, 
                                de tipikusan használjuk az x, y, z, ... betűket.
                                Jelölje E(x), hogy az x program esztétikus,
                                J(x), hogy jó.
                                
                            <itemizedlist>
                                <listitem>
                                    <para>
                                    <emphasis>Az esztétikus programok jók</emphasis>:
                                     MINDENx (E(x) KÖVETKEZIK J(x))
                                    </para>                                    
                                </listitem>
                                <listitem>
                                    <para>
                                    <emphasis>Csak az esztétikus programok jók</emphasis>:
                                     MINDENx (J(x) KÖVETKEZIK E(x))
                                    </para>                                    
                                </listitem>
                                <listitem>
                                    <para>
                                    <emphasis>Az esztétikus és csak az esztétikus programok jók</emphasis>:
                                     MINDENx ((E(x) KÖVETKEZIK J(x)) ÉS (J(x) KÖVETKEZIK E(x)))
                                    </para>                                    
                                </listitem>
                                <listitem>
                                    <para>
                                    <emphasis>Minden program, kivéve a nem esztétikusakat, jó</emphasis>:
                                     MINDENx (NEM E(x) KÖVETKEZIK J(x))
                                    </para>                                    
                                </listitem>
                                <listitem>
                                    <para>
                                    <emphasis>Esztétikus program is lehet rossz</emphasis>:
                                     LÉTEZIKx (E(x) ÉS NEM J(x))
                                    </para>                                    
                                </listitem>
                                <listitem>
                                    <para>
                                    <emphasis>Nem minden esztétikus program jó</emphasis>:
                                     NEM MINDENx (E(x) KÖVETKEZIK J(x))
                                    </para>                                    
                                </listitem>                                
                            </itemizedlist>                                
                            </para>
                            
                    </example>

                    <para>
                        Egy adott tudományterület <emphasis>axiomatikus formális
                        elmélete</emphasis> egy logikai nyelvből és az axiómákból áll.
                        A természetes számok vizsgálatára létrehozott
                        elméletet az Ar nyelv és a Peano-féle axiómarendszer
                        alkotja. Egy elméletet <emphasis>teljesnek</emphasis>
                        nevezünk, ha a 
                        hozzá tartozó nyelv bármely mondatáról eldönthető, hogy
                        ő vagy éppen az ellenkezője vezethető le az elméletben.
                    </para>
                                        
                    <para>
                        De az axiomatikus módszernek is megvannak a maga
                        korlátai, melyeket Hilbert nagy szomorúságára 
                        Gödel híres inkompletibilitási tételei formájában
                        tárt fel 1931-ben. A sors szeszélye, hogy éppen egy nappal
                        azelőtt tette közzé eredményeit, mielőtt Hilbert
                        azóta híressé vált mondásában hitet tett a tudásról
                        alkotott alábbi meggyőződése mellett: 
                        „Tudnunk kell, tudni fogjuk.” Ezzel a hittel
                        szemben az első ilyen inkompletibilitási tétel állítása, hogy a 
                        formális axiomatikus elméletek nem teljesek. Példánknál
                        maradva vannak olyan állítások, melyek igazak a természetes
                        számok körében, de az Ar elméletben sem bizonyítani, sem
                        cáfolni nem lehet őket, azaz sem a megfelelő Ar nyelvi
                        mondat, sem annak tagadása nem vezethető le az elméletben.
                        A témakör pontos fogalmait az Olvasó a 
                        <citation>DRAGÁLIN KÖNYV</citation> könyvben találja meg.
                    </para>

                    <para>
                        A Chaitin-Kolmogorov bonyolultsággal kapcsolatban 
                        megismert fogalmainkat felhasználva könnyen tehetünk 
                        igaz, de bizonyíthatatlan állításokat. Lássuk a 
                        <citation>VITÁNYI KÖNYV</citation> ilyen bevezető 
                        példájának egy programozói megfogalmazását.
                        Ez a hivatkozott <citation>VITÁNYI KÖNYV</citation> példa 
                        arról szól, hogy léteznek bonyolultságot 
                        használó igaz, de bizonyíthatatlan - azaz Gödeli - állítások.
                        Nevezetesen az állítás az, hogy
                        <emphasis>az „x sorozat véletlen” állítás
                        nem bizonyítható.</emphasis> Ennek bizonyításaként tegyük
                        fel, hogy mégis az! Ekkor tudunk egy olyan programot írni,
                        amely generálja a megfelelő elméletbeli levezetéseket
                        és előbb-utóbb rátalál az indirekt feltevésünk szerint
                        létező levezetésre, azaz a bizonyításra...
                    </para>

                    <para>                                                
                        A megfelelő formális axiomatikus elméletet F-el jelölve
                        és elképzelve, hogy az F elméletet 0, 1 jegyekkel lekódoltuk,
                        felülről becsülhetjük a bonyolultságát, azaz K(F)&lt;=|F|&lt;=f
                        az x sorozat véletlen állítás pedig szemantikailag azt
                        jelenti, hogy K(x)&gt;=|x|
                    </para>
                    
                    <para>                                                
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/algelm/godel.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Bonyolultságot használó igaz, de bizonyíthatatlan állítás.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                            
                    </para>

                    <para>                                                
                        Amikor a program kiírja az x-et, az if utasítás
                        fejéből láthatjuk, hogy |x|&gt;f, ezt felhasználva az
                        indulásnál tett felső becslésünknél K(F)&lt;=|F|&lt;=f&lt;|x|
                        adódik, azaz röviden K(F)&lt;|x|. Ha a két bonyolultságos
                        egyenlőtlenségre pillantunk, szépen látszik az
                        ellentmondás:
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        K(F)&lt;|x|
                                    </para>                                    
                                </listitem>
                                <listitem>
                                    <para>
                                        K(F)&gt;=|x|
                                    </para>                                    
                                </listitem>
                            </itemizedlist>
                    </para>
                    
                    <!--
                    <sect5>
                        <title>Chaitin inkompletibilitási tételei</title>

                        <para>
                            HIÁNYZÓ RÉSZ
                        </para>

                    </sect5>
					-->

                        <para>
                            Megjegyezhetjük, hogy az automatikus tételbizonyítással
                            kapcsolatos logikai kutatások szülték az olyan, a deklaratív
                            programozási paradigmák alá sorolt programozási nyelveket, mint
                            például a Prolog. 
                            A <emphasis><link linkend="torzsfa">A programozás egy filogenetikai törzsfája</link></emphasis> című pont
                             alatt részletesebben olvashat a programozási paradigmákról. 
                        </para>

                </sect4>

                    
            </sect3>
            
            <sect3>
                <title>A programozás evolúciója</title>
                
            <blockquote>
                <attribution>Marx György</attribution>
                <para>„A BASIC után PASCAL következzék (felfelé) vagy ASSEMBLER (lefelé)? A matematikusoknál a PASCAL-nak, a diákoknál az ASSEMBLER-nek van nagyobb tábora.”</para>
            </blockquote>                
                
            <para>
                Ha a kedves Olvasó egy pillantást vet a
                <citation>LEVÉNEZ IDŐVONALAK</citation>
                programozási nyelveket bemutató munkájára, 
                akkor az a benyomása támadhat, hogy témánk, 
                a programozás
                egy élő, önmagát szervező diszciplína. 
                A programozási nyelvek arra szolgálnak, hogy 
                kommunikálhassunk új szervünkkel - egyik 
                legújabb játékszerünkkel - a gyors számításokat
                végző gépekkel. Ez sok ember számára nagyon 
                rejtélyes, majd idővel nagyon izgalmas tevékenység.
                De ennek a rejtélyből az izgalomig hatoló megismerési
                folyamatnak a mellékterméke a fejlődés, s ami az egyik
                embernek valamikor izgalmas volt, úgy lesz már inkább
                csak (történeti) érdekesség egy későbbi valakinek, de
                a sors igazságossága, hogy ez a lánc végtelenül folytatódik:
                minden későbbi valaki valamikorivá válik.  
                Amit közben
                felhalmoznak, az az informatikai kultúra.
            </para>
            
            <para>
                És ki tudja milyen lesz a jövője ennek a kultúrának? 
                Például a gépek átalakíthatják
                annyira a mindennapjainkat, hogy egy program forrásszövegének
                elemzéséről szóló óra megjelenhet egy vers elemzéséről szóló
                középiskolai óra mellett esélyes vetélytársként?
            </para>
            
            <para>
                Kevésbé irodalmi, de költői kérdést felvetve: egyszerűbb ma a 
                programozás, 
                mint tegnap? Azonnal vágnánk rá, hogy igen, pedig lehet, hogy
                inkább mégsem! Mi nem akarjuk eldönteni, csak egy további kérdéssel
                sugallni, hogy szerintünk mi a válasz. Egy C vagy egy Java
                programozás tankönyv Chaitin-Kolmogorov bonyolultsága nagyobb-e?
            </para>
            
            <para>
                Meggyőződésünk, hogy amíg a számítógépeink nem az ember
                központi idegrendszerének emberi tudatot létrehozó működése mintájára
                működnek, addig a programozást mindig tanulnunk kell. 
                Márpedig máshogy működnek és a jövő (például a lehetséges kvantum
                programozás?), vagy az azt követő
                jövő még jobb gépei, méginkább máshogy működhetnek majd.
                Ismét 
                csak egy sugalmazó kérdést feltéve: mit érezhetne egy 10 éve
                napi gyakorlatban dolgozó imperatív programozó, amikor tegnapra
                Prolog fejlesztővé kellene átképeznie magát?
            </para>
                
            </sect3>
            
            <sect3 id="torzsfa">
                <title>A programozás egy filogenetikai törzsfája</title>
                
                <blockquote>
                    <attribution>Stanislas Dehaene</attribution>
                    <para>
                    „A matematika Wigner Jenőt lenyűgöző csodálatos hatékonysága a szem látáshoz való alkalmazkodásához hasonlóan a szelektív evolúcióval magyarázható. Ha napjaink matematikája hatékony, az csak azért van, mert a tegnap nem eléggé hatékony matematikáját könyörtelenül kiirtották és kicserélték.”</para>
                </blockquote>

                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/prog/fa.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A programozás egy filogenetikai törzsfája.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                                            
                </para>

            <sect4>
                <title>Megjegyzések a törzsfához</title>
                
                <para>
                A Turing kiszámítható programozás alatt azt értjük, hogy minden olyan dolgot, amit a belőle leszármazó programozások alól származó programozási nyelveken meg lehet csinálni, azt Turing géppel is meg lehet csinálni.
                </para>
                <para>
                A DES törés a <citation>DES TÖRÉS</citation> cikkben ismertetett konkrét DNS számítás. 
                A DNS számítások tipikusan a <quote>brute force</quote> jellegű feladatmegoldásra alkalmasak, ahol
                az összes potenciálisan lehetséges megoldás megvizsgálása során kapjuk a tényleges megoldásokat. A DNS
                számítások apropója, hogy a lehetséges összes megoldást egyszerre, párhuzamosan próbálják ki.
                Az említett DES eljárással akkor találkozhat az Olvasó, amikor egy UNIX vagy Linux rendszerű gépre bejelentkezik, 
                ekkor a begépelt jelszaván, például a 
                <computeroutput>matyi2006</computeroutput> karaktersorozaton
                 a bejelentkeztető program végrehajtja a DES algoritmusát, aminek eredménye, a 
                példánál maradva a <computeroutput>$1$wZ3bMDHK$Xogj2CHjy4.o3MEB2nhp00</computeroutput>
                karaktersorozat. 
                Jelszavunk ilyen kódolt képét tárolja a gép, 
                Linux alatt például a <filename>/etc/shadow</filename> állományban.
                A két minta összevetésétől függ, hogy a bejelentkeztető program beenged-e minket a rendszerbe vagy sem. A DES
                törése annyit tesz, hogy meg tudjuk mondani a kódolt képhez tartozó eredeti szót.
                Csak érdekességként jegyezzük meg és ez a megjegyzés nem kapcsolódik a DNS számításokhoz,
                 hogy a jelszavakat törő programok (ilyen például a <application>cracklib</application>)
                 célja, hogy a rendszergazda rávegye a felhasználókat, hogy - a teljes rendszer védelmében - megfelelően
                 bonyolult jelszavakat válasszanak maguknak. A <citation>PROGRAMOZÓ PÁTERNOSZTER JEGYZET</citation>
                 jegyzetben arra láthatunk példát, hogyan törhetjük, az említett céllal, a felhasználóink jelszavait egy másik, 
                 a <application>John the Ripper</application> programmal.                 
                </para>

                <para>
                 Az említett LEGO Mindstorms NXT korábbi változatát, a 
                 <trademark class="copyright">LEGO</trademark>
                  <trademark class="registered">Mindstorms</trademark>
                  Robotics Invention System robotot egyébként Javaban is
                 lehetett programozni a <citation>LEJOS JAVA</citation> rendszer segítségével. A 
                 <citation>JÁVÁCSKA PORTÁL</citation> és a 
                 <citation>JÁVÁCSKA BARÁTAI</citation> lapjain számos olyan előadás prezentációnk
                 található, ahol ezt mutatjuk be, ilyen például a                  
                 <citation>TANÁRKÉPZÉS EA.</citation> bemutató.
                </para>
                
            </sect4>
                                                
                <sect4>
                    <title>Röviden az egyes programnyelvekről</title>
				<sect5>
                    <title>Ada</title>
                    <para>
Az Amerikai Hadügyminisztérium támogatásával tervezett eljárásorientált nyelv, a NATO egyik hivatalos programozási nyelve. Bonyolult, az eljárásorientált paradigma minden  eszközét tartalmazó nyelv. Az Ada 95 verzió óta objektumorientált konstrukciókat is tartalmaz.
</para>
</sect5>

				<sect5>
                    <title>C</title>
                    <para>
Az egyik legsikeresebb eljárásorientált nyelv. Gépi kódú logikával és azt közelítő sebességgel rendelkező programok írhatók benne. Speciális a mutató típusa. Nincs dinamikus szemantika ellenőrzés. A memóriát a programozó kezeli. Rendszerprogramozásra is használják. Szabad felhasználású implementációi is léteznek (pl. a gcc).
</para>
</sect5>

				<sect5>
                    <title>C++</title>
                    <para>
Az egyik legsikeresebb objektumorientált nyelv, a C kiterjesztése. Többszörös öröklődést, dinamikus és statikus kötést, általánosított referencia típust, speciális típuskényszerítést tartalmaz. A memóriát a programozó kezeli, nincs automatikus szemétgyűjtögetés. Szabad felhasználású implementációi is léteznek (pl. a gcc).
</para>
</sect5>

				<sect5>
                    <title>C#</title>
                    <para>
Az OO paradigmából Java-elveket megvalósító, a .NET keretrendszerbe integrált nyelv. Fejlett vizuális eszközkészlettel és speciális hatásköri eszközkészlettel (névterek) rendelkezik.
</para>
</sect5>

				<sect5>
                    <title>Delphi</title>
                    <para>
A Pascal objektumorientált változata, amelyben az adatbázis-programozás is lehetséges. 
</para>
</sect5>

				<sect5>
                    <title>Java</title>
                    <para>
A Java egy „majdnem” tiszta OO nyelv. A C++ egy továbbfejlesztett változataként jött létre a
nyílt elosztott rendszerek programozási nyelveként. Tartalmaz eljárásorientált elemeket, de programozni benne csak az OO paradigma mentén lehet. Tervezésénél alapvető volt a biztonságos kód írásának követelménye.
A Java egyszeres öröklődést, késői kötést, automatikus memóriakezelést valósít meg. Vannak benne primitív típusok, ezek megfelelnek az eljárásorientált egyszerű típusoknak. Van változója, ami primitív típusú értéket, vagy objektumreferenciát vehet fel értékül. A referencia típusú változók mindig a hivatkozott objektumot adják. Kifejezésfogalma teljesen C-szerű. A módszereket függvények segítségével, az attribútumokat változókkal lehet megadni. Ismeri a csomagot, ez a fordítási egysége. Bezárási eszközrendszere négy szintű. A publikus, privát és védett szintet explicit módon kell megadni. Alapértelmezett a csomag szintű láthatóság. A Javának hatékony kivételkezelő és párhuzamos programozást lehetővé tevő eszközrendszere van, az 5-ös verzióba már beépítették a generikust is. Az interfész egy speciális viselkedésmód absztrakció implementálását lehetővé tevő eszköz.
A Java fordítóprogram egy közbenső formára, az ún. bájtkódra fordít, amelyet aztán a Java Virtual Machine (JVM) interpretál. Ez  segíti a hordozhatóságot.
</para>
</sect5>

				<sect5>
                    <title>JavaScript</title>
                    <para>
A web programozás kliens- és szerveroldali szkript nyelve. Objektumalapú és eseményvezérelt. HTML dokumentumok kezelését teszi lehetővé.
</para>
</sect5>

				<sect5>
                    <title>Lisp</title>
                    <para>
A funkcionális paradigmát bevezető nyelv. Nagyon sok verziója létezik, közülük a dinamikus  objektum fogalommal rendelkező CLOS a leghíresebb. Az eredeti Lisp sok imperatív jellegű eszközt tartalmazott, nem volt tisztán funkcionális.
</para>
</sect5>

				<sect5>
                    <title>Perl</title>
                    <para>
Az egyik legsikeresebb szkript nyelv. Objektumorientált. Reguláris kifejezései igen hatékony és tömör programozást tesznek lehetővé. A webprogramozásban jelentősége igen nagy. A szerveroldali CGI programozás alapeszköze.
</para>
</sect5>

				<sect5>
                    <title>PHP</title>
                    <para>
A szerveroldali web programozás szkript nyelve. Nyílt forráskódú. Legfontosabb felhasználási területe az adatbázis-elérés. Közel két tucat adatbázis-kezelőhöz rendelkezik vezérlőtámogatással.
</para>
</sect5>

				<sect5>
                    <title>Prolog</title>
                    <para>
A logikai paradigma első és legelterjedtebb nyelve. Sok verziója létezik, köztük objektumorientált is. Az elsőrendű predikátumkalkuluson alapul. A Prolog nyelvi rendszer középpontjában egy következtető gép áll. A nyelvben vannak tiszta logikai, metalogikai és logikán túli eszközök is.
</para>
</sect5>
</sect4>                                                
                                                
                </sect3>
                
                <sect3>
                    <title>Bepillantás napjaink gyakorlatába</title>
                    
                    <para>
						A <citation>JAVA.SUN.COM</citation> lapjain számos helyen találhatunk a Java technológia
						elterjedtségét bemutató adatokat. Emeljünk ki 
						néhányat, például a <citation>JAVA MINDENÜTT</citation> című lapról! 
						Mit saccolunk, mennyi Java programozó lehet világszerte?	
						A hivatkozott lap szerint a Java nyelven
						fejlesztők családja, a Java fejlesztői közösség immár több, mint 5 millió programozót tömörít.
						Ezzel a Java fejlesztői közösség a legnagyobb programozói közösség az ember által ismert
						világegyetemben. Mit programoznak a közösség tagjai? Ugyancsak a  lap adatainak tanúságai
						szerint majdnem 2 milliárd Java kártyát, 800 millió Javával eladott személyi számítógépet és 
						1.2 milliárd Javas mobiltelefont! Érdemes azon elgondolkodni, hogy az Olvasó háztartásában
						mennyi Java Virtuális Gép van? Van például Javas mobilja?
                    </para>

                    
                </sect3>
                
                <sect3>
                    <title>Néhány látomás: a jövő programozása</title>

                <blockquote>
                    <attribution>Wigner Jenő</attribution>
                    <para>
                        „Elképzelhető, hogy az emberi értelemnek ugyanúgy vannak határai, mint az állati intellektusnak. Egy kutya sok mindent megtanulhat, de a szorzótáblát lehetetlen neki megtanítani.”
                    </para>
                </blockquote>
                
                <para>Kognitív értelemben sokszor közelebb érezzük magunkhoz a számítógépeket,
                mint az állatokat,
                talán éppen azért, mert a gépek bármi nehézség nélkül
                kinyomtatják a szorzótáblát. Ezt az érzést több megfigyelésünk erősíti
                meg nap mint nap: például amikor LEGO robotunk, végre már, éppen 
                kitalál a padlón könyvhalmokból rögtönzött labirintusból, vagy a
                híradó bemutatja az éppen legcsillogóbb humanoid robot kacsintását. 
                Mégis könnyen elképzelhetőnek tartjuk, hogy ebben az érzésben csalatkozni fogunk.
                 Nemcsak azért, mert mi  -  szemben a számítógépekkel, akik viszont nem  -  ugyancsak megküzdöttünk a szorzótáblával.</para>
                <para>Érdekes, hogy a mesterséges intelligenciát, 
                a mesterséges intelligencia kutatásában való hitelességet senki 
                nem vitatja el az informatikusoktól. De ez egyben annak is 
                alátámasztása, hogy a mesterséges intelligencia tárgya 
                mára túlontúl eltávolodott a természetes intelligencia reprodukálásától, 
                az <emphasis>„Asimovi gépek”</emphasis>
                <citation>ASIMOV REGÉNY</citation>, 
                <citation>ASIMOV MOZI</citation> 
                létrehozásától.                
                </para>
                <para>                
                Ezért olvashatunk újongva az irodalomban az Orch OR, azaz  
                Orchestrated Objective Reduction, <citation>ORCH OR</citation>
                modellről, mert a modellezett jelenség a tudat. Egyébként a modell
                egyben az interdiszciplinaritás példamutató 
                zászlóshajója is, lévén egyik kidolgozója Roger Penrose fizikus, 
                a másik Stuart Hameroff, aki aneszteziológus. Fontos, hogy elméletük
                cáfolható, maguk adnak meg olyan a modellhez kapcsolódó tulajdonságokat,
                melyek sérülése a modell módosítását vagy természetesen akár 
                elvetését is
                implikálhatja.
                </para>

                <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/prog/jovo.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A programozás egy filogenetikai törzsfájának kiegészítése.</phrase>
                        </textobject>	
                    </inlinemediaobject>                       
                    
                </para>
                <para>                                            
                    A kvantum programozást azért származtattuk a Turing 
                    kiszámítható programozásnál bővebb nem Turing
                    kiszámítható programozás dobozból, mert a kvantum gépek képesek
                    valódi véletlenszámok előállítására <citation>VÉLETLEN MŰSZER</citation>.
                </para>
                <para>
                    A Penrose-Hameroff Orch OR modell interdiszciplináris jellegét 
                    az adja,
                    hogy a modell egyaránt operál biológiai, számítástudományi és
                    fizikai alapokon. Biológiai vonatkozás, hogy a modellbeli
                    számításokat a sejtváz mikrotubulusai végzik, mert a
                    számítások alapvető kapcsolóeleme a mikrotubulus csövecskéket
                    felépítő tubulin fehérjék térbeli szerkezete. 
                    Számítástudományi vonatkozás, hogy ezek a globuláris fehérjék
                    a modell szerint egy hexagonális rácsba szervezett sejtautomata
                    hálózatként működnek. S végül, de elsősorban fizikai vonatkozás,
                    hogy ennek a sejtautomatának van olyan periodikusan
                    jelentkező működési fázisa, mely közvetlenül kapcsolódik
                    a természet legmélyebb ismert elméletéhez, a kvantummechanikához.
                    Mert ebben a fázisban a sejtautomata cella következő állapotát nem 
                    közvetlenül és lokálisan a hat hexagonális cella állapota, hanem
                    holisztikusan, a Penrose által bevezetett, a gravitációhoz 
                    feltételezetten
                    kapcsolódó objektiv állapotvektor redukció határozza meg.
                </para>

                <sect4>
                    <title>A Penrose-Hameroff Orch OR tudat modell</title>

                <blockquote>
                    <attribution>Ilya Prigogine</attribution>
                    <para>
                    „Ha most lennék fiatal kutató, akkor a szellem-test problémát tanulmányoznám. Ez a 21. század nagy kihívása.”</para>
                </blockquote>

                    <para>
                        Napjainkban igen népszerű az agy-számítógép, s ennek
                        megfelelően a idegrendszer-szoftver analógia,
                        aminek gyökerei talán Neumann az agyat és a
                        számítógépet összehasonlító <citation>GÉP és AGY</citation>
                        könyvében gyökereznek. Neumann itt említi, hogy az 
                        idegrendszer egy 
                        <emphasis>„rövid program”</emphasis>,
                        avagy mai terminológiával egy interpreter lehet.
                    </para>
                    
                    <para>
                        Az interpreterek tipikusan egy magasabb absztrakciós
                        szintet vezetnek be az őket futtató réteg felett.
                        Gondoljunk csak a Java Virtuális Gépre mint 
                        interpreterre! 
                        <emphasis><link linkend="magasabb_absztrakcio">A Java platform</link></emphasis> 
                        című kép mutatja, hogy a Java Virtuális Gép elrejti az őt futtató
                        hardverek különbözőségeit. Ebben az értelemben a különböző
                        hardvereket most a fonalférgek, a patkányok, a kutyák 
                        végül a majmok agyán át az ember agyáig képzelhetnénk.
                    </para>
                    
                    <para>
                        Az Orch OR modell is egy számításos modell, abban tér el
                        az uralkodó neuron hálózatos számítási modelltől, hogy
                        alapvető szerepet kap benne két olyan jelenség, amit az
                        ember a legelemibbnek ismer a természetben, 
                        ez a kvantummechanika és a 
                        gravitáció. Kicsit sántító analógiával olyan ez, mintha a 
                        fent említett - s persze most csak ezen analógia 
                        megfogalmazása miatt
                        feltételezett - interpreterünkön futó programunkat gépi
                        kódú részekkel kéne kiegészítenünk, azaz a használt
                        absztrakciós szintünknél - ami ebben az esetben a Java
                        programozás - mélyebb szinteken is kellene
                        dolgoznunk, pontosabban a legmélyebb szinten, analógiánkban
                        gépi nyelven. Egyébként vannak, akik éppen ezen analógia
                        miatt fejezik ki kételkedésüket az Orch OR modell tekintetében.
                        Persze e kritikájukat nem a jelen interpreteres analógiánk
                        alakjában fogalmazzák meg a tézisük védelmében, hogy a tudat
                        működését a klasszikus fizika keretein belül kell megmagyarázni,
                        vagy még inkább a triviálisan a fizikára, kémiára, biokémiára
                        épülő, de immár a saját maga szabályai alapján működő biológiára,
                        idegtudományra: „A tudat sem a kémia alagsorában,
                        sem a fizika pincéjében nem lakik”                        
                        <citation>GONDOLKODÓ KÖNYV</citation>. 
                    </para>
                    <para>
                        Az Orch OR modell általános vitája köré épül a 
                        <citation>PENROSE-HAWKING KÖNYV</citation> könyv, melyből
                        kritikus és támogató hangokat is kiemelhetnénk, s
                        mindenképpen ajánljuk az ebben az irányban 
                        érdeklődő kedves Olvasó figyelmébe. 
                        A modell természetesen az előző bekezdés végének
                        idézetétől eltérő indíttatású kritikákat is kap. A leginkább
                        idézett ilyen <citation>TEGMARK DEKOHERENCIA CIKK</citation>.                        
                    </para>

                    <para>
                        Való igaz, hogy az Orch OR modell egy erősen spekulatív 
                        jellegű modell, de mint egy potenciálisan 
                        lehetséges új paradigma minden olyan érdeklődőnek és
                        főleg programozónak 
                        felkeltheti az érdeklődését, aki többre tartja a tudatot
                        egy Turing gépnél. 
                    </para>
                    
                    <sect5 id="hameroff_mikrotubulus_sejtautomata">
                        <title>Hameroff mikrotubulus sejtautomatái</title>

                        <blockquote>
                            <attribution>Madách Imre
                                <citetitle>Az ember tragédiája</citetitle>
                            </attribution>
                            <literallayout>
                                „Az ember ezt, ha egykor ellesi,
                                Vegykonyhájában szintén megteszi.”                    
                            </literallayout>
                        </blockquote>
                                           
                        <para>
                            Hameroff már korábbi munkáiban felveti annak
                            lehetőségét, hogy az
                            agyi számítások alapvető kapcsolóeleme nem az
                            idegsejt, hanem a minden eukarióta sejtben megtalálható
                            mikrotubulus
                            <citation>HAMEROFF MIKROTUBULUS</citation>.                             
                            Penrose
                            <citation>CSÁSZÁR KÖNYV</citation> ismeretterjesztő
                            könyvének olvasása során <citation>HAMEROFF INTERJÚ</citation>
                            jött Hameroff                             
                            ötlete, hogy az agyi kvantum számítások a mikrotubulusokban
                            mehetnek végbe.
                        </para>

                        <para>
                            Az eukarióta sejtek citoszkeletonját, sejtvázát háromféle
                            fehérjefonalakból felépülő hálózatok alkotják, egyikük
                            a mikrotubuláris hálózat. A citoszkeleton adja meg 
                            a sejt alakját, biztosítja a sejten belüli anyagszállítást,
                            esetleg adott esetben még a sejt mozgását is, 
                            ha például a csillókra gondolunk.
                            A mikrotubulusok kétféle tubulin fehérjéből felépülő
                            csövecskék. A kétféle tubulin egymással tubulin
                            dimernek nevezett egységet alkot,
                            melyek egymás után fűzve a protofilamentumokat alkotják.
                            Tipikusan 13 ilyen protofilamentum szál egy hengerpaláston
                            párhuzamosan elhelyezkedve alkotja a mikrotubulust
                            <citation>SEJTBIO 1</citation>, <citation>SEJTBIO 2</citation>.
                            A tubulin dimerek elhelyezkedését hexagonális ráccsal
                            modellezhetjük, ahol egy tubulin dimernek hat 
                            tubulin dimer szomszédja van
                            <citation>MIKROTUBULUS 1</citation>.
                        
                        </para>
                            
                        <para>
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/prog/mikrotubulus.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>A mikrotubulus általában 13 protofilamentum alkotta hengeres csövecske.</phrase>
                                </textobject>	
                            </inlinemediaobject>                       
                        
                        </para>
                        
                        <para>
                            A tubulin dimerek két egymáshoz nagyon hasonló, a
                            fehérjemolekulák konformációja, térszerkezete meghatározta
                            állapotban
                            léteznek. Ezért kétállapotú kvantummechanikai 
                            rendszereknek tekinthetők. Ahogy már említettük, 
                            Hameroffnak éppen
                            Penrose <citation>CSÁSZÁR KÖNYV</citation> ismeretterjesztő 
                            könyvének tanulmányozása során jutott eszébe, hogy
                            a mikrotubulusok ideális otthont biztosíthatnak 
                            a Penrose által javasolt objektív redukciónak
                            nevezett feltételezett folyamatnak.                            
                        </para>
                                                
                    </sect5>
                    
                    <sect5>
                        <title>Penrose objektív redukciója</title>
                        
                        <blockquote>
                            <attribution>Vassy Zoltán</attribution>
                            <para>
                                „Így bármilyen furcsán hangzik, logikailag 
                                lehetséges, hogy magában az objektív világban a 
                                fizikai mennyiségeknek soha nincs egy-egy jól 
                                definiált értékük; csak egy-egy eloszlásuk van, 
                                amelyben a lehetséges értékek egyidejűleg léteznek. 
                                A tudat működik úgy, hogy ezekből az eloszlásokból 
                                konkrét értékeket csinál.”
                            </para>
                        </blockquote>
                    
                        <para>
                        Az <citation>ORCH OR</citation> modell szerint a 
                        mikrotubulus tubulin dimerek alkotta hexagonális rácsa 
                        bizonyos periódusokban
                        klasszikus sejtautomataként 
                        végez számításokat, aminek során a rács egy csomópontjának
                        állapota 6 szomszédjának állapotától függ. Az ezzel 
                        szembeni fejlődési periódusokban viszont a rács egyre
                        több csomópontja kapcsolódik be egy komplex szuperponált
                        kvantummechanikai állapotba, mely során a csomópont
                        állapotáról nem beszélhetünk, hanem csak azután, amikor
                        ennek a fejlődési folyamatnak 
                        a Neumann féle 1-es folyamat
                        (<citation>NEUMANN KVANTUM KÖNYV</citation> 200. oldal,
                        vagy ismeretterjesztő szinten a 
                        <citation>CSÁSZÁR KÖNYV</citation> könyv - 276. oldal - 
                        terminológiájával 
                        az R, az állapotredukció folyamata), 
                        azaz a mérés
                        véget vet és a csomópontok 
                        a méréskor szóba jöhető valószínűségekkel 
                        az egyik vagy a másik állapotukba
                        kerülnek. Az Penrose-féle OR, objektív redukció
                        szerint a kvantummechanikai unitér fejlődésnek
                        végetvető mérés objektíven - például a megfigyelő
                        tudatától függetlenül - következik be, amikor
                        a komplex szuperponált állapotban együtt élő 
                        konformációk térbeli tömegeloszlásainak különbsége
                        átlép egy, a Penrose által <emphasis>egy graviton határnak</emphasis>
                        nevezett értéket. Az <citation>ORCH OR</citation> cikkben
                        ismertetett kalkulációk alapján a szerzők szerint
                        10<superscript>9</superscript> tubulin 500 miliszekundumos
                        összefonódása kiválthatja az egy graviton határ elérését,
                        azaz az objektív redukció bekövetkeztét. Vagy ugyanígy
                        10<superscript>10</superscript> tubulin 50 miliszekundumos
                        összefonódása , s így tovább. Ugyancsak az említett cikkben hivatkozott
                        adatok szerint neurononként 10<superscript>7</superscript> 
                        tubulinnal számolva az objektív redukcióhoz így 
                        10<superscript>9</superscript> / 10<superscript>7</superscript> = 100
                        neuron szükséges, vagy ha a neuron tubulin állományának csupán
                        1 százalékával - mint a folyamatba bekapcsolódó tubulinokkal
                         számolunk, akkor 
                         10<superscript>9</superscript> / 10<superscript>5</superscript> = 10000
                        neuron fél másodperces összefonódása szükséges. 
                        Ezek alapján a tudat megjelenését Hameroff és Penrose az
                        <citation>ORCH OR TUDAT</citation> cikkben 
                        valahol a C. elegans környékén húzzák meg, mert 
                        ennek a fonalféregnek 302 neuronja van 
                        <citation>C. ELEGANS</citation>, akár már képes lehet az objektív redukció
                        futtatására. 
                        </para>
                        
                        <para>                        
                        Az alábbi szimuláció vagy pontosabban
                        csupán - az 
                        <citation>ORCH OR</citation>, 
                        <citation>ORCH OR TUDAT</citation>                        
                        cikkek képei 
                        alapján készített - demonstráció azt 
                        mutatja, hogy egyre több tubulin dimer kerül koherens
                        állapotba, míg az objektív redukció következtében egy
                        előre nem kiszámítható módon ugranak a résztvevő
                        cellák valamely lehetséges állapotukba, az ehhez az
                        állapothoz tartozó valószínűséggel. 
                        </para>
                                            
                        <example id="orch_or">
                            <title>Mikrotubulus sejtautomata szimuláció</title>

                            <para>
                                Ebben a pontban csupán a megfelelő szimulációs, vagy
                                inkább csak demonstrációs programunk által generált
                                néhány pillanatfelvétel képet mutatunk be, a 
                                program részletes feldolgozását a 
                                <emphasis><link linkend="biol_java">Biológiai témájú programok</link></emphasis>
                                című pontban adjuk meg. A programot az 
                                <citation>ORCH OR</citation> cikkben közölt képek
                                mintájára készítettük el. A képek azt mutatják, hogy a 
                                hexa rácson egyre több tubulin dimer kapcsolódik be
                                a közös kvantum szuperponált állapotba. Egészen addig, 
                                amíg a
                                bekapcsolódottak kvantum szuperponált állapotában
                                együtt élő konformációk tömegeloszlásainak különbsége
                                el nem ér egy határt, amikor is bekövetkezik az
                                állapot redukciója, azaz a hexa rács rácspontjai
                                megint egy meghatározott állapotba kerülnek és indul a
                                sejtautomata klasszikus üzeme, s így tovább.
                                
                            </para>
                            
                            <para>
                                                                
                            <table frame="all">
                                <title>Mikrotubulus sejtautomata szimuláció.</title>
                                <tgroup cols="2">
                                    <tbody>
                                        <row>
                                            <entry>
                                                <para>

                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus1.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                            <entry>
                                                <para>

                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus2.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>

                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus3.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                            <entry>
                                                <para>

                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus4.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>

                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus5.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                            <entry>
                                                <para>

                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus6.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>

                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus7.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                            <entry>
                                                <para>

                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus8.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                A bekapcsolódottak kvantum szuperponált állapotában
                                                együtt élő konformációk tömegeloszlásainak különbsége
                                                elérte az egy graviton szintet.                                       
                                                </para>
                                                <para>

                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus9.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                            <entry>
                                                <para>                                                    
                                                Bekövetkezett az
                                                állapot redukció.                                                                  
                                                </para>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/mikrotubulus/mikrotubulus10.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>Mikrotubulus automata szimuláció pillanatfelvétele.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       

                                                </para>
                                            </entry>
                                        </row>
                                        
                                    </tbody>
                                </tgroup>
                            </table>
                        
                            </para>
                            
                                
                        </example>
                        
                    </sect5>
                    
                </sect4>
                
                <sect4>
                    <title>Kvantum számítások</title>
                                    
                        <blockquote>
                            <attribution>Enrico Fermi</attribution>
                            <para>
                                „Hol van mindenki?”
                            </para>
                        </blockquote>
                        
                        <para>
                        Terjedelmi okokból a kézikönyvben ezt a témát nem
                        bontjuk ki, de fontossága miatt adunk egy rövid
                        irodalmi útmutatást. 
                        </para>
							                        
                        <para>
                        A kvantum számítógép elképzelést bevető alapcikk
                        David Deutsch 1985-ben megjelent 
                        <citation>DEUTSCH KVANTUMGÉP CIKK</citation> cikke.
                        Mára a téma igen
                        kiterjedt. A jelenlegi matematikai háttér megértéséhez elegendő
                        a Hilbert-terek ismerete, ami a mai legtöbb, nem ismeretterjesztő
                        könyv olvasásához is szükséges. (Itt érdekességként jegyezhetjük meg,
                        hogy a kvantummechanika matematikai alapjait éppen Neumann
                        János fogta egybe precíz matematikai szigorral a
                        <citation>NEUMANN KVANTUM KÖNYV</citation> könyvében. Sajnos
                        a programozók reguláris képzése nem vértezi fel a hallgatókat
                        azokkal a matematikai ismeretekkel, amik e könyv élvezéséhez
                        szükségesek lennének.)   
                        </para>
                                                
                        <para>                        
                        A kvantum számítási téma megismerésére a 
                        Debreceni Egyetem Elméleti Fizika Tanszék vezetőjének tollából
                        származó
                        <citation>KVANTUMINFORMATIKA</citation> jegyzetet
                        ajánljuk. 
                        </para>
                                                
                        <para>                                                
                        A programozó Olvasóknak a 
                        <citation>PROGRAMOZÓ PÁTERNOSZTER JEGYZET</citation>
                        jegyzetet ajánljuk, ahol két rés kísérlettől indulva említjük
                        a fontos kísérleti mérföldköveket és részletesen bemutatjuk
                        a legfontosabb kvantum algoritmusokat. 
                        </para>
                        
						<sect5>
							<title>Pesszimista programozó optimista gondolata</title>
							
                        <para>
                        Futurisztikus fejezetünk lezárásaként játsszunk el a korábbi, mottóként idézet 
                        Vassy gondolat 
                        <citation>VASSY JEGYZET</citation>
                        és Neumann utolsó munkájának utolsó oldalain
                        megjelenő gondolat 
						<citation>GÉP és AGY</citation>	
                        összefésülésével! Az első így hangzott
                        
                        <blockquote>
                            <attribution>Vassy Zoltán</attribution>
                            <para>
                                „Így bármilyen furcsán hangzik, logikailag 
                                lehetséges, hogy magában az objektív világban a 
                                fizikai mennyiségeknek soha nincs egy-egy jól 
                                definiált értékük; csak egy-egy eloszlásuk van, 
                                amelyben a lehetséges értékek egyidejűleg léteznek. 
                                A tudat működik úgy, hogy ezekből az eloszlásokból 
                                konkrét értékeket csinál.”
                            </para>
                        </blockquote>
                        
						a második pedig a következő                        
                        
                        <blockquote>
                            <attribution>Neumann János</attribution>
                            <para>
                                „Szembe kell néznünk azzal, hogy a nyelv messzemenően történelmi esetlegességet alkot.
                                Az alapvető emberi nyelvek különböző formái hagyományszerűen jutottak el hozzánk, de már e hagyományos
                                formák sokfélesége is bizonyítja, hogy semmiféle feltétlenség vagy szükségszerűség nem testesül meg bennük.
                                S mint ahogy a görög vagy a szanszkrit nyelv létezése történeti tény, nem pedig feltétlen logikai szükségszerűség,
                                ugyanúgy józanul feltételezhetjük, hogy a logika és a matematika is történeti eredetű és esetleges kifejezési
                                formák. Lehetnek a logikának és a matematikának lényegesen eltérő változatai is - mindkettő más alakban  is 
                                létezhetik, mint amit megszoktunk!
                                ”
                            </para>
                        </blockquote>
                        
                        Honnan a pesszimizmus?
                        Mert, ha a tudatunk is csupán történeti esetlegesség, akkor Fermi kérdésére a válasz, hogy 
                        sehová nem tűntek, mert számunkra - abban az értelemben, melyben a kérdés fel lett téve - nem is léteznek!
                        Tehát elvben jóval könnyebb lenne olyan fordítóprogramot
                        írni, ami a delfin-ember vagy a fonalféreg-ember kommunikációt teszi lehetővé, semmint a 
						„zöld fickók” - ember fordítót. Ha ez a pesszimista helyzet állna fent, 
						akkor csak abban bízhatunk, hogy a kvantuminformatikus programozók majd kifejlesztik a megfelelő fordítót! 
						De addig is a mi életünk csíráit küldenénk ki a világegyetembe, hogy idővel majd találkozhassunk
						olyanokkal, akikkel kölcsönösen létezünk egymás számára.
                        </para>
							
						</sect5>
                                                    
                </sect4>

                <sect4>
                    <title>Visszabeszélő gépek</title>

                        <para>
							Még a tanár-diák kontextusban kezdődött el a következő, idézett kérdés a kézikönyv 
							szerzőpárosa között.
							<emphasis>„Miért lenne az jó, ha az asztalon lévő gép visszaszólna?”</emphasis>
							Adekvát válasz még ma sincs, hanem csak ebbe tudományos fantasztikus ihletésű részben merjük beírni, hogy 
							<emphasis>„Mert az intelligens gépek azt is el tudják majd képzelni, amit mi emberek már nem.”</emphasis>							
                        </para>

                </sect4>
                    
            </sect3>
        </sect2>

        <sect2 id="OO_vilag">
            <title>Az OO világ, a programozó szűkebb hazája</title>

            <blockquote>
                <attribution>Kernighan-Plauger
                    <citetitle>A programozás magasiskolája</citetitle>
                </attribution>
                <para>
                    „Több erőfeszítést fektetünk a tervezésbe és kódolásba 
                    (ami szórakozás), hogy csökkentsük a jóval költségesebb
                    tesztelést és hibajavítást (ami nem az).”
                </para>
            </blockquote>
                        
            <para>Ha futása közben - egy koncepcionálisan elég magas nézőpontból - rápillantunk egy OO programra, akkor egymással kölcsönható, együttműködő objektumokat látunk. Amit a nyolcvanas, kilencvenes évek tipikus imperatív programozója gondolt egy egész programja futásáról: szépen szekvenciálisan megy a végrehajtás, jön egy szelekció, 
            azon az ágon megyünk tovább... igen, itt akkor következik egy iteráció... átkerült az objektumokba. Ezért OO programra az esetleges jól olvasható jelző helyett szerencsésebb, találóbb lehet az érthető világ, jól megérthető világ leírás jellemzés. Mert az OO programozó építette osztályoknak arra a kihívásra kell válaszolniuk, hogy modellezni tudják-e a programozó előtt álló feladat világát? Ha igen, akkor a feladat sikeres megoldása annyit tesz, hogy a modellezett világban megnézzük a választ a kérdéseinkre és a válaszokat a valóságos világbeli válaszoknak tekintjük. </para>
            <para>Például ha a következő ábrán bepillantunk az Órarend programba, 
            akkor az azt mondja, hogy Bátfai Norbert Linuxot és Operációs rendszereket fog
            tanítani. Illetve ugyanez a valóságban: a közelgő félév elején BN megnézi majd 
            ennek a programnak a grafikus felületét és onnan tudni fogja, hogy talán már 
            éppen másnap hányra és melyik terembe kell mennie megtartani melyik kedvenc óráját. 
            
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/prog/orarend.png" />
                    </imageobject>
                    <textobject>
                        <phrase>Az órarend program elképzelése.</phrase>
                    </textobject>	
                </inlinemediaobject>                                                            
            
            </para>
            
            <para>Az OO programozó tehát osztályokat épít, olyan osztályokat, amik lehetőség szerint jól modellezik a megoldandó feladat világát. Ennek során a programozó tipikusan felhasznál már rendelkezésre álló osztályokat. Az osztályoknak azt a körét, amik minden ilyen építkezésnél alapvető fontosságúak, illetve adott részirányokban (ilyen részirány lehet  -  csak néhány példát megemlítve  -  a mobil, az adatbázis, a hálózati, az elosztott, a konkurens, a web programozás) alapvető fontosságúak lehetnek, Alkalmazói Programozói Interfésznek, röviden API-nak nevezzük. Így nem meglepő, hogy pusztán az OO nyelv ismerete az API nélkül mit sem ér! </para>
            <para>Mint az ember minden bonyolult dolgot, az API-t is hierarchiába szervezi, esetünkben ez a hierarchia egy fa szerkezet, aminek gyökere a Java. A fa leveleit nem tartalmazó utakat csomagnak is nevezik, a következő ábra alapján például a <classname>java.lang</classname> egy csomag. A <classname>java.lang</classname> csomag azokat az osztályokat tartalmazza amik a nyelv szempontjából alapvetők. A <classname>String</classname> osztálybeli objektumok karakterláncokat reprezentálnak, ezek fontosságát a programozásban nem kell tovább ecsetelnünk, mint ahogyan a számok fontosságát sem: az <classname>Integer</classname> osztály példányai például az egész számokat reprezentálják. 
            Kevésbé egyértelmű az <classname>Object</classname> 
            osztály, pedig  -  ahogyan majd hamarosan látjuk  -  ő a legfontosabb, ő az osztályhierarchia gyökere, azaz minden Java osztály őse... 
            De ne aggódjon a kedves Olvasó, az API-t még véletlenül sem kell megtanulni, hanem csak nézegetése közben hozzászokni, mert természetesen a platform azért platform, hogy biztosítson olyan eszközöket, amik lehetővé teszik, illetve segítik a fejlesztést, esetünkben bemutatják az API hierarchiát. 
            De távolodjunk el pár bevezető sor erejéig most a fáktól és nézzük az erdőt. 
            A fákhoz majd a következő néhány pont után, a
<emphasis><link linkend="se_oo">Java SE OO világ</link></emphasis>            
            című pontban térünk vissza.

                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/prog/api1.png" />
                    </imageobject>
                    <textobject>
                        <phrase>Részlet az API hierarchia fa szerkezetbe szervezéséből.</phrase>
                    </textobject>	
                </inlinemediaobject>                                                            
            
            </para>

            <sect3 id="java_platform">
                <title>A Java platform</title>
                
                <orderedlist>
                    <listitem>
                        <para>Mit gondol a kedves Olvasó, találkozott már valaha a Javával?</para>
                    </listitem>
                    <listitem>
                        <para>Van mobilja? </para>
                    </listitem>
                    <listitem>
                        <para>Igen, akkor az első kérdésre a válasz: biztosan! 
                        Hogy miért? Mert a telefonja nagy valószínűséggel Java képes
                        készülék.</para>
                         
                    </listitem>
                </orderedlist>

                <para>Mi tehát a Java? A válasz attól függ, ki kérdezi. Mert mondjuk a földrajzosoknak lehet egy sziget az Indiai-óceánon. A programozóknak lehet egy modern programozási nyelv, megélhetés vagy szerelem... Az általában vett mobil tulajdonosnak, azaz most nekünk, egy program a telefonon: egy számítógépes program. Ha eddig nem tekintettük számítógépnek is a mobilunkat, akkor kezdjünk barátkozni ezzel a gondolattal, mert bár nem olyan erős sebességben, a kijelzője méretében vagy mondjuk memóriakapacitásában, mint az asztalainkon használt, mára már jól megszokott személyi számítógépeink, de mégiscsak, számunkra most számítógép. </para>
                <para>Visszatérve a Javahoz, ennek a programnak az a feladata, hogy más, éppen Java nyelven megírt programokat futtasson, ezért is nevezik egyszerűen csak Java Virtuális Gépnek, vagy röviden JVM-nek ezt a futtató programot. Tehát, ha például egy telefon javas, akkor az annyit tesz, hogy rajta van a Java VM program. </para>
                <para>Jogos a kérdés, miért hasznos ez nekem mint mobiltelefontulajdonosnak? Mert a JVM elrejti a mobiltelefonok sokféleségét azzal, hogy a fejlesztőknek elég a JVM-re megírni a programjaikat, azok pedig automatikusan működni fognak minden JVM-el rendelkező, azaz Java képes mobilon is! Tehát végső soron én mint mobil tulajdonos elvben több programhoz juthatok hozzá, többhöz, jobbhoz, gyorsabban, olcsóbban. Összefoglalva, a Java erejét a mobiltelefonok világában (azon túl, hogy a Java az Java :) az adja, hogy az elkészített programom elvben automatikusan minden Java képes eszközön működni fog. Ezt a tulajdonságot nevezzük platformfüggetlenségnek: a Java programom futni fog mindenféle javas mobiltelefonon: Motorolán, Nokián, Sony Ericssonon... vagyis minden olyan telefonon, amin rajta van a Java VM!</para>
                <para>A mobilokról általánosítva a személyi számítógépekre, a szerver számítógépre, az egész internetre ugyanez adja a Java erejét: a programozó egy nyelvet megtanulva, egy nyelvet használva tudja a legkülönfélébb programozható eszközöket, például mobilokat, személyi számítógépeket, szervereket kezelni, anélkül, hogy magukkal ezekkel a különböző hardver eszközökkel, vagy az eszközökön található szoftveres erőforrásokkal, például a futó operációs rendszerekkel: Linux-szal, Windows-zal vagy Solarisszal foglalkoznia kéne.
                
                    <inlinemediaobject id="magasabb_absztrakcio">
                        <imageobject>
                            <imagedata fileref="images/prog/platform1.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Java platform.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                                            
                
                </para>
                
                <para>Az ábra beszédes, de hogy pontos is legyen, még finomítanunk kell: a Java Virtuális Gépek bemenete nem közvetlenül az emberi fogyasztásra alkalmas Java forrásszöveg, hanem egy olyan köztes forma, amit egy fordítóprogrammal, 
                a <application>javac</application> nevű Java fordítóprogrammal készítünk el. Ez már nem emberi fogyasztásra alkalmas, szöveges állomány, hanem bináris. Ez a virtuális gépek bemenete, ez az a hordozható forma, amit a Java Virtuális Gépek értelmeznek. Egészen konkrétan, ha készítek egy ilyen, mondjuk Java SE platformbeli osztályt (programot) Linux alatt, 
                amit most nevezzünk <filename>Osztály.class</filename> osztálynak, 
                akkor egyszerűen egy Windows rendszerű gépre átmásolva, ott átadva az ottani Java Virtuális Gépnek, 
                azaz például a megfelelő parancssorba beírva a
                <computeroutput>java Osztály</computeroutput> parancsot, 
                futni fog a programom. 
                A Java telepítés és futtatás kapcsán lásd még 
                <emphasis><link linkend="telepites">A Java telepítése gépünkre</link></emphasis>
                 és 
                <emphasis><link linkend="pelda_futtatas">A példaprogramok futtatása</link></emphasis>
                című pontokat!
                </para>
					<para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/prog/platform2.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Java Virtuális Gép bemenete a Java bájtkód.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                                            
                
                </para>
                <sect4 id="elso_java_ford">
                    <title>Az első Java osztály lefordítása</title>

                    <para>
                        Függessze most fel a kedves Olvasó az olvasást és
                        fordítsa, majd futtassa le első Java programját. 
                        Ehhez először persze gépünkre installálnunk kell
                        a megfelelő fejlesztői környezetet. Ezt sikeresen
                        megtehetjük 
                        <emphasis><link linkend="telepites">A Java telepítése gépünkre</link></emphasis> 
                        és 
                        <emphasis><link linkend="pelda_futtatas">A példaprogramok futtatása</link></emphasis>
                        című pontok alapján, tegyük hát most meg!                        
                    </para>    
                    <para>                        
                        A kézikönyv 
                        eddigi olvasása során már sok Java nyelvű forrás programot
                        láttunk, bármelyikkel megpróbálkozhatunk most, mint
                        első fordításunkkal, futtatásunkkal. De mi az alábbi, 
                        a Fibonacci sorozat (amelyben a sorozat adott tagja az őt
                        megelőző két tag összege) tagjait kiszámító
                        program fordítását javasoljuk.
                        </para>
                        <para>
                            A program kódjára magára egyelőre csak egy pillantást
                            vessünk, mert fő feladatunk most a fordítás,
                            futtatás folyamat technikai bemutatása.

                            <programlisting>                                
                                <![CDATA[
public class Fibonacci {
    
    int előző;
    int aztMegelőző;
    
    public Fibonacci() {
        
        előző = 1;
        aztMegelőző = 1;
        
    }
    
    public int következő() {
        
        int vissza = előző + aztMegelőző;
        
        aztMegelőző = előző;
        előző = vissza;
        
        return előző;
    }
    
    public static void main(String[] args) {
        
        Fibonacci finobacci = new Fibonacci();
        
        for(int i=0; i<10; ++i) {
            System.out.print(finobacci.következő());
            System.out.print(" ");
        }
    }    
}
                                ]]>
                            </programlisting>

                            Vágjuk ki a fenti kódot, majd illesszük be
                            a <filename>Fibonacci.java</filename> nevű
                            állományba. Végül fordítsuk, majd futtassuk az
                            alábbiak szerint, például Linux alatt így:

                            <screen>
                                <![CDATA[
[norbi@niobe ~]$ javac Fibonacci.java
[norbi@niobe ~]$ java Fibonacci
2 3 5 8 13 21 34 55 89 144                                 
                                ]]>
                            </screen>                                                         
                        
                        </para>
                    
                    <sect5 id="bitfarago_feladat">
                        <title>Bitfaragó feladat</title>

                        <para>
                            Milyen 
                            bitmintával kezdődnek a Java bájtkódok, azaz a 
                            <application>javac</application> nevű Java fordító generálta 
                            <filename>.class</filename> kiterjesztésű állományok? Ha a választ hexában nem találjuk kapcsolatosnak a Java gőzölgő kávéscsésze logójával, akkor még dolgozzunk rajta! 
                            Nézzük meg például az imént elkészített <filename>Fibonacci.class</filename>
                            állományt!
                        </para>
                        
                        <tip>
                            <para>
                                Ha már nagyobb gyakorlattal rendelkezünk, akkor a 
                                <link linkend="feladat_01">0,1 feladat</link> feladata is segíthet.
                            </para>
                        </tip>

                        <example>
                            <title>Java disassembler</title>
                            <para>
                                Az előző feladatot nyilvánvalóan azonnal megoldotta az a
                                kedves Olvasó,
                                aki megnézte hexadecimálisban a
                                <filename>Fibonacci.class</filename> állományt. A Java
                                fejlesztői környezet egyébként ad kényelmesebb
                                eszközt, hogy a bájtkódot nézegessük. Bár erre az
                                eszközre az átlagos Java fejlesztőnek valószínűleg nem
                                lesz szüksége, de megemlíteni mindenképpen érdekes.
                                Ez a program a <command>javap</command>, feladata
                                a bájtkódból az assembly nyelvek tokenjeihez
                                hasonló kimenetet előállítani. A 
                                <parameter class="command">-c</parameter> kapcsolóval
                                indítva bemenetként a <filename>Fibonacci.class</filename>
                                bájtkódot átadva beszédesen mutatja be a Java bájtkódot.
                                <screen>
                                    <![CDATA[
[norbi@niobe ~]$ javap -c  Fibonacci
Compiled from "Fibonacci.java"
public class Fibonacci extends java.lang.Object{
int előző;

int aztMegelőző;

public Fibonacci();
  Code:
.
.
.
public int következő();
  Code:
   0:   aload_0
   1:   getfield        #2; //Field előző:I
   4:   aload_0
   5:   getfield        #3; //Field aztMegelőző:I
   8:   iadd
   9:   istore_1
   10:  aload_0
   11:  aload_0
   12:  getfield        #2; //Field előző:I
   15:  putfield        #3; //Field aztMegelőző:I
   18:  aload_0
   19:  iload_1
   20:  putfield        #2; //Field előző:I
   23:  aload_0
   24:  getfield        #2; //Field előző:I
   27:  ireturn

public static void main(java.lang.String[]);
  Code:
.
.
.
                                    ]]>
                                </screen>                                                         
                                Csupán a <function>következő()</function>
                                függvény bájtkódját emeltük ki a <command>javap</command>
                                által készített kimenetből. Ami bár emberi fogyasztásra
                                nem oly alkalmas, mint <function>következő()</function>
                                metódus Java forráskódja, de azért próbáljuk összevetni
                                a kettőt!                                                                
                            </para>    
                        </example>
                                                    
                    </sect5>
                    </sect4>
                    
                    <sect4>
                        <title />
                        
                        <tip>
                            <title>Futtatható megjegyzés</title>
                            
                        <para>
                            Bár nem javasoljuk, de lehetőség van a Java forrásból 
                            futtatható állomány létrehozására is, az ez iránt 
                            érdeklődőknek a <citation>PROGRAMOZÓ PÁTERNOSZTER JEGYZET</citation>
                            jegyzetre hívjuk fel a 
                            figyelmét, ahol Linux alatt a 
                            <application>GNU gcc</application> 
                            fordító 
                            használatával mutatunk erre példákat. Miért nem 
                            javasoljuk? Első ok, hogy így elveszítjük a 
                            hordozhatóságot, a második, hogy ezt a tettet 
                            általában a sebesség kérdésben sem tartjuk indokoltnak. 
                            A sebesség kapcsán érdekes lenne írni valamilyen 
                            benchmark programot, hogy magunk is meggyőződjünk 
                            erről. Írjunk is! 
                            <emphasis><link linkend="pi_jegyei">A Pi jegyeinek nyomában</link></emphasis>
                            című pont BBP algoritmust megvalósító 
                            <classname>PiBBP</classname> osztályunkat átírtuk
                            objektumorientált<emphasis>talanná</emphasis>, azaz 
                            gyakorlatilag nem készítettünk benne objektumokat, hanem
                            csak egy statikus <function>main()</function> függvényt
                            használtunk, illetve az algoritmust átírtuk C nyelvre is.
                            Ekkor az alábbi futási eredményeket kaptuk az alábbi 
                            egyszerű mérésekkel Javaban
                            
                            <programlisting>
                            <![CDATA[
long delta = System.currentTimeMillis();

/* SZÁMÍTÁS */

delta = System.currentTimeMillis() - delta;
System.out.println(delta/1000);            
        ]]>
                            </programlisting>
                            
                            illetve C-ben
                            
                            <programlisting>
                            <![CDATA[
clock_t delta = clock();
        
/* SZÁMÍTÁS */
        
delta = clock() - delta;
printf("delta: %f\n", (double)delta/CLOCKS_PER_SEC);                             
                            ]]>
                            </programlisting>
                            
                            a Pi hexadecimális kifejtésének 
                            (0. pozíciótól számított) adott
                            poziciója hexa jegyének meghatározására egy
                            <productname>Fedora Linux Core 5</productname> operációs rendszerrel
                            felszerelt, <computeroutput>2.6.17.7</computeroutput>
                            verziójú kernellel ellátott
                            <hardware>Sun W1100Z Workstation</hardware> gépen
                            <computeroutput>gcc (GCC) 4.1.0 20060304 (Red Hat 4.1.0-3)</computeroutput>
                            verziójú 
                            <application>gcc</application> és 
                            <computeroutput>java version "1.6.0-beta2"</computeroutput>
                            verziójú <application>Java</application> mellett.
                            (A szóban forgó méréseket végző, említett 
                            teljes programokat, illetve néhány további összehasonlítást a melléklet
                            <emphasis><link linkend="sebesseg">Egyszerű összehasonlítások a sebesség kérdésében</link></emphasis>                                                    
                            című pontjában találhat az érdeklődő Olvasó.)
                            
                    <table frame="all"><title>Java és C egyszerű sebesség összehasonlítása</title>
                        <tgroup cols="4">
                            <thead>
                                <row>
                                    <entry>
                                        <para>Pozíció</para>
                                    </entry>
                                    <entry>
                                        <para>0xJegy</para>
                                    </entry>
                                    <entry>
                                        <para>C [sec]</para>
                                    </entry>
                                    <entry>
                                        <para>Java [sec]</para>
                                    </entry>
                                </row>                                
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                    <para>10<superscript>6</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>6</para>
                                    </entry>
                                    <entry>
                                        <para>4.39</para>
                                    </entry>
                                    <entry>
                                        <para>4.246</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para>10<superscript>7</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>7</para>
                                    </entry>
                                    <entry>
                                        <para>51.19</para>
                                    </entry>
                                    <entry>
                                        <para>49.465</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para>10<superscript>8</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>C</para>
                                    </entry>
                                    <entry>
                                        <para>586.0</para>
                                    </entry>
                                    <entry>
                                        <para>556.935</para>
                                    </entry>
                                </row>
                                </tbody></tgroup></table>
                                
                            </para>
                            
                            <!--
                            <para>                                
                            További olvasmányként a
                            HIÁNYZÓ_CIKK
                            cikket ajánljuk a Java sebesség 
                            témában: hogy nehogy ebben a kérdésben a Java forradalommal
                            szemben álló reakciós  -  <emphasis>&#x201E;nincs tapasztalatom, 
                            nem olvastam erről tudományos cikket, de szerintem lassú&#x201D;</emphasis>
                            - Általában csak a de-vel kezdődő gondolatot mondja ennek a tábornak a képviselője, de visszakérdezéskor kiderül, hogy a de előtti részek az igazak
                            - tábort erősítsék.                            
                            </para>
                            -->

                            <para>
                            Linux alatt a <command>gcc</command> fordító
                            használatával így készítünk futtatható állományt a 
                            fenti Fibonaccis programunkból:
                                <screen>
                                    <![CDATA[
[norbi@niobe ~]$ gcj -o fibonacci --main=Fibonacci Fibonacci.java
[norbi@niobe ~]$ ./fibonacci
2 3 5 8 13 21 34 55 89 144                                     
                                    ]]>
                                </screen>                                                         
                           Lássuk, hogy valóban futtatható állomány készült
                                <screen>
                                    <![CDATA[
[norbi@niobe ~]$ file fibonacci
fibonacci: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), 
for GNU/Linux 2.6.9, dynamically linked (uses shared libs), for GNU/Linux 2.6.9,
not stripped                                    
                                    ]]>
                                </screen>                              
                                
                                szemben a bájtkóddal:
                                <screen>
                                    <![CDATA[
[norbi@niobe ~]$ file Fibonacci.class
Fibonacci.class: compiled Java class data, version 50.0                                    
                                    ]]>
                                </screen>                              
                           
                            
                        </para>                        
                    </tip>
                    
                    </sect4>
                    
                    <sect4 id="tortenet">
                        <title>Történet és oktatás</title>
                        
                    <blockquote>
                        <attribution>Gábor Dénes</attribution>
                        <para>
                        „A jövőt nem lehet megjósolni. Azt föl kell találni.”</para>
                    </blockquote>

                    <para>Patrick Naughton, Mike Sheridian és James Gosling részvételével 1990 végén, 91 elején mindenféle potenciálisan új generációs informatikai termékek kifejleszthetőségének vizsgálatával indult meg egy technológia-intenzív csoport, a Green Team munkája. A háztartásokban található mindenféle különböző hardverű szórakoztató elektronika vezérlése, programozása akkor ilyennek tűnt. </para>
                    <para>Az időközben személyi állományban tucatnyira növő projekt 1992 szeptember harmadikán bemutatta az általuk kifejlesztett termék prototípusát a *7-et, azaz a Csillag7-re keresztelt 5 colos érintőképernyős, vezeték nélküli hálózati kapcsolattal ellátott PDA-t. A *7 feladata az volt, hogy vezérelni tudja az olyan szórakoztató elektronikát, ami érti, interpretálja az ehhez kifejlesztett új nyelvet, az 
                    Oakot. (Az Oak, Tölgy név eredete, hogy Gosling irodájának ablaka éppen egy ilyen fára nézett.)
                    </para>
                    
                    <para>A sikeres demó után a termék értékesítésére alakult a csoportból a FirstPerson, de a piac még nem állt készen. Végül az interpretált Oak nyelv, 1995-ben, már mint Java jelent meg, a korábban megcélzott piac helyére pedig a forradalomként terjedő internet került. A Java születési ideje: 1995. május 23, amikor a SunWorld konferencián John Gage, a Sun kutatási igazgatója hivatalosan bemutatta a Javát és az azt értő HotJava böngészőprogramot, továbbá a konferencián a Netscape bejelentette, hogy böngészőjében támogatni fogja a Javát. </para>
                    <para>Véleményünk szerint ez a szerencsés Java+internet összefonódás is szerepet játszott abban a folyamatban, ami a programozó közösség javát abba az irányba mozdította, hogy a Java nyelv átvegye az első számú általános programozási nyelv helyét az elméjében. Mert egy új programozási nyelv elsajátítása komoly mentális befektetést igényel, de az már egy egészen más dolog, ha ez a befektetés az új világhoz, azaz akkoriban az internet programozásának világához is megadja a kulcsot. Nem befolyásolja a homokvihart a porszem véleménye, 
                    de magunk annak szorítunk, hogy a Java nyelv napjaink római békéje legyen a programozásban.</para>
                    <para>Az oktatás területén  -  az elmúlt 15 évben  -  két birodalom tündöklését és bukását éltük
                    meg, a ma harmincas éveikben járó programozók még diákként a BASIC-ét, majd hallgatóként a PASCAL-ét. 
                    A hanyatlás oka magának a nyelvhez kapcsolódó kultúrának, magának a nyelvhez tartozó civilizációnak a hanyatlása. Mert csak az oktatás ezeket a mentális birodalmakat nem tarthatja fenn, mivel a tipikus tanuló a nyelvhez kapcsolható kultúrához, civilizációhoz kötődik és nem csupán a tiszta nyelvhez, gondolkodásmódhoz magához. Ezért az a meggyőződésünk, hogy amit az oktatási célokra szánt nyelvekkel alapelvekben meg lehet tanítani, azt már korábban, a 10 éves kor környékén meg lehetne és meg kell majd tanítani mondjuk a 
                    LEGO <trademark>Mindstorms</trademark> robotos eszközök segítségével. Mert ez a robotos készlet az életkorban ide kapcsolható játékkultúrához, gyermeki  - építő játék -  civilizációhoz kapcsolódik, s ennek a civilizációnak a fennmaradása hosszabb távon is bíztató.</para>
                    <para>A LEGO Mindstorms Robotics Invention System csomag 1998-ban jelent meg. 
                    Ez alapvetően egy több száz alkatrészből álló LEGO csomag, de több speciális téglát is 
                    tartalmaz. Legfontosabb ilyen a processzort is tartalmazó tégla, 
                    de vannak motorokat tartalmazó, nyomás és fény érzékelésére alkalmas téglák is a csomagban. 
                    </para>
                    
                    <para>
                        <inlinemediaobject>
                            <objectinfo>
                            <title>RobIGOR, a II. Jávácska konferencia 
                            <citation>II. JÁVÁCSKA</citation> kabala LEGO robotja.</title>
                            </objectinfo>                            
                            <imageobject>
                                <imagedata fileref="images/kep/robigor.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A II. Jávácska konferencia kabala LEGO robotja.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                    </para>

                    <para>
                    A robot a szokásos építkező játékkal készíthető el, például 
                    az iménti ábra a 
                    RobIGOR névre keresztelt, a II. Jávácska konferencia 
                    <citation>II. JÁVÁCSKA</citation> kabala LEGO robotját mutatja.
                    Az robot megépítését egy PC-n történő programozási rész 
                    követi. A programot grafikus környezetben készíthetik el a gyerekek, majd infra kapcsolaton, illetve az új csomagban már Bluetooth kapcsolaton vagy USB kábelen keresztül küldhetik át a robotra, hogy aztán azon futtathassák. A csomag 
                    új generációs változata, a LEGO Mindstorms NXT <citation>LEGO MINDSTORMS</citation>, 2006 elejétől elérhető.
                    </para>
                    
                    <para>De visszatérve a Java történelemhez, az időtengely 
                    a másik irányban érdekesebb: a közeli múlt (2004 vége, 2005 eleje) a 
                    Java 5, a Tiger. A jelen (2006 nyara) a Java 6, a Mustang. 
                    A közeli jövő (2008 második fele) a Java 7, a Dolphin. 
                    Az appendix 
                    <emphasis><link linkend="tortenet_elore">A Java verziók újdonságai</link></emphasis>
                    című pontjában bontunk ki majd
                    néhány szívdobogtató finomságot, amiket majd rögtön alkalmazunk
                    is labirintus példáinkra.</para>

					<!-- Tigris, Musztáng, Delfin pár sorok is az appendixbe -->

                    </sect4>
                    
                    <sect4 id="java_OO">
                        <title>A Java OO világ</title>
                        
                    <para>Már bevezettük: a Java OO világ térképe az API 
                    dokumentáció, az osztályok részletes leírásának egy 
                    fa szerkezetbe rendezett rendszere. Érdekessége, hogy a 
                    programozás során a programozó által a forrásszövegbe 
                    illesztett dokumentációs megjegyzésekből áll össze 
                    böngészhető HTML formátumban. A dokumentációs 
                    megjegyzéseket a <computeroutput>/**</computeroutput>
                    karakterek kezdte és a <computeroutput>*/</computeroutput>
                    befejezte 
                    részben kell elhelyezni, amiként a következő példa 
                    is mutatja, hogy hogyan kommentezzük be egy osztályunkat, 
                    az osztály példányváltozóit és a függvényeket. 
                    Ha a program fejlesztése, írása közben a dokumentálást 
                    nem hanyagoljuk el, akkor amikorra a programunk kész, 
                    akkorra egy jól használható dokumentáció is kész.</para>

                            <programlisting>
                            <![CDATA[
/**
 * A labirintus kincseit jellemző osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.1
 * @see javattanitok.labirintus.Labirintus
 */
public class Kincs extends Szereplő {
    /** A kincs értéke. */
    protected int érték;
    /** Megtaláltak már? */
    protected boolean megtalálva;
    /**
     * Létrehoz egy {@code Kincs} objektumot.
     *
     * @param   labirintus  amibe a kincset helyezzük.
     * @param   érték       a kincs értéke.
     */
    public Kincs(Labirintus labirintus, int érték) {
        super(labirintus);
        this.érték = érték;
    }
                            ]]>
                            </programlisting>

                    <para>A forrásokból Java platform 
                    <application>javadoc</application> nevű programja készíti el
                    a böngészhető dokumentációt a fejlesztett programunkról, de
                    természetesen a <application>NetBeans</application>-ben is kattinthatunk a: 
                    <guimenuitem>Bulid/Generate Javadoc for...</guimenuitem> menüpontra. 
					A <application>NetBeans</application> kapcsán lásd még a 
                    <emphasis><link linkend="netbeans">A NetBeans integrált fejlesztői környezet használata</link></emphasis>
                    című pontot!</para>

                    <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/kep/labirintus_api1.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A labirintus API dokumantáció megtekintése.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        
                        A bal felső keretben az osztályokat találjuk, ha kattintással kiválasztunk
                        egyet, akkor ennek a csomagnak az osztályai, interfészei, kivételei a bal
                        alsó keretben bontódnak ki. Ha itt megintcsak kiválasztunk egy tételt, esetünkben
                        például a <classname>Hős</classname> osztályt, akkor annak részleteit a fő frame-ben ismehetjük meg.
                    </para>

                    <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/kep/labirintus_api2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A Hős osztály a labirintus API dokumantációban.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                    </para>
                    
                    <para>De a Java dokumentáció erejét a következő pontban csodálhatjuk meg igazán.</para>
                    
                    </sect4>
                    
                    <sect4 id="se_oo">
                        <title>Java SE OO világ</title>
                        
                    <para>Akkor hát csodáljuk: a <ulink url="http://java.sun.com/">http://java.sun.com</ulink> 
                    szájtról letölthető Java SE fejlesztői csomag, teljes nevén a Java Platform, 
                    Standard Edition 6 Development Kit, JDK 6  -  most a 6-os verziónál tartunk, 
                    mindig figyeljünk, hogy a legújabbat használjuk! Immár két éves az 5-ös Java, a Tigris, 
                    most aktuális Java a 6-os, a Musztáng, de már várjuk a 7-es Javát, a Delfint.
                    A letöltéssel és a telepítéssel kapcsolatos  
                    további részletek tekintetében lásd 
                     <emphasis><link linkend="telepites">A Java telepítése gépünkre</link></emphasis>
                    című pontot!
                    </para>
                    <para>Visszatérve a csodáláshoz: a sikeres telepítés után a JDK könyvtárában találhatjuk 
                    az <filename>src.zip</filename> nevű állományt, amiben megtaláljuk a Java SE OO világ (azaz a Java SE API) összes osztályának 
                    forráskódját. Ha nem csupán a JDK-t töltöttük le, hanem a mellette felkínált 
                    dokumentációt is, akkor láthatjuk, hogy ez a dokumentáció éppen ezekből a 
                    forrásokból készült, főleg az imént bemutatott dokumentációs megjegyzések 
                    felhasználásával. (Azért érdemes a JDK mellől rögtön letölteni a dokumentációt is, 
                    mert így biztosan a megfelelő verziót használjuk majd, a letöltés tekintetében 
                    lásd a  
                    <emphasis><link linkend="api_doksi">A Java dokumentáció, azaz az API doksi letöltése</link></emphasis>
                     című pontot!)</para>
                     
                    <sect5>
                        <title>System.out feladat</title>
                        
                        <para>Nézzük meg, hogy milyen osztálybeli objektum a 
                        <classname>System</classname> osztályban lévő 
                        <computeroutput>out</computeroutput> tag! 
                        A választ az imént említett <filename>src.zip</filename>
                        <filename>java/lang/System.java</filename> forrásában 
                        találjuk. Ha megvan, majd nézzük meg az API doksiban, 
                        azaz szintén az imént említett, a JDK mellől letölthető
                        dokumentációt is: a bal felső frame-ben 
                        <classname>java.lang</classname> csomagra 
                        kattintás után a bal alsóban Classes-ok alól a <classname>System</classname> osztályra
                        kattintva a jobb oldali fő frame-ben már megtaláljuk. Ez utóbbit azért egy képen is megmutatjuk: </para>

                        <para>
                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/prog/api2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Sematikus részlet az Java SE API hierarcia fa szerkezetbe szervezéséből.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        </para>
                        <para>
                        A Java SE API már hatalmas, 
                        ezért itt nem is teszünk mást, csak néhány olyan csomagjáról szólunk pár szót, amelyet a későbbi példáink során mi magunk is használni fogunk. </para>
                        <para>Már tárgyaltuk, hogy az ember mint minden bonyolult dolgot, az API-t is hierarchiába szervezi. Megnéztük, hogy esetünkben ez a hierarchia a fa szerkezet, aminek gyökere a java. A fában található, a gyökérből kiinduló utak pedig a csomagok.</para>
                        <para>A <classname>java.lang</classname> csomag tartalmazza az <classname>Object</classname>
                        osztályt, ez az osztály az öröklődés alapján tekintett 
                        osztályhierarchia gyökere, avagy minden Java
                        osztálynak ez az ős osztálya: apja, nagyapja,
                        dédnagyapja, üknagyapja stb. Így minden osztály 
                        örökli például a <function>getClass()</function> metódusát. 
                        A <function>getClass()</function>
                        metódus megmondja az objektumról, hogy mely osztálybeli. 
                        (A részleteket gyakorlásképpen nézze meg a kedves Olvasó az API doksiban!) 
                        Lássunk egy példát a metódus használatára:

                            <programlisting>
                            <![CDATA[
Labirintus labirintus = new Labirintus(6, 3);
Hős hős = new Hős(labirintus);

System.out.println(labirintus.getClass());
System.out.println(hős.getClass());
                            ]]>
                            </programlisting>

                        A kódrészlet produkálta output:

                            <programlisting>
                            <![CDATA[
class javattanitok.labirintus.Labirintus
class javattanitok.labirintus.Hős
                            ]]>
                            </programlisting>
                        
                        </para>
                                                
                        <para>Magunk is próbálkozhatunk, a fenti kódrészletet a javattanitok.labirintus.Labirintus saját indító <function>main()</function> metódusában találjuk meg.</para>

                        </sect5>                        
                        </sect4>
                        
                        <sect4>
                            <title>Java ME OO világ</title>
                            
                    <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/kep/nokialabirintus.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A Labirintus MIDlet példa egy Nokia 6131 telefonon.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                    
                        Egy magára valamit is adó mobilt árusító üzletben vagy mobilos katalógusban ma már nem csupán azt láthatom a készülékek mellett, hogy Java képesek-e, hanem további lényeges finomságokat is, például MIDP 1.0-ás vagy MIDP 2.0-ás a kiszemelt készülék? Ha megkérdezzük, hogy ez a rövidítés mit jelent, akkor a választ az Java ME OO világban találjuk. Ebben a világban is minden objektum, így már nem lehet meglepő, hogy programjaink itt is objektumokból állnak. 
                    </para>
                    <para>Nézzük meg mobilunkon a jegyzetben fejlesztett labirintus programot: egy elegendően magas koncepcionális nézőpontból éppen egy vászon objektumot látunk. A vászon objektumok arra valók, hogy rajzolni tudjunk a mobilunk kijelzőjére, most éppen a labirintusunkat láthatjuk rajta. Ha például azt szeretnénk, hogy a szereplők, mondjuk a hős és a szörnyek valóságosabban mozogjanak, azaz lépkedjenek, akkor a vásznon további objektumokat, sprite objektumokat is kellene használnunk. A sprite objektumok arra valók, hogy mozgó dolgokat, például a szereplők animált mozgását készítsük el velük. A mozgások tipikusan animációkból állnak össze, azaz lerajzoljuk a lépéseket mondjuk 8 fázisban és minden egyes fázist tartalmazó kép a sprite animációjának egy frame-je lesz... egyelőre ne szaladjunk ennyire gyorsan! </para>
                    <para>Számtalan rendeltetésű objektumról beszélhetnénk még, de távolodjunk el a fáktól és nézzük az erdőt! A telefonokon rendelkezésre álló objektumok összességét szabványok foglalják össze, ilyen szabvány a MIDP is. A mobil téma gyors fejlődése persze magával hozza, hogy idővel egyre több objektum áll rendelkezésre, azaz mind több és több objektummal gazdagodik ez a világ. Például a sprite objektumok a MIDP 2-ben jelentek meg, a korábbi MIDP 1-ben még nem voltak, ekkor az animációkkal kapcsolatos apróságokat a programozónak magának kellett összerakosgatnia, azaz a kép helyére a megfelelő fázist tartalmazó frame-t kirajzolnia. </para>
                    <para>Minden objektumnak megvannak a saját belső tulajdonságai (tagjai, példányváltozói, attribútumai) és az ezekhez a tulajdonságokhoz tartozó saját viselkedési formái (függvényei, módszerei, metódusai, neki küldhető üzenetei). Az objektumok viselkedési formáikon keresztül tudják változtatni belső tulajdonságaikat (tehát változóik értékeit) és viszont: a belső tulajdonságok befolyásolják a viselkedést (metódusainak működését). </para>
                    <para>Például a mobiltelefonok Java Virtuális Gépében élni képes objektumok a <classname>MIDlet</classname> osztályból származó objektumok. A <classname>MIDlet</classname> objektumok rendelkeznek azokkal a tulajdonságokkal és viselkedési formákkal, amik lehetővé teszik, hogy a mobiltelefonok Java Virtuális Gépében élni, működni tudjanak. Ennek megfelelően, ha mobiltelefonos programot akarunk készíteni, azaz olyan osztályt, amelyből példányosított objektumom majd a mobilon futhat, akkor osztályunkkal ezt a <classname>MIDlet</classname> osztályt kell kiterjesztenünk, mert ekkor a saját osztályom is kész lesz arra, hogy ebben a speciális környezetben éljen. </para>
                    <para>Ugyanezt elmondhatnánk a <classname>javax.microedition.MIDlet</classname> osztály helyett </para>
                    <orderedlist numeration="lowerroman">
                        <listitem>
                            <para>a <classname>java.applet.Applet</classname> osztályt helyettesítve, ha ez a speciális környezet a webböngésző</para>
                        </listitem>
                        <listitem>
                            <para>a <classname>javax.servlet.http.HttpServlet</classname> osztályt helyettesítve, ha ez a speciális környezet a webszerver.</para>
                        </listitem>
                    </orderedlist>

                    <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/prog/api3.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Sematikus részlet az Java ME API hierarcia fa szerkezetbe szervezéséből.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        
                        A Java ME API, bár nagyságában korántsem olyan hatalmas, mint a Java SE API, de a MIDP 2 igen jelentős növekedést hozott, ezért itt sem teszünk mást, csak néhány olyan csomagjáról szólunk pár szót, amelyet a későbbi példáink során mi magunk is használni fogunk. A 
                        <classname>java</classname> alól nyíló csomagok: a 
                        <classname>java.lang</classname>, <classname>java.util</classname> és a 
                        <classname>java.io</classname> a Java SE-ből lettek leválogatva, tehát ezeknek a csomagoknak a tartalmát ugyanígy a Java SE API is tartalmazza. Erre utalva hagytuk meg a következő ábrán a korábbi hasonló ábra tetejét. A javax alól nyíló csomagok közül csak a <classname>javax.microedition.midlet</classname>, <classname>javax.microedition.lcdui</classname> csomagokat és a <classname>javax.microedition.lcdui.game</classname> alcsomagot tüntettük fel. 
                    </para>
                    
                    <sect5 id="midlet_feladat">
                        <title>MIDlet feladat</title>
                        
                        <para>Az API doksiban (telepítésével kapcsolatban lásd a  
                        <emphasis><link linkend="api_doksi">A Java dokumentáció, azaz az API doksi letöltése</link></emphasis>
                          című pontot) nézzük meg a <classname>javax.microedition.midlet</classname>
                          csomagban található <classname>MIDlet</classname> osztály <function>startApp()</function>,
                        <function>pauseApp()</function>, 
                        <function>destroyApp()</function>
                        módszereit! Milyen módosítókkal rendelkeznek?</para>
                        <para>Ezek a metódusok az absztrakt jelzővel vannak ellátva, 
                        ez azt jelenti, hogy ha ezt az osztályt kiterjesztjük, 
                        azaz valamely saját osztályunkat ebből örököltetjük, 
                        akkor ezeket a metódusokat mindenképpen, akár üres
                        törzzsel is, de felül kell definiálnunk. E három metódus a 
                        <classname>MIDlet</classname> osztály életciklus metódusai, velük vezérelhetjük,
                        segíthetjük a mobilos objektumunkat, hogy meg tudjon 
                        élni az idegen környezetben. Mely környezet abban 
                        az értelemben idegen, hogy fő célja nem biztos, hogy a 
                        mi alkalmazásunk futtatása, mert például programunkat bármikor 
                        félbeszakítathatja egy éppen bejövő hívás vagy SMS. 
                        Az alábbi, a <classname>javattanitok.LabirintusMIDlet</classname>
                         <classname>MIDlet</classname> osztályból kiragadott kódrészlet azt mutatja, hogy a <function>pauseApp()</function> módszert csupán üres testtel definiáltuk felül, ami azt is jelenti, hogy nem akarunk a programunkkal reagálni az előbb említett, de a mobil platformon természetesen szokásos eseményekre. A <function>startApp()</function> metódusban viszont dolgozunk, kitesszük a képernyőre labirintusunk már korábban elkészített vásznát.</para>

                        <programlisting>
                        <![CDATA[
public void startApp() {
    // A kijelzőn a labirintus vászon legyen látható
    kijelző.setCurrent(labirintusVászon);        
}
public void pauseApp() {
}
                        ]]>
                        </programlisting>

                        <para>A saját <classname>MIDlet</classname> (a <classname>MIDlet</classname> osztályból származó, azaz mondhatjuk, hogy <classname>MIDlet</classname>) osztályunk konstruktorának lefutása után hívódik meg a <function>startApp()</function> metódus, ezzel a <classname>MIDlet</classname> objektumunk aktív állapotba került. Ebből az állapotból időlegesen a <function>pauseApp()</function> módszer viheti ki, véglegesen pedig a <function>destroyApp()</function> módszer. Ennek megfelelően vegyük figyelembe, hogy a <function>startApp()</function> metódus <classname>MIDlet</classname> objektumunk (programunk) élete során többször is lefuthat. Ez konkrétan azt jelentheti  -  feltéve továbbá, hogy a labirintust és az azt kirajzoló vásznat a <function>startApp()</function> metódusban hoznánk létre  -  hogy a játékos már javában labirintusozik, amikor érkezik egy bejövő telefonhívás: meghívódik a <function>pauseApp()</function>, a játékos felveszi vagy sem, de amikor visszatér a játékhoz, akkor a <function>startApp()</function> metódus hívódik meg és feltételünk értelmében újra elkészíti a labirintust. Tehát a játékos a régi játékát gyakorlatilag elveszítette és egy új labirintussal újra kell kezdenie...</para>
                        <para>Az <classname>javax.microedition.lcdui</classname> csomag tartalmazza a GUI interfésszel kapcsolatos osztályokat, ezek a szokásosak: űrlapok, nyomógombok, szövegbeviteli mezők stb. A <classname>javax.microedition.lcdui.game</classname> alcsomag már kimondottan a játékfejlesztőket segíti. Többek között itt találhatjuk a <classname>Sprite</classname> osztályt is. A <classname>GameCanvas</classname> egy olyan vászon, amiben egyben a játék időfejlődését is meg tudjuk adni. A későbbiek során erre majd látjuk a példaprogramot: a <classname>LabirintusMIDlet</classname> és a <classname>LabirintusVaszon</classname> osztályainkat. </para>

                        </sect5>
                        </sect4>
                        </sect3>
                        
                        <sect3 id="corba_oo">
                            <title>Objektumok mindenütt: a CORBA OO világ</title>

                            <para>
                                A CORBA programozó a napjainkban
                                elérhető legmagasabb szoftveres absztrakciós 
                                szinten dolgozik. Számára az objektumok közötti
                                kapcsolattartás immár transzparens.
                                Ha a fejlesztő valamely CORBA objektum szolgáltatását
                                szeretné igénybe venni, azaz az objektum valamely
                                metódusát meghívni, akkor csupán a CORBA objektum
                                referenciáját kell megszereznie és innentől a 
                                megszokott módon a kívánt szolgáltatásnak megfelelő 
                                metódusát meghívnia. Megfordítva, ha a programozó egy
                                szolgáltatást kíván nyújtani, akkor elég csupán a 
                                szolgáltatásra magára koncentrálva megírnia a 
                                megfelelő CORBA objektumot. Mindkét esetben csakis
                                a szolgáltatásra kell koncentrálni, akár igénybe
                                venni, akár szolgáltatni akarjuk azt. Hogy az objektumok
                                fizikailag hol vannak, az nem lényeges.
                                Sőt még az sem lényeges, hogy ezeket a CORBA objektumokat
                                milyen programozási nyelven implementálja a fejlesztő.
                                Természetesen mi a legjobb választással élve, Java
                                nyelven valósítjuk majd meg a példaként szolgáló 
                                CORBA objektumainkat.                                                                
                            </para>
                                
                        <para>
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/prog/corba1.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Az elosztott labirintus CORBA objektumai.</phrase>
                                </textobject>	
                            </inlinemediaobject>
                        </para>
                            
                        <para>
                            Hogyan érjük el a szoftveres absztrakció ilyen magas fokát?
                            Úgy, hogy a CORBA világában szereplő objektumokat 
                            mindig egy interfészen, az objektum IDL 
                            (Interface Definition Language)interfészén
                            keresztül látjuk. 
                            Olyannyira mindig, hogy már magának 
                            a CORBA alapú
                            rendszernek a tervezésekor is ezekben az interfészekben
                            gondolkozunk. Mert a CORBA objektumoknak olyan
                            tulajdonságaik és viselkedéseik vannak, amiket
                            ezek az interfészek specifikálnak. Praktikusan egy CORBA
                            objektum ORB brókeren keresztül elérhető módszerei az
                            objektum IDL interfészében definiált módszerek.
                            További tárgyalásunkban a Java keretein belülre szorítkozva:
                            a Java platform biztosít olyan eszközöket - például
                            az <command>idlj</command> fordítót - amik az
                            IDL interfész definíciókat Java nyelvre fordítják. 
                            Ezután nincs más dolgunk, mint az IDL interfészben
                            megnevezett metódusok - esetünkben Java nyelvi -
                            megvalósítása.                            
                        </para>
                            
                        <para>
                            Példaként nézzük meg, hogy CORBA labirintusos
                            esettanulmányunkban miként fogalmazzuk
                            majd meg, hogy a szereplők a labirintus 
                            valamely
                            oszlopában és sorában vannak. A labirintus
                            hőse a labirintus 
                            egy olyan szereplője, aki gyűjtögeti
                            a labirintusban megtalált értékeket,
                            van valahány élete, amik bizony akár 
                            el is fogyhatnak: 

                        <programlisting>
                        <![CDATA[
           interface Szereplo
            {
                attribute long oszlop;
                attribute long sor;
            };
            interface Hos : Szereplo
            {
                attribute long megtalaltErtekek;
                readonly attribute long eletek;
                void megtalaltam(in Kincs kincs);
                boolean megettek();
            };
                        ]]>
                        </programlisting>

                        A CORBA objektumokat leíró IDL interfész definíciója 
                        az <computeroutput>interface</computeroutput> kulcsszóval
                        kezdődik, amit a név, majd nyitó és záró kapcsos zárójelek
                        közé zárt példány- és módszerdeklarációk követnek. Az
                        interfészek közötti öröklődési kapcsolatot a kettőspont
                        jelöli. Az <computeroutput>attribute</computeroutput>
                        kulcsszóval kezdődik a példányok deklarációja. A CORBA
                        objektumnak majd minden példányához implementálnia kell
                        egy lekérdező és egy beállító metódust, illetve a 
                        <computeroutput>readonly</computeroutput> taghoz csak
                        egy lekérdezőt. Az <computeroutput>in</computeroutput> 
                        szócska arra utal, hogy a kincs a CORBA objektum bemenő
                        adata.
                        </para>
                        
                        <para>
                        Az imént említett példa egyébként része a 
                        <emphasis><link linkend="elosztott_labirintus">Elosztott objektumok - Elosztott labirintus</link></emphasis>
                        című ponthoz készített CORBA objektumok IDL interfészeit 
                        tartalmazó <filename>elosztott.idl</filename> állománynak.                                                
                        </para>
                        
                        <para>
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/prog/corba2.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Az elosztott labirintus CORBA objektumainak IDL interfészei.</phrase>
                                </textobject>	
                            </inlinemediaobject>
                        </para>

                        <para>
                            Az interfészek elkészítése után az
                            említett <command>idlj</command> fordítóval
                            elvégezzük a megfelelő Java nyelvi leképezést
                        <screen>
                            <![CDATA[
C:\...> idlj -fall -falltie elosztott.idl                        
                            ]]>
                        </screen>                            
                        a parancsban felhasznált 
                        <computeroutput>-fall -falltie</computeroutput> 
                        kapcsolók arra
                        utalnak, hogy mely kapcsolódó Java forrásokat, mely
                        CORBA objektum implementálási stratégia mentén kívánjuk
                        legeneráltatni. 
                        A legenerált Java forrásokra - esetünkben
                            egy ilyen például a <filename>HosOperations.java</filename>
                            állományra - támaszkodva implementáljuk a 
                            CORBA objektum metódusait:
                            
                        <programlisting>
                        <![CDATA[
public class HősKiszolgáló
        extends SzereplőKiszolgáló
        implements HosOperations {
        
...

    /**
     * Jelzi, hogy éppen megettek.
     *
     * @return true ha a hősnek még van élete, ellenkező esetben,
     * azaz ha az összes élete elfogyott már, akkor false.
     */
    public boolean megettek() {
        
        if(életekSzáma > 0) {
            --életekSzáma;
            return false;
        } else
            return true;
        
    }    
    /**
     * Gyüjtögeti a megtalált kincseket.
     *
     * @param kincs amit éppen magtalált a hős.
     */
    public void megtalaltam(Kincs kincs) {
        
        megtaláltÉrtékek += kincs.ertek();
        
    }
                        ]]>                        
                        </programlisting>
                        
                        és persze az IDL interfészben specifikált
                        <varname>megtaláltErtekek</varname> taghoz
                        készítünk egy lekérdező és egy beállító
                        módszert és az <varname>eletek</varname>
                        taghoz egy lekérdezőt, mivel ez csak
                        olvasható tagnak specifikáltuk. Ezek után
                        jöhet a klasszikus fordítás, majd a futtatás, de mindezzel a
                        <emphasis><link linkend="elosztott_labirintus">Elosztott objektumok - Elosztott labirintus</link></emphasis>
                        című pontban folytatjuk.
                        </para>
                        
            </sect3>
            </sect2>
            
            <sect2>
                <title>Az internet, a programozó tágabb hazája</title>
                
                    <blockquote>
                        <attribution>Wigner Jenő</attribution>
                        <para>
                            „A gépek ilyenformán szakadatlanul együttműködő egységet alkotnak, s e nagy egységen belül a nyilvántartott adatok és ellentmondások folytonos változása szükségszerűen megy végbe.”
                        </para>
                    </blockquote>

                    <para>
                        Az internet megjelenéséig programjaink csak egy adott
                        számítógépben éltek, léteztek. Napjainkban viszont
                        már olyan programokat is írhatunk, amik egy absztraktabb
                        szinten sokkal tágasabb lakhelyet tudhatnak magukénak:
                        számos, a legkülönfélébb módon összekapcsolt mindenféle
                        számítógép hálózatát.
                    </para>

                    <para>
                        Tekintsük például a SETI@Home projektet
                        <citation>SETI HOME</citation>, melyben az
                        arecibói rádióteleszkóp vette adatokat szétosztják
                        az interneten keresztül jelentkező lelkes felhasználók
                        között, akik gépidejükből szánnak a SETI@Home projekttől
                        kapott részadatok elemzésére. Olyan jeleket keresnek
                        a rádióháttérben, amik idegen civilizációk üzenetei
                        lehetnek. Ezen a számításon a SETI@Home projekt
                        sok millió felhasználója osztozik!                        
                        (A SETI témában általában a már eddig is
                        többször hivatkozott
                        <citation>KAPCSOLAT REGÉNY</citation> elolvasását 
                        javasoljuk érzelmi megalapozásként az érdeklődő Olvasónak.)                        
                    </para>

                    <para>
                        A gépek hálózatának szoftveres alapja a 1969 végétől
                        négy amerikai; az UCLA, UCSB, SRI és
                        az utah-i egyetemek között kiépülő és ébredő 
                        ARPANET hálózatra
                        fejlesztett TCP/IP hálózati szoftver.
                    </para>
                    
                    
            <sect3>
                <title>TCP/IP</title>

                    <blockquote>
                        <attribution>Andrew S. Tanenbaum</attribution>
                        <para>
                            „...míg az Internet szabványosítási konferencián a résztvevők farmert viselnek 
                            (kivéve a San Diegóban megrendezett találkozókat, amikor rövidnadrágot és pólót).”
                        </para>
                    </blockquote>
                                    
                    <para>                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/prog/tcpip1.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az internet TCP/IP modellje.</phrase>
                            </textobject>	
                        </inlinemediaobject>                        

                        <orderedlist numeration="arabic">
                            <listitem>
                                <para>A <emphasis>fizikai réteg</emphasis>
                                nem a programozók, inkább a mérnökök világa. Tipikusan
                                mérnöki kérdések merülnek fel, mert a réteg feladata a
                                gépek valódi, fizikai összekapcsolása. Az e feletti
                                rétegekre viszont már mint szoftverekre gondoljunk.
                               </para>
                            </listitem>                            
                            <listitem>
                                <para>A <emphasis>hálózati rétegben</emphasis>
                                megjelenik az IP szám, amivel illetni tudunk
                                egy gépet, pontosabban egy, a gépben lévő hálókártyát.                                
                                </para>
                            </listitem>                            
                            <listitem>
                                <para>A <emphasis>szállítási rétegben</emphasis>
                                lehetővé válik egy IP számon belül disztingválni.
                                Attól függően, hogy a „Megbízható kommunikációt
                                akarunk?” kérdésre a válasz igen, akkor
                                0-65535 számú TCP kapunk van. Ha a válasz nem, akkor
                                ugyanennyi UDP kapu.
                                </para>
                            </listitem>                            
                            <listitem>
                                <para>Az <emphasis>alkalmazási rétegben</emphasis>
                                találjuk az olyan ismert protokollokat, mint a 
                                HTTP - az internetes böngészés, vagy az SMTP - az
                                internetes levelezés protokollja. A továbbiakban 
                                mindkét említettel, demonstrációs céllal 
                                részletesebben is foglalkozunk majd.
                                </para>
                            </listitem>                            
                        </orderedlist>
                        
                    </para>                        
                    
            </sect3>
            
            <sect3>
                <title>A kliens-szerver modell</title>
                    <para>
                        A szerver az a program, aki valamilyen szolgáltatást
                        nyújt, a kliensek pedig azok a programok, akik ezeket a szerverek nyújtotta
                        szolgáltatásokat igénybe veszik.
                    </para>
                    <para>
                        Nézzünk példákat sikeres szolgáltatásokra, azaz olyanokra,
                        amik külön kaput (well-known port, jól ismert portot) 
                        is kaptak 
                        szolgáltatásuk nyújtására.
                        Ezek a kapuk az 1024 alatti tartományból kerülnek ki,
                        a 
                        <ulink url="http://www.iana.org/assignments/port-numbers">http://www.iana.org/assignments/port-numbers</ulink>
                        címen, vagy Linuxunkon a 
                        <filename>/etc/services</filename> állományban lehet csemegézni,
                        hogy melyek is ezek.
                                                
                        <screen>
                            <![CDATA[
[norbi@niobe ~]$ more /etc/services.
.
.
ftp             21/tcp
ftp             21/udp          fsp fspd
ssh             22/tcp                          # SSH Remote Login Protocol
ssh             22/udp                          # SSH Remote Login Protocol
.
.
.
smtp            25/tcp          mail
smtp            25/udp          mail
.
.
.
http            80/tcp          www www-http    # WorldWideWeb HTTP
http            80/udp          www www-http    # HyperText Transfer Protocol
.
.
.
                            ]]>
                        </screen>                                        
                    </para>
                    
            </sect3>
            
            <sect3>
                <title>Bepillantás az alkalmazási rétegbe: a HTTP protokoll</title>

                    <para>
                        Dolgozzunk egy kicsit az alkalmazási réteg szintjén,
                        nézzük meg Linuxunkon működés közben a HTTP protokollt!
                        Fut a gépünkön a webszerver folyamat? Ezt egyszerű
                        felhasználóként is megnézhetjük a webszerver 
                        (http démon) SysV 
                        indítószkriptjének status kapcsolójával:

                        <screen>
                            <![CDATA[
[norbi@niobe ~]$ /etc/rc.d/init.d/httpd status
A(z) httpd le van állítva                            
                            ]]>
                        </screen>                            
                        
                        tehát nem megy. Futtassuk, mert vele tudunk majd TCP/IP-n
                        keresztül HTTP párbeszédet folytatni. Rendszergazdaként 
                        tudjuk lefuttatni
                        a webszerver megfelelő elindítását elvégző szkriptet a
                        start kapcsolóval
                        
                        <screen>
                            <![CDATA[
[root@niobe ~]# /etc/rc.d/init.d/httpd start
httpd indítása:                                          [  OK  ]                           
                            ]]>
                        </screen>                    
                        
                        Megint csak egyszerű felhasználóként lépjünk kapcsolatba
                        a gépünkön a 80-as TCP kapun a kliensek kapcsolatfelvételeire
                        váró webszerver folyamattal és kérjük el tőle a webterület
                        gyökerének <filename>index.html</filename> állományát:
                        
                        <screen>
                            <![CDATA[
[norbi@niobe ~]$ telnet localhost 80
Trying 127.0.0.1...
Connected to localhost.localdomain (127.0.0.1).
Escape character is '^]'.
                            ]]>
                        </screen>                    
                        
                        a <command>telnet</command> programot, most mint TCP kliens programot használjuk
                        arra, hogy TCP csatornán keresztül tudjunk kommunikálni a 
                        webszerverrel. Össze kell állítanunk a HTTP kérést! Ennek
                        első sora, hogy <computeroutput>GET</computeroutput>, azaz szeretnénk elkérni a webterület
                        gyökeréből az <filename>index.html</filename> állományt és mellesleg a <computeroutput>HTTP/1.0</computeroutput>
                        protokollt beszéljük:
                        
                        <screen>
                            <![CDATA[
[norbi@niobe ~]$ telnet localhost 80
Trying 127.0.0.1...
Connected to localhost.localdomain (127.0.0.1).
Escape character is '^]'.
GET /index.html HTTP/1.0
                            ]]>
                        </screen>                    

                        Az első sort követhetik kulcs-érték párok, ha valamit 
                        szeretnénk közölni a szerverfolyamattal, de mivel
                        most semmit, jöhet a kérés törzse, ami most megint csak
                        legyen üres, így gyakorlatilag két entert nyomunk és 
                        máris jön a HTTP válasz a szervertől:
                                                
                        <screen>
                            <![CDATA[
[norbi@niobe ~]$ telnet localhost 80
Trying 127.0.0.1...
Connected to localhost.localdomain (127.0.0.1).
Escape character is '^]'.
GET /index.html HTTP/1.0

HTTP/1.1 200 OK
Date: Sun, 10 Sep 2006 08:20:31 GMT
Server: Apache/2.2.0 (Fedora)
Last-Modified: Sun, 10 Sep 2006 08:17:16 GMT
ETag: "158540-6f-41d1511bd9b00"
Accept-Ranges: bytes
Content-Length: 111
Connection: close
Content-Type: text/html; charset=UTF-8

<html>
        <head>
                <title>Hello, Javat tanitok!</title>
        </head>
        <body>
                Hello, Javat tanitok!
        </body>
</html>Connection closed by foreign host.
                            
                            ]]>
                        </screen>                    
      
                        A HTTP válasz első sora a protokoll, amit a szerver beszél,
                        aztán a válasz kódja és rövid szöveges feloldása: most 
                        <computeroutput>OK</computeroutput>,
                        azaz OK! Ezt követi mindenféle kulcs-érték pár, majd a válasz
                        testébe csomagolva a kért állomány. Ez történik a háttérben,
                        amikor böngészünk. Ha például egy honlapon egy pdf állományra
                        kattintunk, akkor a válaszban a küldött tartalom 
                        <computeroutput>Content-Type: application/pdf</computeroutput>
                        típusa ez lenne, innen tudja majd a böngésző, hogy nyitni
                        kell a pdf megjelenítőt.

                        </para>
                        
                        <para>
                            Persze ugyanezt Windows alatt is megnézhetjük egy
                            Start/Kellékek/Parancssor parancsablakból, ha egy
                            webszervert futtató gép 80-as kapujára csatlakozunk:

                            <screen>
                            <![CDATA[
C:\Documents and Settings\norbi>telnet www.inf.unideb.hu 80                            
                            ]]>
                            </screen>                    

                        </para>
                        
                        <para>
                        
                    <warning>
                        <title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>
                            <para>
                                A következő példa megint csak nem a
                                teljesen kezdő Javasoknak szól, ők
                                szokás szerint ugorják át és majd például a 
                                <emphasis><link linkend="elso_java">Az első Java tapasztalatok</link></emphasis> című pont után térjenek ide vissza. 
                            </para>
                        </warning>
                        
                        <example>
                            <title>Port szkennelő példa</title>
                            
                            <para>                        
                                Dolgozzunk egy kicsit az szállítási réteg szintjén!
                                Írjunk egy a socket programozás absztrakciós szintjére
                                helyezhető példát!
                                
                                    <inlinemediaobject>
                                        <imageobject>
                                            <imagedata fileref="images/prog/tcpip2.png" />
                                        </imageobject>
                                        <textobject>
                                            <phrase>Socket programozás.</phrase>
                                        </textobject>	
                                    </inlinemediaobject>                        
                            </para>
                            
                            <para>                                
                                Írjunk egy rövid példát, ami megnézi,
                                hogy gépünk éppen milyen portokat
                                figyel.
                                
                                <programlisting>
                                    <![CDATA[
public class KapuSzkenner {
    
    public static void main(String[] args) {
        
        for(int i=0; i<1024; ++i)
            
            try {
                
                java.net.Socket socket = new java.net.Socket(args[0], i);
                
                System.out.println(i + " figyeli");
                
                socket.close();
                
            } catch (Exception e) {
                
                System.out.println(i + " nem figyeli");
                
            }
    }
    
}
                                    ]]>
                                </programlisting>

                                A program végigzongorázza a parancssorában
                                megkapott nevű gép 1024 alatti
                                számú TCP kapuit: megpróbál egy TCP kapcsolatot
                                
                                <programlisting>
                                    <![CDATA[
                java.net.Socket socket = new java.net.Socket(args[0], i);
                                    ]]>
                                </programlisting>
                                                                
                                létrehozni, ha sikerül, akkor a célporton ül
                                egy szerver folyamat, ha nem, azaz ha kivétel
                                keletkezik, akkor nem. Egyébként siker 
                                esetén sem csinálunk semmit, hanem csak
                                bezárjuk az éppen elkészített kliensoldali
                                kommunikációs végpontot reprezentáló socket
                                objektumot.
                                
                                <screen>
                                    <![CDATA[
[norbi@omega ~]$ java KapuSzkenner niobe
.
.
.
19 nem figyeli
20 nem figyeli
21 figyeli
22 figyeli
23 nem figyeli
24 nem figyeli
25 figyeli
26 nem figyeli
.
.
.
79 nem figyeli
80 figyeli
81 nem figyeli
82 nem figyeli
.
.
.
                                    ]]>
                                </screen>                    
                                
                            </para>
                            
                        </example>

                        <caution>
                           <title>Csak saját gépre</title>
                            <para>
                                Fontos, hogy ezt a 
                                kapufigyelő programunkat ne
                                szabadítsuk rá az internetre,
                                azaz ne engedjük
                                rá tetszőleges gépre, hanem 
                                csak az otthonira. Mert egy
                                túlérzékeny rendszergazda még
                                (jogosan) úgy érezné, hogy támadás
                                fenyegeti a gépét. Ha ilyen
                                gépen akarjuk kipróbálni, például az 
                                iskolában, azt előtte beszéljük meg
                                a megfelelő rendszergazdával.
                            </para>
                        </caution>
                        </para>
                        
                        <example>
                            <title>Jól ismert portok feladat</title>
                            <para>
                                Milyen szolgáltatások futnak a fent leportszkennelt
                                gépen?
                            </para>
                        </example>
            </sect3>
        </sect2>    
    </sect1>
    
    </chapter> 
    
    <chapter id="sajat_vilagok">
    
    <chapterinfo>
        <keywordset>
          <keyword>objektumorientált tervezés</keyword>
          <keyword>objektumorientált programozás</keyword>
          <keyword>OO programozás</keyword>
          <keyword>Java programozás</keyword>
          <keyword>Java bevezetés</keyword>
          <keyword>osztály</keyword>
          <keyword>objektum</keyword>
          <keyword>öröklődés</keyword>
          <keyword>kivételkezelés</keyword>
          <keyword>eseménykezelés</keyword>
          <keyword>GUI</keyword>
          <keyword>Swing</keyword>
          <keyword>CORBA</keyword>
          <keyword>Java IDL</keyword>
          <keyword>CORBA</keyword>
          <keyword>ORB</keyword>
          <keyword>idlj</keyword>
          <keyword>POA</keyword>
        </keywordset>
    </chapterinfo>
    
        <title>Saját világok teremtése és Java alapok</title>
       
    <epigraph>
        <attribution>
            David Clark
            <citetitle>
                <citation>HÁLÓZATOK KÖNYV</citation>
                <citation>INTERNET REGULATION</citation>
            </citetitle>
        </attribution>
        <para>
            „Döcögő egyetértés és futó programok”
        </para>
    </epigraph>        

    <epigraph>
        <attribution>
            Konfuciusz
            <!--
            <citetitle>
                <citation></citation>
            </citetitle>
-->
        </attribution>
        <para>
            „A tigrist előbb gondolatban el kell ejteni - a többi formalitás”
        </para>
    </epigraph>        
        
    <abstract>
        <para>
            Az OO programozó mentális világokat teremt, mint ahogyan mi is ezt fogjuk
            tenni ebben a fejezetben. Kifejlesztünk egy labirintus API
            interfészt, azaz megteremtjük a saját labirintus játékunk 
            képzeletbeli világát.
            S e fejlesztési munka során ismerkedünk meg a Java OO programozás alapjaival.
            Itteni munkánk gyümölcse, a kifejlesztett labirintus API szolgál majd a 
            következő fejezetek fejlesztendő esettanulmányainak alapjául.
        </para>
    </abstract>

    <highlights>
        <para>
            Ebben a gyakorlati programozási részben
            <itemizedlist>
                <listitem><para>elkezdünk egy saját labirintus OO világot teremteni</para></listitem>                    
                <listitem><para>miközben megismerjük az OO és konkrétan a Java OO programozás alapfogalmait</para></listitem>
            </itemizedlist>                
        </para>                
    </highlights>        
                
    <sect1 id="java_vilaga">
        <title>A Java világa</title>
                
        <blockquote>
            <attribution>Madách Imre
                <citetitle>Az ember tragédiája</citetitle>
            </attribution>
            <literallayout>
                „Fel hát csatázni, fel hát lelkesülni
                Az  új tanért. Alkotni új világot,”                    
            </literallayout>
        </blockquote>
        
        <para>Lépjünk hát be a Java világába! Első lépésünk a Java SE, 
        ME fejlesztői csomag telepítése, beállítása legyen. Itt általános
        szabály, hogy mindig a legfrissebb verziójú Java SE, ME fejlesztői 
        csomagokat használjuk. 
        <emphasis><link linkend="telepites">A Java telepítése gépünkre</link></emphasis>
        pontban részletes segítséget adunk a 
        letöltésről, telepítésről és az esetleges további beállításokról mind a Windows, mind a Linux operációs rendszereket futtató Olvasóknak egyaránt. </para>
        <para>A továbbiakban tehát feltesszük, hogy a megfelelő Javát az előző bekezdés hivatkozta pont 
        értelmében beállítottuk és egyik kezünk mindig a billentyűzeten...</para>

        <sect2>
            <title>A Java nyelv</title>
            
            <para>Minden programhoz kapcsolható egy sajátos világ, egy mikrokozmosz. </para>

            <para>A kisebb, egyszerűbb programok esetén ez a mikrokozmosz általában 
            nem külön létező, hanem csupán egy már létező világ parányi, kiragadott 
            része. Erre példaként tekintsük azt a szokásos C programot, ami a sztenderd
            inputját másolja a sztenderd outputjára és a bemenet vége jelre kilép. 
            
			<warning>
				<title>Figyelmeztetés a C-ben járatlan Olvasóknak</title>
				<para>
					Az alábbi széles körben elterjedt, szokásos C bevezető 
					példa a hasonló szerkezetű és 
					működésű Java példát vezeti be, rövid átfutása után akár át is
					ugorható. 	
				</para>
			</warning>
                        
            <programlisting>
                <![CDATA[
#include <stdio.h>
int
main (void)
{
  int c;
  while ((c = getchar ()) != EOF)
    putchar (c);
  return 0;
}                
                ]]>
            </programlisting>

            Az Olvasó az alábbi módon fordíthatná és futtathatná ezt a 
            <filename>masol.c</filename> forrásállományba illesztett másoló kódot.
            
            <screen>
                <![CDATA[
[norbi@niobe ~]$ gcc masol.c -o masol
[norbi@niobe ~]$ ./masol
q
q
w
w
e
e
r
r
t
t                
                ]]>
            </screen>                    
            
            A <command>gcc</command> fordítóval lefordítottuk a 
            <filename>masol.c</filename> forrást és a fordítás eredményéül
            kapott bináris futtatható állományt a <filename>masol</filename> nevű 
            állományba tetettük a fordító <parameter class="command">-o</parameter>
            kapcsolójának segítségével. Majd az aktuális könyvtárból, azaz a
            <computeroutput>./állománynév</computeroutput> alakban futtattuk
            a <filename>masol</filename> nevű állományt. A futás alatt a 
            billentyűzetről beütött és enterrel kísért
            <userinput>q</userinput>,
            <userinput>w</userinput>,
            <userinput>e</userinput>,
            <userinput>r</userinput>,
            <userinput>t</userinput> karaktereket a program a kimenetén, azaz a
            képernyőn visszhangozta, egészen a bemenet vége, azaz a 
            <keycap>Ctrl+d</keycap> billentyűkombináció megnyomásáig.            
            </para>
            
            <para>
            Ennek a C programnak a világát az 
            <computeroutput>stdin</computeroutput> - most a billentyűzet, az 
            <computeroutput>stdout</computeroutput> - most a képernyő, 
            a UNIX világból ismerős elemei, továbbá az egész 
            számok, köztük az <constant>EOF</constant>
            jelnek megfelelő szám alkotják. Ebben a világban 
            a program szerint az történik, hogy számot olvasunk a program 
            <computeroutput>stdin</computeroutput> bemenetről a
            <function>getchar()</function> függvénnyel 
            és írjuk a program <computeroutput>stdout</computeroutput> kimenetre, s 
            mindaddig folytatjuk ezt, amíg az <constant>EOF</constant>
            számot nem olvassuk a bemeneten.
            
            </para>
            
            <para>
            Hogyan fest az iménti C kódnak megfelelő Java program mikrokozmosza?
            
            <programlisting>
                <![CDATA[
public class Másol {
    
    public static void main(String[] args) throws Exception {
        
        int i = 0;
        while((i=System.in.read()) != -1)
            System.out.printf("%c", i);

    }    
}                
                ]]>
            </programlisting>
            
            Az Olvasó az alábbi módon fordíthatná és futtathatná ezt a 
            <filename>Másol.java</filename> forrásállományba illesztett 
            másoló osztályt.
            
            <screen>
                <![CDATA[
[norbi@niobe ~]$ javac Másol.java
[norbi@niobe ~]$ java Másol
q
q
w
w
e
e
r
r
t
t                
                ]]>
            </screen>                    
            
            A <command>javac</command> fordítóval lefordítottuk a 
            <filename>Másol.java</filename> forrást, a fordítás eredményéül
            kapott bináris bájtkód állományt a <filename>Másol.class</filename> 
            nevű 
            állományba kaptuk. Amit a 
            <command>java Másol</command> parancs kiadásával - a 
            <filename>.class</filename> kiterjesztést soha nem, mindig csupán
            az osztálynevet kiírva - adtunk át
            bemenetként a Java Virtuális Gépnek. A futás alatt ugyancsak a 
            billentyűzetről beütött és enterrel kísért
            <userinput>q</userinput>,
            <userinput>w</userinput>,
            <userinput>e</userinput>,
            <userinput>r</userinput>,
            <userinput>t</userinput> karaktereket a program a kimenetén, azaz a
            képernyőn visszhangozta, egészen a bemenet vége, azaz a 
            <keycap>Ctrl+d</keycap> billentyűkombináció megnyomásáig.                        
            </para>

            <para>
            Ennek a Java programnak a világát csatornák, 
            a <varname>System.in</varname> sztenderd bejövő és a 
            <varname>System.out</varname> sztenderd kimenő csatornák alkotják.
            Egészen pontosan a <classname>System</classname> osztály
            <classname>InputStream</classname> típusú <varname>in</varname>
            és <classname>PrintStream</classname> típusú, azaz 
            <classname>PrintStream</classname> osztálybeli 
            <varname>out</varname> változója vagy tagja. Ezen felül a 
            működés pedig megegyezik az imént tárgyalttal annyi kiegészítéssel,
            hogy a <varname>System.in</varname> bejövő csatorna 
            <function>read()</function> függvénye a <literal>-1</literal>
            érték visszaadásával jelzi a csatorna végét.
            </para>
                        
            <para>A nagyobb, bonyolultabb programok esetén maga a program, azaz a programozó építheti fel a mikrokozmoszt. Példaként tekintsünk egy labirintus játék programot, amiben a világ maga a labirintus, kincsestől, szörnyestől, hősöstől és a szokásos történik: a hős bolyong, a szörnyek próbálják megenni, a kincs várja, hogy rábukkanjanak stb. </para>
            <para>Az OO programozás ereje abban rejlik, hogy a programozó a fejlesztés során arra van utalva, hogy saját világokat építsen, teremtsen! Építőelemei a választott OO platform API interfészének osztályai, habarcsa pedig maga a választott OO nyelv. </para>
            <para>A következőkben a Java nyelvvel egy labirintus játék világának felépítése során ismerkedünk meg.</para>

            <sect3>
                <title />
                <sect4>
                    <title />
                    <sect5 id="sajat_labirintus">
                        <title>Saját labirintus feladat</title>
                        
                        <example>
                            <title>Saját labirintusunk elképzelése</title>
                            <para>                           
                                Mindenki képzelje el saját labirintusát! Egy 
                                négyzethálós lapon készítsünk vázlatos rajzot a 
                                szerkezetéről, foglaljuk össze írásban, mik 
                                vannak egy labirintusban!                            
                            </para>
                        </example>
                                                
                        <para>
                            Mi a labirintusunkat a következőképpen képzeljük el.
                            </para>
 
                        <para>
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/labirintus/labirintus1.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Egy labirintus tervrajza.</phrase>
                                </textobject>	
                            </inlinemediaobject>
                                                                            
                        </para>
                        
                        <para>Ez egy 10 cella széles és 10 cella magas labirintus. 
                        A falat tégla színnel jelöltük, a járatot világossárgával. 
                        Persze olyan is lehetne, hogy jóval nagyobb labirintust 
                        készítenék és azt, hogy egy cella éppen járat vagy fal 
                        véletlenül döntenénk el: minden egyes ilyen döntésnél fej 
                        vagy írás érmét használnánk, de legalábbis egy ennek 
                        megfelelő véletlenszám generátort, azaz egy olyan 
                        programot (vagy éppen csak egy 
                        <classname>java.util.Random</classname> osztálybeli
                        objektumot) ami a fej vagy írás dobálást szimulálja. 
                        </para>
                        
                        <para>Aztán legyenek a labirintusban kincsek, szörnyek és maga a 
                        hős. Sok értékes kincs, kevés szörny és egy hős. A 
                        játék, hogy a hőssel minél gyorsabban össze kell 
                        gyűjteni a kincseket, miközben pedig el kell kerülni 
                        a szörnyeket. A kincsek és a szörnyek minden játékban 
                        máshonnan induljanak!
                        </para>
                        
                        <para>
                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/labirintus/labirintus2.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Egy lehetséges benépesített labirintus.</phrase>
                                </textobject>	
                            </inlinemediaobject>                        

                            <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/labirintus/labirintus3.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Egy másik lehetséges benépesített labirintus.</phrase>
                                </textobject>	
                            </inlinemediaobject>                        
                        </para>
                        
                        </sect5>
                    </sect4>
                </sect3>
                        
                <sect3>
                    <title>Osztályok és objektumok</title>
                            
                <para>Milyenek is a labirintusok, milyen is a mi, az előző pontban elképzelt labirintusunk? Gyűjtsük most össze a lényeges jellemzőit, tulajdonságait, részeit! 
                Majd ezt követően Java nyelven írjuk le! </para>
                <para>Mindenekelőtt a labirintusnak van mérete: szélessége és hosszúsága. 
                Ez két szám, két egész szám. Javaban az egész értékeket így írjuk le:</para>

                <programlisting>
                    <![CDATA[
int szélesség;
int magasság;
                    ]]>
                </programlisting>
                
                
                <para>és úgy olvassuk, hogy a szélesség és a magasság 
                <type>int</type>
                típusú változók. Ezeknek a változóknak az értéke az előző labirintus példánál maradva 10 és 10.</para>
                <para>A labirintus lényegéhez tartozik a szerkezete, azaz, hogy hol van fala. Mert ahol nincs, ott ugye járata van. Ezt a labirintus elképzelése során, a négyzethálós lapon egy kétdimenziós tömb alakjában rajzoltuk le. Javaban ha nem egyetlen számot akarunk reprezentálni, hanem számok ilyen szabályos elrendezését, tömbjét, akkor ezt írjuk:</para>

                <programlisting>
                    <![CDATA[
int[][] szerkezet;
                    ]]>
                </programlisting>
                        
                <para>
                    <inlinemediaobject>
                        <objectinfo>
                            <title>A megfelelő cella megmondja, hogy z 5. sor 6. oszlopában fal van vagy járat?</title>
                        </objectinfo>                        
                        <imageobject>
                            <imagedata fileref="images/labirintus/labirintus4.png" />
                        </imageobject>
                        <textobject>
                            <phrase>Az 5. sor 6. oszlopában fal van vagy járat?</phrase>
                        </textobject>
                    </inlinemediaobject>
                </para>
                    
                <para>
                ahol a <computeroutput>[5][6]</computeroutput>
                majd például azt mondja meg, hogy az 5. sor 6. oszlopában fal van vagy járat, azaz az itt lévő szám 0 vagy 1, most éppen járat, azaz 0. Az ábrán egyben azt is észrevételezhetjük, hogy a Java tömbök elemeinek indexelése, azaz sorszámozása nullától indul.                    
                </para>
                
                <para>Mivel labirintus terünk olyan, hogy itt csak ez a két érték jöhet szóba, az 
                int típus használata jelen esetben pazarló, mert az int értéke nem csupán 0 vagy 1 lehet, hanem 
                a -2<superscript>31</superscript> számtól a 2<superscript>31</superscript>-1 
                számig bármi, 
                ami búzaszemben nem olyan sok, mintha egy szemből indulva a sakktábla minden cellájában megdupláznánk a szemeket, de azért jó nagy. </para>
                <para>Használjunk helyette 
                <type>boolean</type> típust, mert ennek 
                csupán két értéke lehet: a hamis - Javaban <literal>false</literal> - 
                vagy az igaz - <literal>true</literal>. 
                Esetünkben a tervben szereplő 0 értéket képzeljük a <literal>false</literal>
                 boolean értéknek, az 1 értéket <literal>true</literal> boolean értéknek. Ekkor a</para>

                <programlisting>
                    <![CDATA[
boolean[][] szerkezet;
                    ]]>
                </programlisting>
                                
                <para>
                    <inlinemediaobject>
                        <objectinfo>
                            <title>Hamis az, hogy fal van, tehát nem fal van itt, hanem járat.</title>
                        </objectinfo>                        
                        <imageobject>
                            <imagedata fileref="images/labirintus/labirintus5.png" />
                        </imageobject>
                        <textobject>
                            <phrase>Nem fal van, hanem járat.</phrase>
                        </textobject>
                    </inlinemediaobject>
                </para>
                <para>                                        
                tömb <computeroutput>[5][6]</computeroutput>
                eleme majd arra a kérdésre válaszol, hogy fal van-e ezen a helyen a labirintusunkban?                    
                </para>

                <para>A válasz hamis, azaz nem fal van ott, hanem járat. </para>

                <para>Foglaljuk most össze, hogyan írtuk le labirintusunkat:</para>

                <programlisting>
                    <![CDATA[
int szélesség;
int magasság;
boolean[][] szerkezet;
                    ]]>
                </programlisting>
                
                <para>Java nyelven a fejlesztendő programunk világabeli
                dolgok tulajdonságait osztályokba foglalva írjuk le.
                Az osztálynak van neve, ez utaljon magára arra a dologra, 
                amit az osztály le akar írni és megegyezés szerint 
                kezdődjék nagy első betűvel. Ha több szóból áll, akkor
                minden alkotó rész szó kezdődjék nagy első betűvel. 
                A mi labirintus osztályunkat nevezzük egyszerűen 
                <classname>Labirintus</classname> osztálynak és tartalmazza 
                tehát azokat az általános jellemzőket, amit a labirintusról 
                éppen most összeszedtünk. A név elé írjuk a 
                <computeroutput>class</computeroutput>
                kulcsszót, majd az osztály nevét, végül az osztály tulajdonságait foglaljuk nyitó és záró kapcsos zárójelek közé.</para>

                <programlisting>
                    <![CDATA[
class Labirintus {

        int szélesség;
        int magasság;
        boolean[][] szerkezet;

}
                    ]]>
                </programlisting>
                
                <para>
                Megvan általában a labirintusunk leírása, de nekünk egy 
                konkrét játékban egy konkrét labirintusra lesz szükségünk, azaz 
                egy a <classname>Labirintus</classname>
                osztályból származó konkrét labirintusra, 
                egy labirintus objektumra. Azt a folyamatot, amikor egy osztályból 
                konkrét példányt, egy objektum példányt hozunk létre,  
                <emphasis>példányosításnak</emphasis>
                nevezzük. A példányosítást egy speciális függvény, a konstruktor 
                végzi. 
                De mielőtt tovább folytatnánk, elöljáróban következzék 
                még néhány gondolat. A Java nyelv, bármennyire is csodálatos 
                nyelv, de mégiscsak egy nyelv. A következő pontban 
                - egy rövid kitérő erejéig -
                ennek megfelelően közelítünk majd a Java programozási nyelvhez. Ebben a
                tárgyalásban a beszélt nyelvek - mint például a magyar nyelv - felől
                közelítünk a pogramozási nyelvhez, mint ahogyan hasonlóan ezt a 
                megközelítést követtük - az egyébként gyermekeknek
                szánt - 
				<citation>FANTASZTIKUS PROGRAMOZÁS</citation> könyvben is.
				Csak érdekességként jegyezzük meg, hogy a fordított folyamat, amely során
				a programozási nyelvek világa felől közelítünk a beszélt nyelvekhez, Noam
				Chomsky nyelvész munkássága nyomán 
				<citation>CHOMSKY NYELVOSZTÁLYOK</citation>				
				ma az egyik legalapvetőbb 
				informatikai és fontos nyelvészeti diszciplina.
                </para>
                
				</sect3>                
                
                <sect3>
                    <title>A programozás világnyelve a Java</title>
                
                <para>
                A Java nyelv nem beszélt, hanem írott nyelv, 
                amin a programozók „beszélnek”, azaz 
                írnak. A Java nyelvnek napjainkra három nagy 
                nyelvjárása alakult ki, ezek a Java ME, a Java SE és a Java EE.
                Az ME (a Micro Edition - mikro kiadás) a mobiltelefonokat 
                programozók közösségében
                terjedt el, az EE (az Enterprise Edition - vállalati kiadás) az
                ipari szférában hódít, az SE (a Standard Edition - általános kiadás) 
                pedig az a közös gyökér, amiből ezek a dialektusok mára kifejlődtek. De ne becsüljük
                le a Java SE-t, mert a Java SE API hatalmas. Csak egy példával érzékeltetve:
                a Java nyelven implementáló CORBA programozó is a Java SE nyelvjárást
                beszéli! Ami ezeket a nyelvjárásokat elidegeníthetetlenül összeköti, az maga a
                Java nyelv, a Java nyelv nyelvtana.
                </para> 
                
                <sect4>
                    <title>A Java nyelvtana</title>
                
                <para>                
                A Java nyelvben használt betűk lehetnek akár ékezetesek is, mert a
                Java forrásállományokban tetszőleges Unicode karaktereket felhasználhatunk.
                Az egymás után írt betűket szavaknak nevezzük. 
                </para>
                                
                <sect5 id="java_szofajok">
                    <title>A Java szófajok</title>

                <para>                
                A Java szavak háromfélék lehetnek, ezek a 
                <itemizedlist>
						<listitem><para><emphasis>kulcsszavak</emphasis></para></listitem>
						<listitem><para><emphasis>az azonosító szavak</emphasis></para></listitem>
						<listitem><para><emphasis>és a kifejezés szavak.</emphasis></para></listitem>
						</itemizedlist>
                </para>
                
                <para>                
                A Java szófajok legegyszerűbbike a <emphasis>kulcsszó</emphasis>,
                mert a Java kulcsszavak véges
                kevesen vannak. Könnyen megadhatjuk őket egy egyszerű felsorolással. Ezt a 
                felsorolást azzal segítjük, hogy a kulcsszavakat további három alszófajba
                osztjuk, ezek a 
                <itemizedlist>
						<listitem><para><emphasis>melléknevek</emphasis></para></listitem>
						<listitem><para><emphasis>a típus nevek</emphasis></para></listitem>						<listitem><para><emphasis>és a vezérlő nevek</emphasis></para></listitem>
						</itemizedlist>
                </para>
                
                    <warning>
                        <title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>
                        <para>
                            A következőkben valódi Java forráskódrészletek következnek.
                            Ne értelmezni próbáljuk ezeket, hanem csupán az említett
                            szavak előfordulásait figyeljük meg bennük!
                        </para>
                    </warning>

					<para> A Java melléknevek a következők:               
					<itemizedlist>
						<listitem><para><emphasis>static</emphasis> jelentése, hogy nem 
						példányhoz, hanem osztályhoz tartozó. Például a 
						<classname>Labirintus</classname> osztálybeli
					   <programlisting>
							<![CDATA[
    /** Normál működés, a hőssel időközben semmi nem történt. */
    public static final int JÁTÉK_MEGY_HŐS_RENDBEN = 0;    						
							]]>
						</programlisting>					
							sorok azt jelentik, hogy a <varname>JÁTÉK_MEGY_HŐS_RENDBEN</varname>
							egész típusú változó statikus, azaz nem a <classname>Labirintus</classname>
							 osztálybeli
							példányokhoz, hanem magához a <classname>Labirintus</classname> osztályhoz
							tartozik. Nem minden labirintus objektumnak van meg ez az egész 
							típusú változója, hanem az esetlegesen létrehozott több
							labirintus objektumnak van egy
							közös <varname>JÁTÉK_MEGY_HŐS_RENDBEN</varname> nevű változójuk. 
							Tehát - akár a <classname>Labirintus</classname> osztályból való példány
							létrehozása nélkül - az osztálynévvel minősítve, a 
							<computeroutput>Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN</computeroutput>
							formában használhatjuk ezt a 
							változót. Így teszünk például a <classname>LabirintusJáték</classname>
							osztályban: 
					   <programlisting>
							<![CDATA[
            switch(labirintus.bolyong(hős)) {
                
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:                
                    break;   						
							]]>
						</programlisting>			
						ahol a program szövegrészlet azt mondja, hogy 
						a hős labirintusbeli bolyongása során nem csinálunk semmit, ha a 
						hőssel nem történik semmi.
						</para></listitem>
						
						<listitem><para><emphasis>final</emphasis> jelentése, hogy nem 
						módosítható. Például az előző
						<classname>Labirintus</classname> osztálybeli példánál 
						maradva a						 
					   <programlisting>
							<![CDATA[
    /** Normál működés, a hőssel időközben semmi nem történt. */
    public static final int JÁTÉK_MEGY_HŐS_RENDBEN = 0;    						
							]]>
						</programlisting>	
						sorokban a <computeroutput>final</computeroutput> melléknév azt
						jelenti, hogy a <varname>JÁTÉK_MEGY_HŐS_RENDBEN</varname> nem
						módosítható a futás során. Ez azt jelenti, hogy a 
						<computeroutput>JÁTÉK_MEGY_HŐS_RENDBEN = 42;</computeroutput>						 értékadást tartalmazó programot a fordító le sem fordítja, hanem
						hibát jelez, mert a változót nem módosíthatónak mondtuk!
						
					   <programlisting>
							<![CDATA[
C:\...\Munkakönyvtár>javac javattanitok\labirintus\Labirintus.java
javattanitok\labirintus\Labirintus.java:44: cannot assign a value 
to final variable JÁTÉK_MEGY_HŐS_RENDBEN

JÁTÉK_MEGY_HŐS_RENDBEN = 42;
^
1 error							
							]]>
						</programlisting>					
										
							</para></listitem>
						
						<listitem><para><emphasis>public</emphasis> jelentése, hogy 
						bárhonnan látható. Próbáljuk ki, hogy az imént, a
						<classname>Labirintus</classname> osztályból 
						idézett sorokból kihagyjuk a 
						<computeroutput>public</computeroutput> melléknevet:						 
					   <programlisting>
							<![CDATA[
    /** Normál működés, a hőssel időközben semmi nem történt. */
    static final int JÁTÉK_MEGY_HŐS_RENDBEN = 0;    								
							]]>
						</programlisting>				
							
							Az így módosított <classname>javatanitok.labirintus</classname>
							csomagbeli
							labirintus API-val már nem fog lefordulni például a 
							<classname>javatanitok</classname> csomagbeli, a 
							<classname>javatanitok.labirintus.Labirintus</classname>
							osztályt használó
							<classname>LabirintusVilág</classname> program, mert nem látja
							az immár nem publikus tulajdonságú 
							<varname>JÁTÉK_MEGY_HŐS_RENDBEN</varname> tagot:							
						
					   <programlisting>
							<![CDATA[
C:\...\Munkakönyvtár>javac javattanitok\LabirintusVilág.java
javattanitok\LabirintusVilág.java:83: JÁTÉK_MEGY_HŐS_RENDBEN is not public 
in javattanitok.labirintus.Labirintus; cannot be accessed from outside package
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                               ^
1 error							]]>
						</programlisting>					
							
							</para></listitem>


						<listitem><para><emphasis>private</emphasis> jelentése, hogy 
						csak a saját osztályában látszik. Például az előző pont módosításához 
						hasonlóan végezzük el az alábbi átalakítást: 
					   <programlisting>
							<![CDATA[
    /** Normál működés, a hőssel időközben semmi nem történt. */
    private static final int JÁTÉK_MEGY_HŐS_RENDBEN = 0;    								
    							]]>
						</programlisting>					

							ennek megfelelően fordításkor az alábbi hibát kapjuk:
						
					   <programlisting>
							<![CDATA[
C:\...\Munkakönyvtár>javac javattanitok\LabirintusVilág.java
javattanitok\LabirintusVilág.java:83: JÁTÉK_MEGY_HŐS_RENDBEN has private access
in javattanitok.labirintus.Labirintus
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                               ^
1 error
						]]>
						</programlisting>				
						
						ha ragaszkodnánk a privát tulajdonsághoz, akkor ezt a 
						hibát csak úgy háríthatnánk el, ha csakis a 
						<classname>javatanitok.labirintus.Labirintus</classname>
						osztályban használnánk a továbbiakban a
						 	<varname>JÁTÉK_MEGY_HŐS_RENDBEN</varname> tagot.
												
							</para></listitem>
							
						<listitem><para><emphasis>protected</emphasis> jelentése, hogy 
						csak a saját és a leszármazott osztályokban látszik.  
						Például az előző pontok módosításaihoz
						hasonlóan végezzük el az most az alábbi módosítást: 
					   <programlisting>
							<![CDATA[
    /** Normál működés, a hőssel időközben semmi nem történt. */
    protected static final int JÁTÉK_MEGY_HŐS_RENDBEN = 0;    								
    							]]>
						</programlisting>					

							aminek megfelelően most fordításkor a 
						
					   <programlisting>
							<![CDATA[
C:\...\Munkakönyvtár>javac javattanitok\LabirintusVilág.java
javattanitok\LabirintusVilág.java:83: JÁTÉK_MEGY_HŐS_RENDBEN has protected access
in javattanitok.labirintus.Labirintus
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                               ^
1 error
						]]>
						</programlisting>				
						hibát kapjuk.
						Ha ragaszkodnánk a védett tulajdonsághoz, akkor ezt a 
						hibát csak úgy háríthatnánk el, ha csakis a 
						<classname>javatanitok.labirintus.Labirintus</classname>
						osztályban vagy annak leszármazottaiban használnánk a továbbiakban a
						 	<varname>JÁTÉK_MEGY_HŐS_RENDBEN</varname> tagot.						
						
							</para>
							<para>
							Megjegyezhetjük, hogy a 
							<computeroutput>public</computeroutput>,
							<computeroutput>static</computeroutput>,
							<computeroutput>final</computeroutput> jellemzésű változókat 
							konstansoknak nevezzük. A 
                                JDK könyvtárában található
                                <filename>src.zip</filename> állományban -
                                ahol megtaláljuk a Java SE OO világ összes 
                                osztályának forráskódját - a
                                <filename>src.zip/java/lang/Math.java</filename>
                                forrásban 
                                leírt
                                <classname>Math</classname> osztályban
                                találjuk például a Pi konstans definícióját:
                                <computeroutput>public static final double PI = 3.14159265358979323846; </computeroutput>
							</para>
							</listitem>

						<listitem><para><emphasis>void</emphasis> jelentése, hogy nem 
						ad vissza értéket. Például a <classname>LabirintusJáték</classname>
						osztályban a 
					   <programlisting>
							<![CDATA[
    /**
     * Ébresztő az várakozó rajzolást végző szálnak, ki kell rajzolni a játék 
     * grafikus felületét.
     */
    synchronized public void rajzolniKell() {
        
        notify();
        
    }							
							]]>
						</programlisting>					
							sorok azt mondják, hogy a <function>rajzolniKell()</function>
							függvény nem ad vissza semmit, mert hiszen nem is számol ki semmit.
							Feladata csupán annyi, hogy az éppen egy 
							<function>wait()</function> hívásban alvó végrehajtási szálat 
							a <function>notify();</function>
							függvény meghívásával felébressze.
							</para></listitem>
						
						<listitem><para><emphasis>synchronized</emphasis> jelentése, hogy 
						korlátozza, szabályozza a szálak futását. 
						Az imént látott <function>notify()</function>
						függvény a <classname>java.lang.Object</classname> osztály - minden 
						Java osztály ősének - metódusa, ami egyben azt is jelenti, hogy
						ezzel a metódussal minden Java osztály rendelkezik. Mint ahogyan a
						a függvény párjával, a <function>wait()</function> metódussal is.
						Ez utóbbi függvény hívása elaltatja a hívást végrehajtó 
						programszálunk futását, az előbbi pedig az ilyen alvó szálakat ébreszti fel. 
						Szabály, hogy egy objektum <function>notify()</function> függvényét
						szinkronizáltan hívjuk. Szinkronizált a
						hívás, ha az objektum egy szinkronizált példány vagy az objektum 
						osztályának szinkronizált osztály metódusából, vagy az objektum egy
						szinkronizált programszöveg blokkjából történik. 
						Ezt a szinkronizált tulajdonságot
						jelöli a <computeroutput>synchronized</computeroutput> melléknév.
						A fenti példában a 
						<computeroutput>synchronized public void rajzolniKell() {</computeroutput>
						szinkronizált, példányhoz tartozó <function>rajzolniKell()</function>
						metódust láttuk.				
							</para></listitem>
														
					</itemizedlist>
					</para>
	
					<para> A Java <emphasis>típusnevek</emphasis>
					 a következők:                              
						<emphasis>int</emphasis>, 
						<emphasis>long</emphasis>, 
						<emphasis>byte</emphasis>, 
						<emphasis>char</emphasis>, 
						<emphasis>float</emphasis>, 
						<emphasis>double</emphasis>, 
						<emphasis>boolean</emphasis>.
						A típusnevek használatával a 
						<emphasis><link linkend="tipusok_es_valtozok">Típusok és változók</link></emphasis> című pontban foglalkozunk részletesen.
					</para>

					<para>A Java <emphasis>vezérlő nevek</emphasis> a következők:
					<itemizedlist>
						<listitem><para><emphasis>import</emphasis> jelentése,
						más osztályok használatának jelzése. Például a 
						<classname>LabirintusVilág</classname> osztálybeli 
					   <programlisting>
							<![CDATA[
import javattanitok.labirintus.*;							
							]]>
						</programlisting>				
						sor azt mondja, hogy az osztály használja a 
						<classname>javattanitok.labirintus</classname> csomagot, a 
						kézikönyvhöz fejlesztett labirintus API-t. Ha ezt a sort
						kitörölnénk az osztály forráskódjából, akkor a 
					   <programlisting>
							<![CDATA[
C:\...\Munkakönyvtár>javac javattanitok\LabirintusVilág.java 
javattanitok\LabirintusVilág.java:31: cannot find symbol
symbol  : class Labirintus
location: class javattanitok.LabirintusVilág
    protected Labirintus labirintus;
              ^
javattanitok\LabirintusVilág.java:33: cannot find symbol
symbol  : class Hős
location: class javattanitok.LabirintusVilág
    protected Hős hős;
              ^
javattanitok\LabirintusVilág.java:47: cannot find symbol
symbol  : class RosszLabirintusKivétel
location: class javattanitok.LabirintusVilág
    throws RosszLabirintusKivétel {				
    
...
11 errors    			
							]]>
						</programlisting>				
						hibákat adná a fordító. Mivel nem jeleztük, hogy használjuk a 
						<classname>javattanitok.labirintus</classname> csomagot, így a fordító nem 
						találja az ebben a csomagban elhelyezett <classname>Labirintus</classname>, 
						<classname>Hős</classname>, <classname>RosszLabirintusKivétel</classname> 
						stb. használt osztályokat. 
						</para>
						<para>						
						Az <computeroutput>import</computeroutput>
						utasításban a csillag a csomag összes osztályát jelenti. A
						<classname>LabirintusKiszolgáló</classname> osztálybeli
					   <programlisting>
							<![CDATA[
import java.util.List;
import java.util.Iterator;
							]]>
						</programlisting>				
						sorok azt mondják, hogy a <classname>java.util</classname>
						csomagnak csupán a <classname>List</classname> és az
						<classname>Iterator</classname> osztályát használja a  
						 <classname>LabirintusKiszolgáló</classname> osztály.						
						</para></listitem>
						
						<listitem><para><emphasis>package</emphasis> jelentése, hogy egy 
						adott csomagba tartozó rész következik. Például a 
						<classname>Labirintus</classname> osztály 
						<filename>Labirintus.java</filename> forrásának első
					   <programlisting>
							<![CDATA[
package javattanitok.labirintus;
							]]>
						</programlisting>				
						utasátása azt mondja, hogy a <filename>Labirintus.java</filename>
						állomány tartalma a <classname>javattanitok.labirintus</classname>
						csomagba fog kerülni. Fontos szabály, hogy ennek megfelelően a 
						<filename>Labirintus.java</filename> állományt egy, a csomag nevének
						megfelelő
						<filename class="directory">javattanitok\labirintus</filename> könyvtárban kell
						elhelyezni.
						</para>						
						<para>						
						Ha a <filename>Labirintus.java</filename> forrásból a 
						<computeroutput>package javattanitok.labirintus;</computeroutput>
						sort kitörölnénk, a következő fordítási hibát kapnánk:
					   <programlisting>
							<![CDATA[
C:\...\Munkakönyvtár>javac javattanitok\LabirintusVilág.java
javattanitok\LabirintusVilág.java:31: cannot access javattanitok.labirintus.Labirintus
bad class file: .\javattanitok\labirintus\Labirintus.java
file does not contain class javattanitok.labirintus.Labirintus
Please remove or make sure it appears in the correct subdirectory of the classpath.
    protected Labirintus labirintus;						
							]]>
						</programlisting>				
						mert a szóban forgó sor kivétele után a <classname>Labirintus</classname>
						osztály már nem tartja magát a 
						<classname>javattanitok.labirintus</classname> csomagba
						tartozónak.						
						</para></listitem>
						
						<listitem><para><emphasis>class</emphasis> jelentése, hogy osztály
						megadása következik. Például a <classname>Szereplő</classname>
						osztályt leíró <filename>Szereplő.java</filename> állomány így kezdődik:
					   <programlisting>
							<![CDATA[
/*
 * Szereplő.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.labirintus;
/**
 * A labirintus szereplőit (kincsek, szörnyek, hős) absztraháló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1 
 * @see javattanitok.labirintus.Labirintus
 */
public class Szereplő {							
							]]>
						</programlisting>										
						</para></listitem>
						
						<listitem><para><emphasis>extends</emphasis> jelentése, hogy
						egy osztály kiterjesztése következik. A <classname>Hős</classname>
						osztályunk kiterjeszti a <classname>Szereplő</classname> osztályt, 
						ennek megfelelően a <classname>Hős</classname> forrása így kezdődik:
					   <programlisting>
							<![CDATA[
/*
 * Hős.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.labirintus;
/**
 * A labirintus hősét leíró osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.labirintus.Labirintus
 */
public class Hős extends Szereplő {
							]]>
						</programlisting>																
						</para></listitem>
												
						<listitem><para><emphasis>new</emphasis> jelentése, hogy egy új
						objektumot készít. A
						<classname>LabirintusVilág</classname> osztályban például így készül el
						a labirintus:
					    <programlisting>
							<![CDATA[
        // A labirintus elkészítése állományból
        labirintus = new Labirintus(labirintusFájlNév);
							]]>
						</programlisting>						
						A <computeroutput>new</computeroutput> használatát 
						<emphasis>példányosításnak</emphasis>
						nevezzük. Itt a <classname>Labirintus</classname> osztály olyan
						konstruktor függvényét hívtuk, amely egy állományból, a
						<varname>labirintusFájlNév</varname> nevű állományból építi fel a labirintust.						
						</para></listitem>
						
						<listitem><para><emphasis>try catch</emphasis> kijelöli a 
						megfigyelt forrásszövegrész blokkot és a kivételkezelő blokkot.
						Például a <classname>LabirintusVilág</classname> osztály szokásosan
						indul, a statikus <function>main()</function> függvényében készít
						önmagából egy objektum példányt: 
					    <programlisting>
							<![CDATA[
        try {
            
            new LabirintusVilág(args[0]);
            
        } catch(RosszLabirintusKivétel rosszLabirintusKivétel) {
							]]>
						</programlisting>						
						a <computeroutput>try</computeroutput> blokkban figyeli, hogy
						nem történt-e valami probléma (kivétel) a példányosítás során, 
						ha igen - mondjuk
						nincs meg az <varname>args[0]</varname> megnevezte, a labirintus
						tervét tartalmazó állomány - akkor a program futása a 
						<computeroutput>catch</computeroutput> kivételkezelő 						
						<computeroutput>RosszLabirintusKivétel</computeroutput> ágán
						folytatódik.
						</para></listitem>
						
						<listitem><para><emphasis>this</emphasis> jelentése: hivatkozás egy 
						osztály aktuális példányára. A <computeroutput>this</computeroutput> 
						használatára triviális példa a példánytagok beállítása
					    <programlisting>
							<![CDATA[
    public Labirintus(int szélesség, int magasság,
            int kincsekSzáma, int szörnyekSzáma) {
        
        this.magasság = magasság;
        this.szélesség = szélesség;
        ...            							
							]]>
						</programlisting>						
						Kevésbé egyszerű példa a 
						<classname>MandelbrotHalmazNagyító</classname> osztályunkban	
						szereplő
					    <programlisting>
							<![CDATA[
            public void mouseReleased(java.awt.event.MouseEvent m) {
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
                    double dx = (MandelbrotHalmazNagyító.this.b
                            - MandelbrotHalmazNagyító.this.a)
                            /MandelbrotHalmazNagyító.this.szélesség;
							]]>
						</programlisting>
						mert itt egy egéreseményekre reagáló
						<computeroutput>addMouseListener(new java.awt.event.MouseAdapter() {</computeroutput>
						névtelen objektumon belül vagyunk, így a
						<computeroutput>this</computeroutput> önmagában ezt az
						eseménykezelő objektumot jelentené, ezért minősítjük a 
						 	<classname>MandelbrotHalmazNagyító</classname>
						 	 osztálynévvel, mert nekünk az
						 	aktuális <classname>MandelbrotHalmazNagyító</classname>
						 	 objektumra van éppen
						 	szükségünk, hogy hozzáférjünk annak <varname>a</varname>,
						 	<varname>b</varname> és <varname>szélesség</varname>
						 	 tagjaihoz.					
						 	 </para>
						 	 <para>
						 	 Részletesebben olvashat a 
						 	 <computeroutput>this</computeroutput> kulcsszóról a
<emphasis><link linkend="this">Vissza az OO-hoz</link></emphasis> című részben.						 	 
						</para></listitem>
						
						<listitem><para><emphasis>super</emphasis> hivatkozik egy 
						osztály szülőjének aktuális példányára. Példáink közül
						a <classname>Pontmátrix</classname> osztályban találkozunk a
						használatával:
					    <programlisting>
							<![CDATA[
    /** A pontmátrixot tartalmazó kép kirajzolása. */
    public void paintComponent(java.awt.Graphics g) {
        
        super.paintComponent(g);
        
        if(pontmátrixKép != null)
            g.drawImage(pontmátrixKép, 0, 0, this);
    }
							]]>
						</programlisting>						
						</para></listitem>

						<listitem><para><emphasis>implements</emphasis> jelzi,
						hogy egy osztály megvalósítja egy interfész módszereit.
					    <programlisting>
							<![CDATA[
class Kiszolgáló implements Runnable {
							]]>
						</programlisting>
						A fenti, a <classname>Kiszolgáló</classname> osztályból származó
						osztálydefiníció feje mutatja, hogy a 
						<classname>Kiszolgáló</classname> osztály megvalósítja a 
						<classname>Runnable</classname> - egyébként egyetlen - 
						<function>run()</function> metódusát. Ennek megfelelően a 
						<classname>Kiszolgáló</classname> osztálynak rendelkeznie kell
						a <function>run()</function> függvény implementációjával, mint 
						ahogyan rendelkezik is:
					    <programlisting>
							<![CDATA[
    public void run() {
        
        try {
            java.io.BufferedReader bejövőCsatorna =
                    new java.io.BufferedReader(
                    new java.io.InputStreamReader(socket.getInputStream()));
            java.io.PrintWriter kimenőCsatorna =
                    new java.io.PrintWriter(socket.getOutputStream());
            
            String sor = null;
            while((sor = bejövőCsatorna.readLine()) != null) {
                
                kimenőCsatorna.println(sor);
                kimenőCsatorna.flush();
            }
            socket.close();
            
        } catch(java.io.IOException ioE) {
            ioE.printStackTrace();
        }
    }
							]]>
						</programlisting>						
						</para></listitem>
						
						<listitem><para><emphasis>return</emphasis> jelentése: 
						visszatérés függvényből.
					    <programlisting>
							<![CDATA[
public class Kincs extends Szereplő {
    /** A kincs értéke. */
    protected int érték;
...							
    /**
     * Megmondja, hogy megtalálták-e már a kincset?
     *
     * @return true ha a kincset már megtalálták, 
     * ha még nem akkor false.
     */
    public boolean megtalálva() {
        
        return megtalálva;
        
    } 
							]]>
						</programlisting>
						A fenti, a <classname>Kincs</classname> osztályból származó
						kódcsipet jól mutatja, hogy a <computeroutput>return</computeroutput>
						utasítás nemcsak kiugrik a hívott függvény végrehajtásából, hanem
						- és ez a tipikus használata - visszaadja a függvény által kiszámolt,
						megfelelő típusú értéket.
						</para></listitem>
						
						<listitem><para><emphasis>for</emphasis> jelentése az előírt lépésszámú 
						ciklus bevezetése.
						A következő, a <classname>LabirintusKiszolgáló</classname>
						osztályból származó példa végiglépked a <varname>kincsek</varname>
						lista kincsein.
					    <programlisting>
							<![CDATA[
        for(Kincs kincs : kincsek) {
            
            if(kincs.megtalalt(hős))
                hős.megtalaltam(kincs);
            
        }
							]]>
						</programlisting>						
						Klasszikusabb használatot mutat a 
						<classname>Labirintus</classname> osztályból kicsippentett,
						 alábbi kódtöredék:
					    <programlisting>
							<![CDATA[
        // Szörnyek létrehozása
        szörnyek = new Szörny[szörnyekSzáma];
        for(int i=0; i<szörnyek.length; ++i)
            szörnyek[i] = new Szörny(this);
            				]]>
						</programlisting>												
						ami a <varname>szörnyek</varname> tömbön lépked végig.
						</para></listitem>
						
						<listitem><para><emphasis>while</emphasis> jelentése, az
						elől tesztelő ciklus bevezetése. Az alábbi, a 
						<classname>TCAG2Hexa</classname> osztálybeli ciklus
					    <programlisting>
							<![CDATA[
        int i = 0;
        while((i=System.in.read()) != -1) {
            
            switch(i) {
                
                case 'T':
                    második = 0;
                    break;
                case 'C':
                    második = 1;
                    break;
                case 'A':
                    második = 2;
                    break;
                case 'G':
                    második = 3;
                    break;
            }
							]]>
						</programlisting>						
						addig olvas a <varname>System.in</varname> bemenetről, tipikusan
						a billentyűzetről, ameddig csak lehet, tehát amíg a 
						<computeroutput>while</computeroutput> után szereplő feltétel
						kiértékelése igazat ad.
						</para></listitem>
						
						<listitem><para><emphasis>do while</emphasis> jelentése a
						hátul tesztelő ciklus bevezetése. A <classname>Szereplő</classname>
						osztálybeli alábbi ciklus
						<programlisting>								
							<![CDATA[
        // Többször próbálkozunk elhelyezni a szereplőt a labirintusban,
        // számolja, hol tartunk ezekkel a próbálkozásokkal:
        int számláló = 0;
        
        do {
            // itt +2,-2-k, hogy a bal alsó saroktól távol tartsuk
            // a szereplőket, mert majd ezt akarjuk a hős kezdő pozíciójának
            oszlop = 2+véletlenGenerátor.nextInt(maxSzélesség-2);
            sor = véletlenGenerátor.nextInt(maxMagasság-2);
            // max. 10-szer próbálkozunk, de ha sikerül nem "falba tenni" a
            // szereplőt, akkor máris kilépünk:
        } while(++számláló<10 && labirintus.fal(oszlop, sor));
							]]>
						</programlisting>		
						addig próbálja elhelyezni a szereplőt a labirintusban, amíg nem
						falba teszi, de maximum 10 alkalommal próbálkozik.
						Tehát addig megy vissza a
						<computeroutput>do</computeroutput>-ra, amíg a 
						<computeroutput>while</computeroutput> után szereplő feltétel
						kiértékelése igazat ad.										
						</para></listitem>
						
						<listitem><para><emphasis>if else</emphasis> jelentése egy
						villa elágazás a végrehajtásban.
					    <programlisting>
							<![CDATA[
                // Sejt cella kirajzolása
                if(rács[i][j] == ÉLŐ)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
							]]>
						</programlisting>
						azaz vagy feketével vagy fehérrel töltjük ki a 
						<varname>j*cellaSzélesség</varname>, 
						<varname>i*cellaMagasság</varname>,
                        <varname>cellaSzélesség</varname>, 
                        <varname>cellaMagasság</varname> 
                        (bal felső sarok oszlop, sor és szélesség, magasság) 
                        adatokkal jellemzett téglalapot.
						</para></listitem>
						
						<listitem><para><emphasis>if else if else</emphasis> jelentése egy
						többirányú elágaztatás a végrehajtásban.
					    <programlisting>
							<![CDATA[
        // A billentyűzetről érkező események feldolgozása
        addKeyListener(new java.awt.event.KeyAdapter() {
            // Az 'k', 'n', 'l', 'g' és 's' gombok lenyomását figyeljük
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_K) {
                    // Felezük a cella méreteit:
                    cellaSzélesség /= 2;
                    cellaMagasság /= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    // Duplázzuk a cella méreteit:
                    cellaSzélesség *= 2;
                    cellaMagasság *= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel = !pillanatfelvétel;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_G)
                    várakozás /= 2;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_L)
                    várakozás *= 2;
                repaint();
            }
        });
							]]>
						</programlisting>						
						a kódrészlet megállapítja, hogy a program által figyelt gombokat
						nyomtuk-e le és igenlő esetben végrehajtja a megfelelő feladatot.
						Ha nem a figyelt gombok valamelyikét nyomtuk volna, akkor az utolsó
						<computeroutput>if</computeroutput>
						 nélküli 
						 <computeroutput>else</computeroutput>
						  teljesülne, de ezt most elhagytuk.
						</para></listitem>

						<listitem><para><emphasis>switch case</emphasis> jelentése több 
						lehetőség közüli választás a végrehajtásban. A korábban bemutatott
						kódrészletbeli <computeroutput>switch</computeroutput> utasítás
					    <programlisting>
							<![CDATA[
           switch(i) {
                
                case 'T':
                    második = 0;
                    break;
                case 'C':
                    második = 1;
                    break;
                case 'A':
                    második = 2;
                    break;
                case 'G':
                    második = 3;
                    break;
            }							
							]]>
						</programlisting>						
						eldönti, hogy az <varname>i</varname> a <literal>'T'</literal>,
						 <literal>'C'</literal>,
						 <literal>'A'</literal>,
						 <literal>'G'</literal> betűk közül esetlegesen melyik éppen az 
						 <varname>i</varname>.
						</para></listitem>

						<listitem><para><emphasis>break</emphasis> jelentése kiugrás
						a tartalmazó blokkból. Az alábbi <classname>ElosztottKliens</classname>
						osztályból származó sorok addig ismétlik a billentyűzetről
						való olvasást, amígcsak 
						<keycap>k</keycap> billentyűt nem nyomunk, mert
						
					    <programlisting>
							<![CDATA[
                String parancs = null;
                while((parancs = konzol.readLine()) != null) {
                    // A Hos CORBA objektum kilép a labirintusból
                    if("k".equals(parancs))
                        break;
                }
							]]>
						</programlisting>						
						annak hatására a <computeroutput>break</computeroutput>
						utasítás kilépteti a végrehajtást a ciklusból.
						</para></listitem>

						<listitem><para><emphasis>throws</emphasis> jelzi, hogy
						egy függvény milyen kivételeket dob.
						Például a <classname>Labirintus</classname> osztály a labirintust
						állományból felépítő konstruktor függvénye ilyen:
					    <programlisting>
							<![CDATA[
   /**
     * Egy megfelelő szerkezetű szöveges állományból elkészít egy új a 
     * <code>Labirintus</code> objektumot.
     *
     * @param      labirintusFájlNév       a labirintust definiáló, megfelelő 
     *                                     szerkezetű szöveges állomány neve.
     * @exception  RosszLabirintusKivétel  ha a labirintust definiáló állomány 
     *                                     nincs meg, nem a megfelelő szerkezetű, 
     *                                     vagy gond van az olvasásával.
     */
    public Labirintus(String labirintusFájlNév) throws RosszLabirintusKivétel {							
							]]>
						</programlisting>						
						</para></listitem>

						
					</itemizedlist>					
					
					</para>
					
					<para>
						Ezzel befejeztük a kulcsszavak ismertetését, a következő bekezdésben az
						<emphasis>azonosító szavak</emphasis>
						 tárgyalásával folytatjuk a Java nyelvtanának ismertetését.
						
					</para>

					<para>
					A nem számmal kezdődő és nem kulcsszó szavakat azonosítóknak nevezzük.
					Az azonosító szavak szerepe - mint nevük is mutatja - valaminek az
					azonosítása. Például a változók nevei azonosítók. A korábbi kódrészletekből
					idézve
					a 
					<computeroutput>public static final int JÁTÉK_MEGY_HŐS_RENDBEN = 0;</computeroutput>
					sorban a <varname>JÁTÉK_MEGY_HŐS_RENDBEN</varname> szó 
					azonosító. A <computeroutput>int i = 0;</computeroutput> sorban az
					<varname>i</varname> egybetűs szó azonosító, vagy mondjuk a 
					<computeroutput>labirintus = new Labirintus(labirintusFájlNév);</computeroutput>
					sorban a <varname>labirintus</varname>, a <classname>Labirintus</classname> 
					és a <varname>labirintusFájlNév</varname> szavak azonosítók. 
					A <varname>labirintus</varname> változó értéke egy referencia, az újonnan
					létrehozott <classname>Labirintus</classname> osztálybeli objektum 
					referenciája. Tehát a <varname>labirintus</varname> azonosító értékével
					ezt az új objektumot azonosítja. Ha például ezt az objektumot törölni
					akarjuk, akkor majd azt írjuk, hogy 
					<computeroutput>labirintus = null;</computeroutput> azaz a labirintus
					azonosítónak azt a <literal>null</literal>
					 értéket adjuk, ami egyetlen objektumnak sem referenciája. 
					 A <classname>Labirintus</classname> azonosító egy osztály, a labirintusunkat
					 absztraháló osztály neve, ez az azonosító például nem változó. 
					 A <varname>labirintusFájlNév</varname> nevű
					 azonosító megint csak egy változó, értéke a labirintus tervrajzát hordozó
					 állomány nevét tartalmazó karaktersorozat objektum
					  referenciája. 					        
					</para>
                

					<para>
						A Java 
						<emphasis>kifejezés szavak</emphasis>
						 lehetnek egyszerűek vagy összetettek.						
					</para>
					
					<para>
						Az 
						<emphasis>egyszerű kifejezés szavak</emphasis>
						<itemizedlist>
						<listitem><para><emphasis>a számok</emphasis>, 
						 például a <literal>42</literal>, <literal>-42</literal> vagy mondjuk a
						<classname>LabirintusVaszon</classname> osztálybeli sorokban 
					    <programlisting>
							<![CDATA[
            // A kijelző törlése
            g.setColor(0x00FFFFFF);
            g.fillRect(0, 0, getWidth(), getHeight());
            // A labirintus kirajzolása
            g.setColor(0x00ed7703);							
							]]>
						</programlisting>											
						a hexadecimális <literal>0x00FFFFFF</literal> a fehér és 
						<literal>0x00ed7703</literal> a 
						vörös=237<subscript>(10)</subscript>, 
						zöld=119<subscript>(10)</subscript>, 
						kék=3<subscript>(10)</subscript>
						színeket kódoló számok.
						</para></listitem>
						
						<listitem><para><emphasis>a karakterláncok</emphasis>, 
						minden idézőjelek közé zárt szöveg karakterlánc. Például a
						<classname>LabirintusServlet</classname> osztálybeli
						alábbi sorokban
					    <programlisting>
							<![CDATA[
        // A válasz csatornán küldött adatokat a böngésző
        // mint html oldalt értelmezze 
        httpVálasz.setContentType("text/html;charset=UTF-8");							
							]]>
						</programlisting>											
						a <literal>text/html;charset=UTF-8</literal> egy karakterlánc. 
						
						</para></listitem>

						<listitem><para><emphasis>a logikai igaz és hamis</emphasis>
						 literál értékek, az igaz <literal>true</literal> és a 
						 hamis <literal>false</literal>.
						
						</para></listitem>

						<listitem><para><emphasis>az azonosítók</emphasis> (például
						változó, függvény vagy osztály nevek) is egyszerű
						kifejezés szavak.
						</para></listitem>

						</itemizedlist>
					</para>
					
					<para>
					Az 
						<emphasis>összetett kifejezés szavakat</emphasis>
						egyszerű és összetett kifejezés szavakból építjük fel a 
						műveleti és zárójelek felhasználásával.					
					</para>

					<para>
					Az alábbi, a <classname>LabirintusKiszolgáló</classname> osztályból
					kiragadott metódus soraiból
					    <programlisting>
							<![CDATA[
    /**
     * A labirintus sztring reprezentációja. 
     *
     * @return String labirintus sztring reprezentációja.
     */
    public String toString() {
        
        return " Idő:" + idő
                + " hős:" + hősök.size()
                + " kincs:" + kincsek.size()
                + " szörny:" + szörnyek.size();
        
    }							]]>
						</programlisting>											
					a következő kiragadott szó
					    <programlisting>
							<![CDATA[
			   " Idő:" + idő
                + " hős:" + hősök.size()
                + " kincs:" + kincsek.size()
                + " szörny:" + szörnyek.size();
								 ]]>
						</programlisting>								
					egy összetett kifejezés szó. Az <computeroutput>+</computeroutput>
					 jellel összekapcsolt
					  <literal> Idő:</literal>,
					  <literal> hős:</literal>,
					  <literal> kincs:</literal>,
					  <literal> szörny:</literal>
					karakterláncokból, az <varname>idő</varname>
					  változónévből, mint egyszerű kifejezés szavakból
					és három
					 <computeroutput>változónév.függvénynév()</computeroutput> alakú, 
					 a <computeroutput>.</computeroutput> hivatkozó és a zárójellel összekapcsolt
					 összetett kifejezés szavakból épül fel. 										
					</para>

					<para>
					A kifejezés szavak értéket is hordoznak, a program futása során a most
					tárgyalt kifejezés szó értéke egy karakterlánc, mondjuk lehet éppen az 
					<computeroutput> Idő:325 hős:1 kincs:2 szörny:1</computeroutput>.
					</para>


					<para>
					Az alábbi, a <classname>Hisztogram</classname> osztályból
					kiragadott sorokban
					    <programlisting>
							<![CDATA[
            // Egy doboz kirajzolása
            g.setColor(java.awt.Color.YELLOW);
            if(maxDobozÉrték/képMagasság != 0)
                g.fillRect(i*dobozSzélesség,
                        képMagasság-dobozok[i]/(maxDobozÉrték/képMagasság),
                        képSzélesség/dobozok.length,
                        dobozok[i]/(maxDobozÉrték/képMagasság));
							]]>
						</programlisting>											
					például a 
					    <computeroutput>maxDobozÉrték/képMagasság != 0</computeroutput>
					egy összetett kifejezés szó. A <computeroutput>/</computeroutput>, a 
					szokásos aritmetikai
					és a <computeroutput>!=</computeroutput> logikai, a nem egyenlőséget
					vizsgáló
					 jellel összekapcsolt két
					  változónévből és egy számból, a nullából
					   áll. 										
					</para>

					<para>
					Értékeljük ki a szóban forgó
					<computeroutput>maxDobozÉrték/képMagasság != 0</computeroutput>
					összetett kifejezés szót! A két változó értékének
					<computeroutput>maxDobozÉrték/képMagasság</computeroutput> hányadosa
					egy szám, ha ez nullától különböző, akkor a kifejezés értéke
					<literal>true</literal>, különben <literal>false</literal>.
					</para>

                </sect5>

                <sect5 id="java_mondattana">
                    <title>A Java mondattana</title>

					<para>
					Java nyelven, 
					hasonlóan, mint például a beszélt, mondjuk magyar nyelven,  
					sokféle mondat szerkeszthető. 
					A legegyszerűbb mondatokat - ahogy már fentebb láthattuk is -  
					pontosvessző zárja le, a bonyolultabb mondatokat pedig az egyszerűbb 
					mondatokból lehet felépíteni. 				
					</para>

                    <warning>
                        <title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>
                        <para>
                            A következőkben valódi Java forráskódrészletek következnek.
                            Ne próbáljuk erőlködve értelmezni őket, a minden erőfeszítés
                            nélküli olvasásuk majd az egész kézikönyv feldolgozása után
                            valósul meg - a szerzők látomása szerint.
                        </para>
                    </warning>

					<para>
                A Java nyelv egyszerű mondatai a következők:
                <itemizedlist>
						<listitem><para>a <emphasis>deklaráló mondatok</emphasis>
						azt mondják, hogy valami legyen ez, az, ilyen, olyan. Például a 
						<classname>Pontmátrix</classname> osztálybeli 
					    <programlisting>
							<![CDATA[
    /** A pontmátrixot tartalmazó kép. */
    java.awt.image.BufferedImage pontmátrixKép;							
							]]>
						</programlisting>
						sorok 
						<computeroutput>java.awt.image.BufferedImage pontmátrixKép;</computeroutput>
						deklarációja azt mondja, hogy a <varname>pontmátrixKép</varname>
						nevű változó legyen egy olyan változó, ami értékeként
						 képes hordozni egy <classname>java.awt.image.BufferedImage</classname>
						 osztálybeli objektum referenciáját. Röviden a Java programozó azt
						 mondja majd ilyenkor, hogy a <varname>pontmátrixKép</varname>
						 egy <classname>BufferedImage</classname>. 
						</para></listitem>
						
						<listitem><para>az <emphasis>értékadó mondatok</emphasis>
						azt mondják el, hogy valaminek az értéke legyen ez, az, ennyi, annyi. 
						Például a <classname>Sejtautomata</classname> osztálybeli alábbi sorok
					    <programlisting>
							<![CDATA[
        // Cellaméretek kezdetben
        cellaSzélesség = 10;
							]]>
						</programlisting>
						10 pixel szélesre állítják a sejtautomata kirajzolt celláinak szélességét.
						</para></listitem>

						<listitem><para>a <emphasis>metódushívó mondatok</emphasis> függvényt
						hívnak,						
					    <programlisting>
							<![CDATA[
            socket.close(); 
							]]>
						</programlisting>
						a fenti, a <classname>LabirintusKiszolgálóSzál</classname> osztálybeli
						sor lezárja a kommunikációs kaput.
						</para></listitem>
						
						<listitem><para>a deklaráló, értékadó és metódusmondatokat kombinálhatjuk is.
						A <classname>Pontmátrix</classname> osztálybeli induló
					    <programlisting>
							<![CDATA[
    // A panel mérete
    java.awt.Dimension mátrixMéret =
            new java.awt.Dimension(800, 800);							
							]]>
						</programlisting>
						<varname>mátrixMéret</varname> egy <classname>Dimension</classname> és
						rögtön megadunk egy ilyen 800x800-as pixelméretű példányt is a megfelelő
						konstruktor meghívásával.
						</para>
						<para>
						De azt is megtehetjük, hogy egyszerűen csak létrehozunk egy példányt
					    <programlisting>
							<![CDATA[
        new ElosztottLabirintus();							
							]]>
						</programlisting>						
						mint ahogyan például a <classname>ElosztottLabirintus</classname>
						osztályban tettük.
						</para>
						<para>
						Vagy létrehozunk egy példányt és rögtön hívjuk is egy módszerét:
					    <programlisting>
							<![CDATA[
        new Thread(this).start();
							]]>
						</programlisting>						
						mint a <classname>LabirintusKiszolgálóSzál</classname> osztályban a
						hálózati kommunikációt elvégző szál elkészítésénél és indításánál tettük. 
						</para>						
						<para>
						Avagy éppen egy metódus visszatérési értékével inicializálunk egy
						változót, erre az alábbi példát a
					    <programlisting>
							<![CDATA[
        // Elkérjük a böngészőbe menő csatornát
        java.io.PrintWriter csatornaBöngészőbe = httpVálasz.getWriter();							
							]]>
						</programlisting>						
						<classname>LabirintusServlet</classname> osztályból kicsípve közöltük.
						</para>												
						<para>
						Végül lássunk egy komplexebb példát is:
					    <programlisting>
							<![CDATA[
            // Vagy új vagy régi a hős, a hős neve = "hoszt IP : név"
            Hős hős = hálózatiLabirintus.hős(socket.getInetAddress().getHostAddress() +
                    " : " + játékostól);
							]]>
						</programlisting>						
						amint a <classname>LabirintusKiszolgálóSzál</classname> osztályban a 
						<function>hős()</function> függvénynek átadott paramétert egy
						összetett kifejezés szóval írtuk le, a <function>hős()</function> függvénynek
						aktuális paraméterként majd ennek a szónak az értéke, például a 
						<literal>192.168.1.1 : Herkules</literal> karaktersorozat objektum
						referenciája adódik át, amit a
						<classname>HálózatiLabirintus</classname> osztály 
					    <programlisting>
							<![CDATA[
    /**
     * A hálózaton keresztül jelentkező hős elkészítése.
     *
     * @param   név     a hős neve (= "hoszt IP : név").
     * @return  Hős     a névhez tartozó, esetleg újonan létrehozott hős.
     */
    public Hős hős(String név) {	
        // Ha már létező hős jelentkezett be újra a játékba
        if(hősök.containsKey(név))
            return (Hős)hősök.get(név);
        // Vagy új játékos jön
        else {
            // aki még nincs a hősök között
            // akkor új hősként létrehozzuk
            Hős hős = new Hős(labirintus);
            // A hős kezdő pozíciója
            hős.sor(9);
            hős.oszlop(0);
            // Felvétele a hősök közé
            hősök.put(név, hős);
            
            return hős;
        }
        
    }    						
							]]>
						</programlisting>						
						majd a <classname>String</classname> típusú, <varname>név</varname>
						 nevű formális paraméterében kap meg. 
						</para></listitem>

						</itemizedlist>
					
					</para>


					<para>
                A Java nyelv összetett mondatai egyszerű és összetett mondatokból
                néhány kulcsszóval és a kapcsos zárójelek használatával képezhetők.
                Főbb összetett mondat típusok a következők:
                <itemizedlist>

						<listitem><para>a <emphasis>ha-akkor-különben mondatok</emphasis> 
						a program végrehajtásának villa elágazásait írják le.
						A korábban említett 
					    <programlisting>
							<![CDATA[
                // Sejt cella kirajzolása
                if(rács[i][j] == ÉLŐ)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
							]]>
						</programlisting>						
						példánál maradva a <varname>g</varname> 
						<classname>Graphics</classname> objektum 
						<function>setColor()</function> színbeállító függvénye
						a <varname>java.awt.Color.BLACK</varname> értékkel fog meghívódni,
						ha a rács i. sorának, j. oszlopának sejtje élő, azaz a 
						<computeroutput>rács[i][j] == ÉLŐ</computeroutput>
						feltétel értéke igaz, és <varname>java.awt.Color.WHITE</varname>
						színnel, ha nem igaz.
						</para>
						<para>
						Ha valamelyik ágon egynél több mondatot szeretnénk írni, akkor 
						ezeket a mondatokat egy kapcsos zárójelek határolta blokkba
						kell szerveznünk, mint ahogyan például az alábbi, a 
						<classname>HálózatiLabirintus</classname>
						osztálybeli sorokban láthatjuk:
					    <programlisting>
							<![CDATA[
        // Ha már létező hős jelentkezett be újra a játékba
        if(hősök.containsKey(név))
            return (Hős)hősök.get(név);
        // Vagy új játékos jön
        else {
            // aki még nincs a hősök között
            // akkor új hősként létrehozzuk
            Hős hős = new Hős(labirintus);
            // A hős kezdő pozíciója
            hős.sor(9);
            hős.oszlop(0);
            // Felvétele a hősök közé
            hősök.put(név, hős);
            
            return hős;
        }							
							]]>
						</programlisting>
						</para>
						<para>
						Nézzünk meg egy komplikáltabb példát is alább, a 
						<classname>LabirintusVaszon</classname> osztályból!
					    <programlisting>
							<![CDATA[
                if(kincsKép != null) {
                    if(!kincsek[i].megtalálva())
                        g.drawImage(kincsKép,
                                kincsek[i].oszlop()*téglaSzélesség,
                                kincsek[i].sor()*téglaMagasság,
                                javax.microedition.lcdui.Graphics.LEFT
                                |javax.microedition.lcdui.Graphics.TOP);
                } else {
                    // Ha már megvan a kics, akkor szürkébbel rajzoljuk
                    if(kincsek[i].megtalálva())
                        g.setColor(0x00d2cfb7);
                    else // Különben sárgábbal
                        g.setColor(0x00fbe101);
                    
                    g.fillRect(kincsek[i].oszlop()*téglaSzélesség,
                            kincsek[i].sor()*téglaMagasság,
                            téglaSzélesség/2, téglaMagasság);
                }			
							]]>
						</programlisting>						
						</para></listitem>
						
						<listitem><para>a <emphasis>ha-különben-ha mondatok</emphasis> 
						hasonlóak az előzőekhez, de több ága lehet a villának, a lehetőségek
						közül egy, az első fog lefutni:
					    <programlisting>
							<![CDATA[
                // A kurzor gomboknak megfelelő irányba lépéssel
                if ((billentyű & LEFT_PRESSED) != 0) {
                    hős.lépBalra();
                } else if ((billentyű & RIGHT_PRESSED) != 0) {
                    hős.lépJobbra();
                } else if ((billentyű & UP_PRESSED) != 0) {
                    hős.lépFöl();
                } else if ((billentyű & DOWN_PRESSED) != 0) {
                    hős.lépLe();
                }							
							]]>
						</programlisting>
						ebben a <classname>LabirintusVaszon</classname> osztálybeli
						példában a kapcsos zárójelekre nem is lett volna szükség, mert
						minden villa ágon csupán egyetlen utasítás van, de soha ne 
						szégyelljünk bőven bezárójelezni egy kódot. Mivel a programok
						tipikusan bonyolódni szoktak, a bőséges zárójelezés sokszor
						egyértelműbbé és átláthatóbbá teszi a forrást, ami egyben
						könnyedebb továbbfejleszthetőséget is jelent! Visszatérve a 
						példára, az <computeroutput>else</computeroutput>
						 ágat itt elhagytuk.
						</para></listitem>
						
						<listitem><para>az <emphasis>ellenőrzött mondatok</emphasis> 
						végrehajtása speciális, mert ha a mondat értelmezése során
						valamilyen kivétel keletkezik, akkor azt kezelhetjük. Például a
						<classname>Labirintus</classname> osztály kódjából kiragadott alábbi
						kódrészletben
					    <programlisting>
							<![CDATA[
            while(sor.startsWith("//"))
                sor = szövegesCsatorna.readLine();
            
            try {
                
                kincsekSzáma = Integer.parseInt(sor);
                
                sor = szövegesCsatorna.readLine();
                szörnyekSzáma = Integer.parseInt(sor);
                
                sor = szövegesCsatorna.readLine();
                szélesség = Integer.parseInt(sor);
                
                sor = szövegesCsatorna.readLine();
                magasság = Integer.parseInt(sor);
                
                szerkezet = new boolean[magasság][szélesség];
                
            } catch(java.lang.NumberFormatException e) {
                
                throw new RosszLabirintusKivétel("Hibás a kincsek, szörnyek száma, 
													szélesség, magasság megadási rész.");
                
            }							
							]]>
						</programlisting>
						addig olvasunk be sorokat a <varname>szövegesCsatorna</varname>
						csatornáról, amíg a <computeroutput>//</computeroutput> megjegyzés
						jellel kezdődő sorok el nem fogynak a labirintusunkat leíró
					    <programlisting>
							<![CDATA[
//
// labirintus.txt
//
// DIGIT 2005, Javat tanítok
// Bátfai Norbert, nbatfai@inf.unideb.hu
//
// A labirintus szerkezetét megadó állomány, szerkezete a következő:
// a kincsek száma
// a szörnyek száma
// a labirintus szélessége
// magassága
// fal=1 járat=0 ... 
// .
// .
// .
6
3
10
10
0 0 0 1 0 1 0 1 1 1
...							
							]]>
						</programlisting>
						állományunk elejéről. A
						<computeroutput>try {</computeroutput> vezeti be a megfigyelt
						forráskód blokk kezdetét. Itt olvassuk be a 6, 3, 10, 10
						számokat. Ha a második 10-et elírjuk például q0-ra, akkor a
						<computeroutput>magasság = Integer.parseInt(sor);</computeroutput>
						sor értelmezésekor egy hiba keletkezik, egy 
						<classname>NumberFormatException</classname> kivétel objektum, 
						ami után a vezérlés már
						nem kerül a következő, a 
						<computeroutput>szerkezet = new boolean[magasság][szélesség];</computeroutput>
						sorra, hanem az ennek megfelelő 
						<computeroutput>} catch(java.lang.NumberFormatException e) {</computeroutput>
						kivételkezelő ágon folytatódik, ahol megtörténik a kivétel kezelése. Jelen
						esetünkben ez a kivétel tovább dobását jelenti a jelen kódunkat hívó
						függvénynek... a kivételkezelés részletes tárgyalását majd a 
						<emphasis><link linkend="kivetelkezeles">Kivételkezelés</link></emphasis>
                        című pontban folytathatja a kedves Olvasó.						
						</para></listitem>
						
						<listitem><para>a <emphasis>ciklus mondatokkal</emphasis> 
						a ciklusokat írjuk le, csak az előírt lépésszámú ciklusra kitérve a 
						korábbi 
					    <programlisting>
							<![CDATA[
        for(Kincs kincs : kincsek) {
            
            if(kincs.megtalalt(hős))
                hős.megtalaltam(kincs);
            
        }
							]]>
						</programlisting>						
						példában a ciklus kapcsos zárójelek közé zárt magja vagy törzse
						a <varname>kincsek</varname>, egyébként <classname>Kincs</classname>
						objektumokat tartalmazó lista objektum minden tagjára lefut. Gyakorlatilag
						minden kincstől megkérdezzük, hogy rátalált-e a hősünk?
						</para>
						<para>
						A szintúgy korábbi kódtöredékben 
				    <programlisting>
							<![CDATA[
        // Szörnyek létrehozása
        szörnyek = new Szörny[szörnyekSzáma];
        for(int i=0; i<szörnyek.length; ++i)
            szörnyek[i] = new Szörny(this);
            				]]>
						</programlisting>
						az <varname>i</varname> 
						ciklusváltozót a 0 kezdőértékkel inicializáljuk, 
						ha a 
						<computeroutput>i&lt;szörnyek.length</computeroutput> igaz, akkor
						ezzel az <computeroutput>i=0</computeroutput>
						 értékkel végrehajtjuk a magot, majd következik a
						  <computeroutput>++i</computeroutput>, azaz az 
						 <varname>i</varname> értékének eggyel való megnövelése, miután újra
						megvizsgáljuk a <computeroutput>i&lt;szörnyek.length</computeroutput>
						feltételt. Ha igaz, végrehajtjuk a magot , s így tovább, egészen addig, amíg
						hamis nem lesz, mert akkor már nem hajtjuk végre a magot és a 
						vezérlés a ciklus mondat utáni következő mondatra kerül.						
						</para></listitem>
						
						<listitem><para>a <emphasis>függvény mondatok</emphasis> 
						egy függvényt definiálnak. A függvény nevét melléknevek előzik meg,
						majd kerek zárójelek között a formális paraméterei szerepelnek, amit
						a kapcsos zárójelek közé zárt függvénytörzs vagy test követ.
						A <classname>LabirintusMIDlet</classname> osztály
					    <programlisting>
							<![CDATA[
    /**
     * A MIDletet felfüggesztő életciklus metódus, azaz mit tegyünk,
     * ha egy bejövő hívás vagy SMS megzavarja a programunk futását?
     * (Most semmit, mert csupán üres testes implementációját adtuk a
     * függvénynek.)
     */
    public void pauseApp() {}							
							]]>
						</programlisting>
						függvénye az üres paraméterlistára 
						<computeroutput>()</computeroutput>
						és az üres testre
						<computeroutput>{}</computeroutput> is
						példát mutat.
						</para>
						<para>
						Nem ennyire triviális példa a <classname>Pontmátrix</classname>
						osztály 
					    <programlisting>
							<![CDATA[
    public void pillanatfelvétel(String fájlNév) {
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(pontmátrixKép, "png",
                    new java.io.File(fájlNév));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }    						
							]]>
						</programlisting>						
						függvénye, melynek már van egyetlen formális paramétere, a 
						<computeroutput>String fájlNév</computeroutput>, és a törzse sem üres:
						png képformátumban elmenti az osztály 
						<varname>pontmátrixKép</varname> <classname>BufferedImage</classname>
						példányát a paraméterként kapott állománynéven a 
						<classname>javax.imageio.ImageIO</classname> osztály statikus 
						<function>write()</function> függvényével. Érdekességként megjegyezhetjük,
						hogy a formális paramétert a hívás helyén úgy aktualizáljuk, hogy az
						átadott aktuális paraméter karaktersorozat objektumot a felhasználói
						felület egy állománykiválasztó párbeszédablakában jelöljük ki:
					    <programlisting>
							<![CDATA[
        } else if("Mentés...".equals(menü)) {
            
            javax.swing.JFileChooser betöltő = new javax.swing.JFileChooser();
            betöltő.showSaveDialog(getContentPane());
            pillanatfelvétel(betöltő.getSelectedFile().getAbsolutePath());							
							]]>
						</programlisting>						
						
						</para></listitem>
						
						<listitem><para>az <emphasis>osztály mondatok</emphasis> a
						legbővebb összetett mondatok, velük definiáljuk az osztályokat.
						Az osztály nevét melléknevek előzik meg, közvetlenül előtte a
						<computeroutput>class</computeroutput> áll,						
						illetve az osztálynév után néhány szóba jöhető kulcsszó után,
						a kapcsos zárójelek között következik az osztály törzse vagy
						 teste. Egyszerű példaként álljon itt a korábbi 
						 <classname>Szereplő</classname> osztály:
					    <programlisting>
							<![CDATA[
public class Szereplő { 							
							]]>
						</programlisting>
						Az öröklés, kiterjesztés jelzésére pedig például a 
						<classname>Hős</classname> osztály:
					    <programlisting>
							<![CDATA[
public class Hős extends Szereplő {							
							]]>
						</programlisting>
						Az Olvasó az öröklődéssel  
						<emphasis><link linkend="osztalyok_fejlodese">Az osztályok fejlődése: az öröklődés</link></emphasis> című pontban ismerkedhet majd meg részletesen.
						Végül tekintsünk egy komplexebb példát a 
						<classname>LabirintusKiszolgáló</classname> osztályt! 						
					    <programlisting>
							<![CDATA[
public class LabirintusKiszolgáló
        extends javattanitok.labirintus.TöbbHősösLabirintus
        implements LabirintusOperations, Runnable {							
							]]>
						</programlisting>
						Kiterjesztjük a másik csomagbeli <classname>TöbbHősösLabirintus</classname>
						osztályt és implementáljuk a <classname>LabirintusOperations</classname> és
						a <classname>Runnable</classname> interfészeket.
						</para></listitem>
						
						</itemizedlist>
					
					</para>


                </sect5>

				</sect4>                
				
                <sect4>
                    <title>A Java nyelv és a Java programozás között</title>

				<para>
                Alapvető fontosságú - az iménti pontok terminológiájával: függvény - mondat lesz 
                a következő. 
                <programlisting>
                    <![CDATA[
függvényNév(változók felsorolása) {

}
                    ]]>
                </programlisting>
                
                Az ilyen mondatokat függvényeknek 
                vagy metódusoknak nevezzük.                 
                </para>

                <para>A <function>függvényNév</function>
                a függvény neve, ezt követi egy kerek zárójelek közötti változó-felsorolás
                - a függvény formális paramétereinek megadása - ami ugyan akár el is maradhat, majd egy kapcsos zárójelpár következik, ami további mondatokat tartalmazhat. 
                </para>
                
                <para>
                    A függvények tipikus hivatása, hogy kiszámoljanak és visszaadjanak
                    hívóiknak valamilyen típusú eredményt. Ezt így írjuk le:
                <programlisting>
                    <![CDATA[
EredményTípus függvényNév(változók felsorolása) {

}
                    ]]>
                </programlisting>
                    Ha a függvény nem ad vissza értéket a hívónak, akkor azt a 
                    <computeroutput>void</computeroutput> kulcsszó szerepeltetésével
                    kell jeleznünk:
                <programlisting>
                    <![CDATA[
void függvényNév(változók felsorolása) {

}
                    ]]>
                </programlisting>                    
                </para>
                
                <para>Még a függvények leírásánál is alapvetőbb mondatok
                az osztályok definícióját leíróak - mint ahogyan a 
                <classname>Labirintus</classname> osztály kapcsán az imént 
                láttunk erre egy konkrét példát  -  ezeknek a mondatoknak 
                általános szerkezete a következő:</para>

                <programlisting>
                    <![CDATA[
class OsztályNév {

}                    ]]>
                </programlisting>
                
                <para>A kapcsos zárójelek közé jöhetnek az osztály által leírt dolog tulajdonságait megadó egyszerű Java nyelvű mondatok, vagy függvények. </para>

				</sect4>
				</sect3>

                <sect3>
                    <title>Vissza az OO-hoz</title>

                <sect4 id="objektumok_letrehozasa">
                    <title>Objektumok létrehozása: a konstruktor</title>
                    
                    <para>
                        Egy osztály függvényei között a 
                        <emphasis>konstruktornak</emphasis> nevezett
                        függvények speciális rendeltetésűek, feladatuk 
                        az osztályból származó objektumok felépítése.
                    </para>
                    
                    <para>A konstruktor függvény neve megegyezik az osztály nevével:</para>

                    <para>
                    <programlisting>
                        <![CDATA[
Labirintus(int szélesség, int magasság) {

}
                        ]]>
                    </programlisting>
                        Vegyük észre, hogy a konstruktor függvényeknek nincs
                        valamely kiszámolt értéket visszaadó visszatérési értéke, s
                        a <computeroutput>void</computeroutput> kulcsszó sem
                        szerepel a függvény fejének leírásában.
                    </para>
                                        
                    <para>A paraméterként kapott két egész szám a létrehozandó új 
                    <classname>Labirintus</classname> objektum szélessége és magassága. 
                    Tegyük fel, hogy van egy programunk, ami használni akar egy labirintust
                    és a program éppen most érkezik ahhoz a ponthoz, ahol szüksége 
                    van a labirintusra! Ekkor példányosít a <classname>Labirintus</classname>
                    osztályból, azaz le fog futni a <classname>Labirintus</classname>
                    osztály konstuktora. Gondoljunk bele, mit kell végrehajtania a konstruktornak? </para>

                    <para>A paraméterként kapott szélességet és magasságot be kell állítania a létrehozandó új labirintus objektumban, majd létre kell hoznia az ennek a két számnak megfelelő méretű labirintus szerkezetet. A kapott szélesség és magasság tulajdonság beállítása azért fontos feladat, mert a létrehozandó új labirintus objektumnak ezt a két számot tudnia kell magáról, mindig tudnia, nem csupán a megfelelő méretű labirintus szerkezet létrehozásakor. Írjuk le ezt Java nyelven:</para>

                    <programlisting>
                        <![CDATA[
Labirintus(int szélesség, int magasság) {
    
    this.szélesség = szélesség;
    this.magasság = magasság;
    szerkezet = new boolean[szélesség][magasság];    
        
}                        ]]>
                    </programlisting>
                    
                    <para id="this">
                        Látható, hogy az osztály definíciójában szereplő <varname>szélesség</varname> és <varname>magasság</varname> változónevek megegyeznek a konstruktor függvény paramétereinek nevével, hogy biztosan a létrehozandó új labirintus objektum szélességét és magasságát állítsuk be. Ezért az első két értékadásnál a <computeroutput>this</computeroutput> operátorral minősítjük a változóneveket, ami annyit jelent, hogy a változónév elé írjuk, hogy <computeroutput>this</computeroutput>: ezzel megkülönböztetve a függvényben lévő ugyanilyen nevű változóktól. A <computeroutput>this</computeroutput> mindig az aktuális, azaz jelen esetben a létrehozandó új objektumot jelenti. Hiszen a fejlesztés során a programozó szinte mindig valamely osztály viselkedését írja, eközben az jár a fejében, hogy ebből az osztályból egy példány fog létrejönni, akinek az éppen programozott élethelyzetében a most éppen begépelt viselkedést kell mutatnia...  -  ez az „akinek példány” a 
                        <computeroutput>this</computeroutput>.

                        <inlinemediaobject>
                            <objectinfo>
                                <title>A konstruktor függvény lokális, paraméterlistája magasság változójának és a
                                Labirintus objektum magasság változójának cím komponense különböző. </title>
                            </objectinfo>                            
                            <imageobject>
                                <imagedata fileref="images/labirintus/labirintus6.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Egy Labirintus osztálybeli objektum elképzelése.</phrase>
                            </textobject>
                        </inlinemediaobject>

                    </para>
                    
                    <para>
                        A következő, a <computeroutput>new</computeroutput> operátort használó utasítás létrehozza a megfelelő méretű kétdimenziós logikai tömböt, azaz a memóriában lefoglal annyi helyet, ahol ez a szerkezet elfér, és logikai celláit automatikusan feltölti hamis értékekkel. (De az igazi paranoiás programozó az ilyen automatikus értékekkel nem foglalkozik, hanem mindig maga adja meg azokat... de erre még nem most, hanem majd később látunk példát!)

                    <programlisting>
                        <![CDATA[
szerkezet = new boolean[szélesség][magasság];    
                        ]]>
                    </programlisting>

                    </para>
                                        
                    <para>
                        Saját labirintus osztályunkból ugyancsak a <computeroutput>new</computeroutput> operátorral tudunk példányosítani. Visszatérve feltevésünkhöz, hogy van egy programunk, ami használni akar egy labirintust... és a program éppen most érkezik ahhoz a ponthoz, ahol szüksége van a labirintusra, ekkor éppen a következő sort hajtja végre:
                    
                    <programlisting>
                        <![CDATA[
Labirintus labirintus = new Labirintus(10, 10);
                        ]]>
                    </programlisting>
                    
                    </para>

                    <para>Ekkor a kis <varname>labirintus</varname> azonosítót a létrehozott, új labirintus objektum referenciájának is nevezzük (egészen pontosan az azonosító, a 
                    <varname>labirintus</varname> nevű változó értéke a referencia). Az objektum tulajdonságaira a referencia után írt ponttal hivatkozhatunk, azaz 
                    a <computeroutput>labirintus.szélesség</computeroutput> a létrehozott, új labirintus objektumbeli szélességet jelenti.</para>
                    <para>Összegezzük eddigi erőfeszítéseinket egyetlen forrásban:</para>
                    
                    <programlisting>
                        <![CDATA[
class Labirintus {

    int szélesség;
    int magasság;
    boolean[][] szerkezet;
    
    Labirintus(int szélesség, int magasság) {
    
        this.szélesség = szélesség;
        this.magasság = magasság;
        szerkezet = new boolean[szélesség][magasság];    
        
    }
    
    static main() {

        Labirintus labirintus = new Labirintus(10, 10);

    }
    
}
                        ]]>
                    </programlisting>
                    
                    <para>Java programjaink végrehajtása a <function>main()</function> függvénnyel kezdődik  -  most egyetlen feladataként  -  benne példányosítjuk a létrehozandó új labirintus objektumunkat. Tehát mivel most akarjuk létrehozni a labirintus objektumot, így nyilván még nem létezik, akkor mégis hogyan futhat a <function>main()</function> metódus? Ezért van a 
                    <computeroutput>static</computeroutput> módosító kulcsszó! A <computeroutput>static</computeroutput>
                    kulcsszó azt jelenti, hogy a függvény nem az osztály példányaihoz, hanem magához az osztályhoz tartozik, azaz anélkül is meg lehet hívni, hogy az őt tartalmazó osztályból példányosítanánk.</para>
                    <para>Készítsük most el programunk olyan változatát, amit akár már le is fordíthatunk, futtathatunk:</para>
                    
                    <programlisting>
                        <![CDATA[
class Labirintus {

    int szélesség;
    int magasság;
    boolean[][] szerkezet;
    
    Labirintus(int szélesség, int magasság) {
    
        this.szélesség = szélesség;
        this.magasság = magasság;
        szerkezet = new boolean[szélesség][magasság];    
        
    }
    
    public static void main(String[] args) {

        Labirintus labirintus = new Labirintus(10, 10);

    }
    
}
                        ]]>
                    </programlisting>
                    
                    <para>A <function>main()</function> függvényt most abban a 
                    formában használtuk, amelyben mindig szerepelnie kell, a 
                    <computeroutput>void</computeroutput> kulcsszó jelzi, 
                    hogy a függvény nem ad vissza semmilyen értéket. 
                    A <computeroutput>public</computeroutput> módosító kulcsszó pedig arra utal, hogy hogyan látszik az osztályunkon kívülről a függvény. A <computeroutput>public</computeroutput> azt jelenti, hogy mindenhonnan látszik. A finomságokat majd később részletezzük, most annyit jegyezzünk meg, hogy a <function>main()</function> függvényt mindig így használjuk. Azt persze még megemlíthetjük, hogy más formában nem is használhatjuk, mert eltérés esetén az osztályunkat nem tudjuk lefordítani. A <function>main()</function> paraméterét a következő feladat után tárgyaljuk.</para>

                    <para>Tehát itt az idő, próbáljuk is ki ezt az osztályt!</para>

                    <screen>
                            <![CDATA[
C:\...> javac Labirintus.java
C:\...> java Labirintus
                            ]]>
                    </screen>                    
                    
                    <para>Sok látványos dolog nem történt, a program indítása után gyorsan visszaadta a promptot és kész. Megérte feldolgozni ezt a sok oldalt eddig, ennyiért? Hogyne, hiszen pici módosítással szóra bírhatjuk a <classname>Labirintus</classname> osztálybeli objektumunkat. Módosítsuk így az indítófüggvényt:</para>
     
                    <programlisting>
                        <![CDATA[
public static void main(String[] args) {

    Labirintus labirintus = new Labirintus(10, 10);

    System.out.println(labirintus.magasság);

}                        
                        ]]>
                    </programlisting>
                                   
                    <para>A <filename>Labirintus.java</filename> forrásállomány módosítása után azt újra lefordítva és az osztályt futtatva:</para>

                    <screen>
                            <![CDATA[
C:\...> javac Labirintus.java
C:\...> java Labirintus
10
                            ]]>
                    </screen>                    
                    
                    <para>Sikerrel kiírattuk a labirintus magasságát.</para>

                    <sect5>
                        <title>Példánytag elérése osztályszintű függvényből feladat</title>
                        
                        <para>A fordítás-futtatás-(bosszankodás) munkamenet begyakorlásaképpen, írassuk ki a labirintus szélességét is, módosítsuk a <function>main()</function> függvényt így:</para>
                    
                        <programlisting>
                            <![CDATA[
public static void main(String[] args) {

    Labirintus labirintus = new Labirintus(10, 10);

    System.out.println(labirintus.szélesség);
    System.out.println(labirintus.magasság);

}
                            ]]>
                        </programlisting>
                    
                        <para>Mi történik az alábbi módosítás esetén, azaz ha a méretet megadó változóneveket nem a labirintus példány referenciája után írjuk, hanem csak úgy egyszerűen ki akarjuk íratni őket:</para>
                    
                        <programlisting>
                            <![CDATA[
public static void main(String[] args) {

    Labirintus labirintus = new Labirintus(10, 10);

    System.out.println(szélesség);
    System.out.println(magasság);

}
                            ]]>
                        </programlisting>
                    
                        <para>Ekkor a futtatásig már el sem jutunk, mert a forrás nem fordul! A NetBeans környezet rögtön a leírása után jelzi a hibát, a parancssort használó pedig ezt fogja látni, amikor megpróbálja lefordítani a forrást:</para>

                    <screen>
                            <![CDATA[
C:\Documents and Settings\norbi> javac Labirintus.java
Labirintus.java:19: non-static variable szélesség cannot be referenced from 
a static context
        System.out.println(szélesség);
                           ^
                           ]]>
                    </screen>                    
                    
                        <para>Ez fontos hiba, amibe eleinte sokszor belefut a kezdő Java OO programozó Olvasó, de gyorsan ki lehet nőni. Pontosan azt mondja, hogy a <filename>Labirintus.java</filename> forrásállományom 19. sorában a példányokhoz, és nem az osztályhoz tartozó változót osztályhoz, és nem példányhoz kapcsolódó környezetben akarok használni. Ez valóban nem értelmezhető, hiszen az indító függvényem egyetlen példányhoz sem tartozik, sőt direkt azért van, mert amikor ő indul, akkor még nincsenek példányok, majd pont ő hozza létre az elsőt vagy az elsőket. Ha pedig nincs példányom, akkor hogyan is akarhatom kiíratni egy példány szélességét! Mindaddig, amíg ezt a hibát nem érezzük logikusnak, filozofáljunk el a példány és az osztály különbözőségén!</para>
                        <para>Visszatérve a példa fősodrához: a létrehozandó új labirintus objektum már tudja magáról saját méretét, megvan az ennek a méretnek megfelelő méretű labirintus szerkezetet
                         hordozni képes adatszerkezet, azaz a megfelelő kétdimenziós logikai tömb, de maga a szerkezet még nincs meg. Megadhatnánk ezt téglánként:</para>
                    
                        <programlisting>
                            <![CDATA[
Labirintus(int szélesség, int magasság) {

    this.szélesség = szélesség;
    this.magasság = magasság;
    szerkezet = new boolean[szélesség][magasság];    

    szerkezet[0][0] = true; szerkezet[0][1] = true; ...
    szerkezet[1][0] = true; szerkezet[1][1] = false; ...
    .
    .
    .   
}                            
                            ]]>
                        </programlisting>
                    
                        <para>De ezzel több probléma is van. Láthatóan nagy méret esetén egyik a nehézkesség, nem is beszélve a labirintus szerkezetének módosíthatóságáról. A másik alapvetőbb, hogy előre a forrásszöveg írásakor nem tudjuk, hogy a ...-ok helyére hány oszlopnyi és hány sornyi konkrét szerkezeti cella megadás kellene. Mert ez nem dől el a fordítási, hanem csak a futási időben, amikor a Java Virtuális Gép végrehajtja a </para>
                    
                        <programlisting>
                            <![CDATA[
Labirintus labirintus = new Labirintus(10, 10);
                            ]]>
                        </programlisting>
                    
                        <para>példányosítást, a konkrét labirintus létrehozását.</para>
                        <para>Válasszunk más megoldást! Nem túl általános, de annál egyszerűbb megoldásként lássuk el az osztályt egy olyan konstruktorral is, ami fix méretű labirintust csinál. Mivel a méret fix, így a konstruktornak nem szükségesek paraméterek:</para>
                    
                        <programlisting>
                            <![CDATA[
Labirintus() {
        
        szerkezet = new boolean[][]{
            
            {false,false,false,true,false,true,false,true,true,true},
            {false,false,false,false,false,false,false,false,false,false},
            {true,false,true,false,true,false,true,false,true,false},
            {false,false,false,false,true,false,true,false,false,false},
            {false,true,true,false,false,false,true,true,false,true},
            {false,false,false,false,true,false,false,false,false,false},
            {false,true,false,false,false,true,false,true,true,false},
            {false,false,false,true,false,true,false,true,false,false},
            {false,true,false,false,false,false,false,false,false,true},
            {false,false,false,false,true,false,false,false,true,true}
        };
        
        magasság = szerkezet.length;
        szélesség = szerkezet[0].length;
        
    }
                            ]]>
                        </programlisting>
                    
                        <para>Most a logikai tömb elkészítésekor azt is megmondtuk, hogy a tömb logikai celláit milyen logikai értékkel akarjuk feltölteni. Amikor a tömb elkészült, a szélességet és a magasságot már tőle kérjük el:</para>
                    
                        <programlisting>
                            <![CDATA[
magasság = szerkezet.length;
szélesség = szerkezet[0].length;
                            ]]>
                        </programlisting>
                    
                        <para>Hogy teljesen világos legyen, jöjjön a következő ábrán egy kis tömbológia.
                        
                            <inlinemediaobject>
                                <objectinfo>
                                    <title>A kétdimenziós tömb olyan egydimenziós tömb, aminek elemei
                                    egydimenziós tömbök.</title>
                                </objectinfo>                                
                                <imageobject>
                                    <imagedata fileref="images/labirintus/labirintus7.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>Labirintus tömbológia.</phrase>
                                </textobject>
                            </inlinemediaobject>

                        </para>
                        <para>A kétdimenziós tömb egydimenziós tömbökből áll, példánknál maradva: a <varname>szerkezet</varname> egy olyan tömb, aminek elemei (az ábrán a sorok) megint csak tömbök, így jön ki a két dimenzió. </para>

                        <para>A
                                            
                        <programlisting>
                            <![CDATA[
szerkezet.length;
                            ]]>
                        </programlisting>
                        
                        megadja a tömb méretét, hogy hány eleme van, azaz most, hogy hány sora van, hogy hány tömb eleme van. A

                        <programlisting>
                            <![CDATA[
szerkezet[0].length;
                            ]]>
                        </programlisting>
                        
                        megadja az első (azaz a 0.) elem méretét, az elem most tömb, mérete annyi, ahány eleme van, azaz most, ahány logikai érték van egy sorban: tehát az oszlopok száma.                         
                        </para>
                        <para>Begyakorolandó a kétdimenziós tömb bejárását a 
                        <emphasis><link linkend="vezerlesi_szerkezetek">Vezérlési szerkezetek</link></emphasis>                        
                        című pontban azzal folytatjuk, hogy kiíratjuk az argumentum nélküli konstruktorral készített tömb szerkezetét.</para>
                        <para>A konstruktorokhoz visszatérve, válasszunk további más megoldást! A labirintus elképzelése során, a négyzethálós lapon egy kétdimenziós tömb alakjában rajzoltuk le a labirintus szerkezetét. Készítsünk el egy ennek a rajznak megfelelő szöveges állományt és osztályunkat lássuk el egy olyan konstruktorral, ami képes ezt beolvasni! Ekkor majd így példányosítjuk a labirintus objektumunkat:</para>

                        <programlisting>
                            <![CDATA[
Labirintus labirintus = new Labirintus("labirintus.txt");
                            ]]>
                        </programlisting>
                        
                        <para>A szélességgel, magassággal kapcsolatban nem adunk át infót a konstruktornak, hiszen ezt a két számot a labirintus rajzából, azaz majd az állományból is meg tudja állapítani maga a konstruktor is. Viszont paraméterként adjuk a konstruktornak a tervrajznak megfelelő szöveges állomány nevét. Ennek az új konstruktornak az elkészítését 
                        <emphasis><link linkend="labirintust_fajlbol">A labirintust állományból felépítő konstruktor</link></emphasis>                        
                        című pontjában folytatjuk.</para>
                        
                        </sect5>
                        
                        <sect5 id="sajat_szereplok">
                            <title>Saját szereplők feladat</title>
                            
                        <para>A labirintusunk kincseit, szörnyeit és hősünket az a közös tulajdonság jellemzi, hogy valahol vannak a labirintusban. Helyzetüket egy számpárral írhatjuk le:</para>
                                            
                        <programlisting>
                            <![CDATA[
int oszlop;
int sor;
                            ]]>
                        </programlisting>
                        
                        <para>ennek megfelelően, például a
                        <classname>Szereplő</classname> nevű Java osztályba foglalva írhatjuk, hogy</para>
                                            
                        <programlisting>
                            <![CDATA[
class Szereplő {

  int oszlop;
  int sor;

}                            ]]>
                        </programlisting>
                        
                        <para>Milyen lényeges jellemzőik legyenek még a szereplőknek? Azaz hogyan alakítsuk ki, álmodjuk meg a játék világát, a labirintus játék programunk mikrokozmoszát? Milyen szereplőink lesznek, avagy amiért szép a játékfejlesztés, e kérdés itt így is feltehető: milyen szereplőink legyenek?</para>
                        <para>A kincsnek mondjuk legyen értéke:</para>
                                            
                        <programlisting>
                            <![CDATA[
int érték;
                            ]]>
                        </programlisting>
                        
                        <para>a hősnek pontszáma, amiben a már összeszedett kincsek értékeit gyűjti majd: </para>
                                            
                        <programlisting>
                            <![CDATA[
int megtaláltÉrtékek;
                            ]]>
                        </programlisting>
                        
                        <para>Adott kincsről azt is tudnunk kell, hogy megtalálta-e már a hős vagy sem?</para>
                                            
                        <programlisting>
                            <![CDATA[
boolean megtalálva;
                            ]]>
                        </programlisting>

                        <para>
                            S lehet hosszan tervezgetni, rajzolgatni..., megint áttervezni,
                             az egészet a papírkosárba dobni és párszor ezt újra elismételni.
                        </para>

                        <para>Ha azt akarjuk, hogy a <classname>Kincs</classname> osztályunk objektumai minden olyan jellemzővel rendelkezzenek, mint amikkel az általánosabb <classname>Szereplő</classname> osztálybeli objektumok (vagy aki fonákkal gondolkozik: a <classname>Kincs</classname> nem más, mint egy speciális <classname>Szereplő</classname>), akkor a <classname>Kincs</classname> osztállyal ki kell terjesztenünk a <classname>Szereplő</classname> osztályt, ekkor Javaban ezt írjuk:
                    
                            <programlisting>
                                <![CDATA[
class Kincs extends Szereplő {

  int érték;
  boolean megtalálva;

}
                                ]]>
                            </programlisting>
                        
                        </para>

                        <para>Ekkor a <classname>Kincs</classname> osztályból példányosított objektumok a <classname>Szereplő</classname> osztály tulajdonságaival is rendelkezni fognak, így végeredményben egy <classname>Kincs</classname> osztálybeli objektum a következő tulajdonság tagokkal fog rendelkezni:
                    
                            <programlisting>
                                <![CDATA[
int oszlop;
int sor;
int érték;
boolean megtalálva;
                                ]]>
                            </programlisting>
                        
                        </para>
                        
                        <para>Ilyenkor azt is szoktuk mondani, hogy a <classname>Kincs</classname> osztály gyermeke a <classname>Szereplő</classname> osztálynak, vagy megfordítva, hogy a <classname>Szereplő</classname> osztály őse a <classname>Kincs</classname> osztálynak.</para>
                        <para>A szereplők feladat arról szól, hogy mindenki képzelje el saját labirintusa szereplőit! Milyen további tulajdonságokat tudunk elképzelni? Válaszunkat a saját <classname>Kincs</classname>, <classname>Hős</classname>, <classname>Szörny</classname> osztályainkban fogalmazzuk meg! Mi magunk ennek a feladatnak a megoldását  
                        <emphasis><link linkend="osztalyok_fejlodese">Az osztályok fejlődése: az öröklődés</link></emphasis>
                        című fejezetben adjuk meg, folytatva az itt megkezdett öröklődéssel kapcsolatos kérdések boncolgatását.</para>
                        <para>Milyen konstruktorral szereljük fel a <classname>Szereplő</classname> osztályt? Először is, a labirintus szereplőit el kell valahová helyeznünk a labirintusban, ezt  nehezíti, hogy nem tehetjük őket bárhová, legalábbis a falba nem, hanem csak járatba, azaz a labirintus olyan pozíciójára, ami nem fal! Ebből a gondolatból következően már érezzük, hogy a <classname>Szereplő</classname> és a <classname>Labirintus</classname> között van egy erős kapcsolat. A programtervező feladata ezt a kapcsolatot valamilyen formában elkészíteni. Mi most azt a megoldást választjuk, hogy a <classname>Szereplő</classname> osztálybeli objektumnak 
                        átadjuk annak a <classname>Labirintus</classname> osztálybeli objektumnak a referenciáját, amibe éppen bele akarjuk helyezni, azaz a <classname>Szereplő</classname> osztálybeli konstruktorunkat így írjuk meg:
                    
                        <programlisting>
                                <![CDATA[
class Szereplő {

  int oszlop;
  int sor;   
  Labirintus labirintus;

  Szereplő(Labirintus labirintus) {

        this.labirintus = labirintus;
        szereplőHelyeKezdetben();

    }

}
                                ]]>
                       </programlisting>
                    </para>                        
                </sect5>
                </sect4>
                
                <sect4>
                    <title>Objektumok kommunikációja: a metódushívás</title>
                    
                    <para>
                        A tipikus OO program az egymással kölcsönható objektumok
                        összessége. Az objektumok közötti kölcsönhatás, kommunikáció
                        az objektumok metódusainak hívásán keresztül valósul meg.
                        Ha egy objektumnak üzenni akarunk, ha egy objektum valamely
                        szolgáltatását akarjuk igénybe venni vagy 
                        egészen egyszerűen szólva meg akarjuk hívni egy objektum
                        valamely függvényét, metódusát, akkor nem kell mást
                        tennünk, mint leírni az objektum referenciáját, azt
                        követően egy pontot, majd a metódus nevét magát. Például
                        korábban tárgyaltuk, hogy a 
                        <varname>System.out</varname>, azaz a
                        <classname>System</classname>
                        osztálybeli <varname>out</varname> tag egy
                        <classname>PrintStream</classname> osztálybeli 
                        objektum referenciáját, azaz a mindenkori programunkhoz 
                        rendelt 
                        sztenderd kimenő csatorna objektum referenciáját tartalmazza.
                        Ha ennek az objektumnak akarok üzenni, például mondjuk 
                        azt, hogy 
                        írja ki a <literal>Helló, Világ!</literal> szöveget, akkor
                        a <classname>PrintStream</classname> osztály
                        <function>println()</function> függvényét kell használnom
                        a referencia utáni pontot követően írva tehát:
                        
                        <programlisting>
                            <![CDATA[
System.out.println("Helló, Világ!");
                            ]]>
                        </programlisting>
                        
                        Nézzünk még néhány további példát a metódushívásra a 
                        <classname>Labirintus</classname> osztályból! Az
                        i. kincstől megkérdezzük, hogy megtalálta-e a hős.

                        <programlisting>
                            <![CDATA[
            // A hős rátalált valamelyik kincsre?
            if(kincsek[i].megtalált(hős))
                hős.megtaláltam(kincsek[i]);                            
                            ]]>
                        </programlisting>
                        Ha igen, akkor a hősnek átadjuk a megtalált kincset.

		A következő ciklusban az összes szörny lép egyet a hős felé:

                        <programlisting>
                            <![CDATA[
        for(int i=0; i < szörnyek.length; ++i) {
            
            szörnyek[i].lép(hős);
                            ]]>
                        </programlisting>

                        
                        
                    </para>
                                        
                </sect4>
                
                <sect4 id="osztalyok_fejlodese">
                    <title>Az osztályok fejlődése: az öröklődés</title>
                    
                    <para>Folytatjuk a játék világát absztraháló, 
                    a 
                    <emphasis><link linkend="sajat_szereplok">Saját szereplők feladat</link></emphasis>
                    feladatban megkezdett osztályhierarchia felépítését. Ott hagytuk abba, hogy a hős a megtalált kincsek értékeit a <varname>megtaláltÉrtékek</varname> változójában gyűjtögeti majd.
                    
                        <programlisting>
                                <![CDATA[
class Hős extends Szereplő {
    int megtaláltÉrtékek;
    Hős(Labirintus labirintus) {
        super(labirintus);
        megtaláltÉrtékek = 0;
    }    
    public void megtaláltam(Kincs kincs) {        
        megtaláltÉrtékek += kincs.érték();        
    }
                                ]]>
                       </programlisting>
                       A <classname>Hős</classname> osztály példányát felépítő 
                       <computeroutput>Hős(Labirintus labirintus)</computeroutput>
                       konstruktor első dolga az ős, a <classname>Szereplő</classname> osztály
                       <computeroutput>Szereplő(Labirintus labirintus)</computeroutput>
                       konstruktorának meghívása - ezt eredményezi a 
                       <computeroutput>super(labirintus);</computeroutput>
                        hívást tartalmazó első sor. Az ős korábban bemutatott konstruktora 
                        beállítja a 
                        <varname>labirintus</varname>-t és elhelyezi a hős szereplőt
                         valahová ebbe a labirintusba. Majd a <classname>Hős</classname>
                         osztály <varname>megtaláltÉrtékek</varname> tagja kapja meg
                         a <literal>0</literal> kezdőértékét.
                         A <varname>megtaláltÉrtékek</varname> tagot az 
                         osztály <function>megtaláltam()</function> módszerével növeli a
                         paraméterként jövő, épp megtalált kincs értékével.
                    </para>                        
                    
                    <para>
                    Építsük tovább a hősünket absztraháló osztályt! Legyen a hősnek néhány élete,
                    kezdetben mondjuk <varname>ÉLETEK_SZÁMA</varname> darab, és minden esetben, amikor
                    hősünket megeszik a labirintusban, ez az érték csökkenjen eggyel! Ennek a 
                    tulajdonságnak a hordozására felveszünk egy <varname>életekSzáma</varname>
                    egész típusú változót, amit az <varname>ÉLETEK_SZÁMA = 5</varname> konstans
                    értékkel inicializálunk:
                        <programlisting>
                                <![CDATA[
class Hős extends Szereplő {
    int megtaláltÉrtékek;
    
    public static final int ÉLETEK_SZÁMA = 5;
    int életekSzáma = ÉLETEK_SZÁMA;
    
    Hős(Labirintus labirintus) {
        super(labirintus);
        megtaláltÉrtékek = 0;
    }    
    public void megtaláltam(Kincs kincs) {        
        megtaláltÉrtékek += kincs.érték();        
    }
    
    public boolean megettek() {
        
        if(életekSzáma > 0) {
            --életekSzáma;
            return false;
        } else
            return true;        
    }                                    
                                ]]>
                       </programlisting>
                       Az osztály a <function>megettek()</function> nevű 
                       viselkedésében kezeli a felvett <varname>életekSzáma</varname>
                       tagját. A függvény visszatérési értékével jelzi, hogy él-e
                       még egyáltalán a hős.
                    </para>
                    
                    <para>
                    A <classname>Hős</classname> osztály végleges formáját a                     
                            <emphasis><link linkend="hos_java">A Hős osztály</link></emphasis>
                            című pontban tanulmányozhatja az Olvasó.
                    </para>

                    <para>
                    A például a <citation>SOMMERVILLE KÖNYV</citation> könyvben 
                    bemutatott UML jelöléseit használva az alábbi osztálydiagrammal
                    foglaljuk össze és fejlesztjük tovább terveinket.
                    </para>

                <para>
                    <inlinemediaobject>
                        <objectinfo>
                            <title>A labirintus API osztálydiagrammjának szereplőkkel
                            kapcsolatos részlete.</title>
                        </objectinfo>
                        <imageobject>
                            <imagedata fileref="images/labirintus/osztalyd.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A labirintus API osztálydiagrammjának részlete.</phrase>
                        </textobject>
                    </inlinemediaobject>
                    </para>

                    <para>
                    A kézikönyvhöz készített osztályok közötti összes öröklési kapcsolatot
                    könnyen megtalálhatja az érdeklődő Olvasó, ha elugrik 
                    <emphasis><link linkend="pelda_csomagok">A csomagok szervezése</link></emphasis>
                    című pontra, ahol az osztálynevek 
                    (a <command>javadoc</command> paranccsal készített Java dokumentáció
                    mintájára)
                     tabulált szedésével jeleztük az öröklődést:
                    
                        <programlisting>
                                <![CDATA[
java.lang.Object
    javattanitok.labirintus.Labirintus
        javattanitok.labirintus.GenerikusLabirintus
        javattanitok.labirintus.TöbbHősösLabirintus
    javattanitok.labirintus.Szereplő
        javattanitok.labirintus.Hős
        javattanitok.labirintus.Kincs
        javattanitok.labirintus.Szörny
    java.lang.Throwable (implements java.io.Serializable)
        java.lang.Exception
            javattanitok.labirintus.RosszLabirintusKivétel                                
                                ]]>
                       </programlisting>
                       vagy ugyaninnen, de néhány oldallal későbbről idézve:
                       
                        <programlisting>
                                <![CDATA[
    javax.microedition.lcdui.game.GameCanvas
         javattanitok.LabirintusVaszon (implements java.lang.Runnable)
    javattanitok.HálózatiLabirintus (implements java.lang.Runnable)
         javattanitok.KorbásLabirintus
         javattanitok.TávoliLabirintus (implements javattanitok.TávoliHősíthető)
    javax.servlet.http.HttpServlet
         javattanitok.LabirintusServlet
                                ]]>
                       </programlisting>
                                            
                    </para>


<para>
A labirintus példák absztrahálta világok bonyolódásával a világokat leíró osztályokat is
fejlesztenünk kellett egészen addig, hogy a hálózati labirintus világában az
addig használt labirintus már nem volt megfelelő. Mivel ebben a világban 
egy hős halála immár nem jelentette egyben a labirintus játék végét is, hiszen a 
hálózaton keresztül jövő többi hős egyikük halálától függetlenül még nyugodtan 
bolyongana tovább a 
labirintusban. A hálózati labirintus részletes kifejtését a 
<emphasis><link linkend="labirintus_socket">TCP/IP - Hálózati Labirintus</link></emphasis>
 című pontban találjuk meg. 
</para>

<para>
Természetes az a gondolat, hogy ennek a bonyolultabb világnak az absztrahálásához
szükségünk lenne a szokásos labirintusra, de annyi módosítással, hogy most már a 
bolyongó hős halála ne jelentse a labirintus állapotának drasztikus megváltozását.
A megoldás, hogy a régi osztály kiterjesztésével új osztályt készítünk, azaz
új osztályunkat a <classname>TöbbHősösLabirintus</classname> osztályt a 
 <classname>Labirintus</classname> osztályból örököltetjük, majd a <classname>Labirintus</classname>
 <function>public int bolyong(Hős hős)</function> viselkedését a 
 <classname>TöbbHősösLabirintus</classname> osztályban felüldefiniáljuk. 
 Figyelje meg a kedves Olvasó, hogy a 
  <emphasis><link linkend="tobbhososlabirintus_osztaly">A TöbbHősösLabirintus osztály</link></emphasis>
 című pontban bemutatott kód mennyivel rövidebb a 
  <emphasis><link linkend="labirintus_osztaly">A Labirintus osztály</link></emphasis>
  című pontba foglalt ős labirintus kódjától!
</para>

<para>
Ha összehasonlítjuk az ős <function>public int bolyong(Hős hős)</function>
függvényének megfelelő

                       <programlisting>
                                <![CDATA[
        for(int i=0; i < szörnyek.length; ++i) {
            
            szörnyek[i].lép(hős);
            
            if(szörnyek[i].megesz(hős))  {
                játékÁllapot = JÁTÉK_MEGY_MEGHALT_HŐS;
                
                if(hős.megettek())
                    játékÁllapot = JÁTÉK_VÉGE_MEGHALT_HŐS;
                
                return játékÁllapot;
            }
            
        }                                
                                ]]>
                       </programlisting>

 részletét a származtatott osztály 
 <function>public int bolyong(Hős hős)</function> megfelelő
 részletével:
 
                       <programlisting>
                                <![CDATA[
       for(int i=0; i < szörnyek.length; ++i) {
            
            szörnyek[i].lép(hős);
            
            if(szörnyek[i].megesz(hős))  {
                
                if(hős.megettek())
                    // De ez a játék vége csak a hős végét
                    // jelenti, a labirintusét nem!
                    return JÁTÉK_VÉGE_MEGHALT_HŐS;
                else
                    return JÁTÉK_MEGY_MEGHALT_HŐS;
                
            }            
        }                                
                                ]]>
                       </programlisting>
 akkor láthatjuk, hogy a felüldefiniált viselkedés már nincs hatással
 a játék állapotára, azaz új osztályunkban egy hős halála a labirintus világára már
 nincs hatással.
</para>

                <sect5>
                    <title>Többalakúság</title>
                    
                <para>
                A többalakúságra (polimorfizmusra) példát láthatunk, ha a 
                <classname>HálózatiLabirintus</classname> osztályban
                a labirintusunkat így vesszük fel:
                        <programlisting>
							<![CDATA[
public class HálózatiLabirintus implements Runnable {
    /** A játék aktuális labirintusa, minden hálózati hős ebben mozog. */
    // TöbbHősösLabirintus labirintus;
    Labirintus labirintus;
                            ]]>
                       </programlisting>

viszont a továbbfejlesztett <classname>TöbbHősösLabirintus</classname> 
osztálybeli objektumként hozzuk létre, azaz a 
<classname>HálózatiLabirintus</classname> 
konstruktorban így példányosítjuk a 
labirintust:
                        <programlisting>
							<![CDATA[
    public HálózatiLabirintus(String labirintusFájlNév) throws 
            RosszLabirintusKivétel {
        // A labirintus elkészítése állományból
        labirintus = new TöbbHősösLabirintus(labirintusFájlNév);
                            ]]>
                       </programlisting>
                példánkban a többalakúság az, hogy a 
                <computeroutput>Labirintus labirintus</computeroutput>
                nem egy <classname>Labirintus</classname> osztálybeli
                objektum, hanem a <classname>Labirintus</classname> osztály
                egy leszármazottjabeli, a 
                <classname>TöbbHősösLabirintus</classname> osztálybeli objektum.
                Ha ennek a <computeroutput>labirintus</computeroutput> objektumnak
                meghívjuk a <function>public int bolyong(Hős hős)</function>
                metódusát, akkor a felüldefiniáló, azaz a 
                <classname>TöbbHősösLabirintus</classname> osztálybeli
                <function>public int bolyong(Hős hős)</function> függvény fog
                lefutni.                                
                </para>
                
					<tip>
					<title>Melyik metódus hívódik?</title>
					
						<para>			
						Szúrjunk be két logoló sort a 
						<classname>Labirintus</classname> (szülő) és a 
						<classname>TöbbHősösLabirintus</classname> (gyermek) osztálybeli
						<function>public int bolyong(Hős hős)</function> 
						függvénybe: 	
						
                        <programlisting>
							<![CDATA[
System.out.println("A gyermekbeli hívódott");
System.out.flush();							

System.out.println("A szülőbeli hívódott");
System.out.flush();							
                            ]]>
                       </programlisting>						
                       
                       majd a <classname>HálózatiLabirintus</classname> osztályt
                       futtatva győződjünk meg róla, hogy a gyermekbeli módszer hívódik!
						</para>
					
					</tip>
                
                </sect5>
                    
            </sect4>
            </sect3>
            
            <sect3>
                <title>Mi történik a metódusokban?</title>

                <para>
                    Az OO program osztályainak, az osztályok közötti kapcsolatok
                    megállapításának folyamata inkább egy szervezési és átfogó
                    jellegű stratégiai tervezési feladat. Ezzel szemben az osztály
                    metódusainak implementálása taktikai jellegű. Ez az a hely, ahová
                    a klasszikus imperatív programozó visszaszorult az OO paradigmaváltás
                    sikere után. Itt programozzuk be azt, amit csinál a program, az
                    osztály vagy az osztálybeli objektum. Alapvető imperatív eszközeink
                    ebben, a programunk tipikusan kódolási szakaszában a változók.
                </para>
                
                <sect4 id="tipusok_es_valtozok">
                    <title>Típusok és változók</title>

                    <para>
                        Javaban általában a típusok osztályok, a változók pedig
                        tipikusan valamilyen osztálybeli objektum referenciáját 
                        hordozzák értékként. Kivételt képeznek viszont az
                        úgynevezett <emphasis>primitív típusok</emphasis>, melyek
                        a 
                        <type>boolean</type>, 
                        <type>byte</type>, 
                        <type>char</type>, 
                        <type>double</type>, 
                        <type>float</type>, 
                        <type>int</type>, 
                        <type>long</type>.
                    </para>

                    <para>
                        Az ilyen típusú változókat osztályok-objektumok 
                        nélkül használhatjuk, ők az imperatív programozásban klasszikusan
                        megszokott változók. Javaban a primitív típusok
                        változóinak értéktartománya meghatározott, ahogy ezt a 
                        következőkben részletesen ismertetjük.
                        
                    <table frame="all"><title>A Java primitív típusai</title>
                        <tgroup cols="3">
                            <thead>
                                <row>
                                    <entry>
                                        <para>Típus</para>
                                    </entry>
                                    <entry>
                                        <para>Minimum</para>
                                    </entry>
                                    <entry>
                                        <para>Maximum</para>
                                    </entry>
                                </row>                                
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                    <para><type>boolean</type></para>
                                    </entry>
                                    <entry>
                                    <para><literal>false</literal></para>
                                    </entry>
                                    <entry>
                                        <para><literal>true</literal></para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para><type>byte</type></para>
                                    </entry>
                                    <entry>
                                    <para>-2<superscript>7</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>2<superscript>7</superscript>-1</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para><type>char</type></para>
                                    </entry>
                                    <entry>
                                    <para>\u0000</para>
                                    </entry>
                                    <entry>
                                        <para>\uffff</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para><type>double</type></para>
                                    </entry>
                                    <entry>
                                    <para>2<superscript>-1074</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>(2-2<superscript>-52</superscript>)*2<superscript>1023</superscript></para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para><type>float</type></para>
                                    </entry>
                                    <entry>
                                    <para>2<superscript>-149</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>(2-2<superscript>-23</superscript>)*2<superscript>127</superscript></para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para><type>int</type></para>
                                    </entry>
                                    <entry>
                                    <para>-2<superscript>31</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>2<superscript>31</superscript>-1</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para><type>long</type></para>
                                    </entry>
                                    <entry>
                                    <para>-2<superscript>63</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>2<superscript>63</superscript>-1</para>
                                    </entry>
                                </row>
                                </tbody></tgroup></table>
                        
                    </para>
                    
                    
                </sect4>
                
                <sect4 id="vezerlesi_szerkezetek">
                    <title>Vezérlési szerkezetek</title>
                    
					<para>
					A vezérlési szerkezetek tipikusan az iteráció és a szelekció
					megszervezésére adnak lehetőséget programjaink forrásszövegében.
					Előbbivel, azaz a ciklusok szervezésével, a 
					<computeroutput>for</computeroutput>, 
					<computeroutput>while</computeroutput> és 
					<computeroutput>do while</computeroutput> 
					kulcsszavak említése során 
					<emphasis><link linkend="java_szofajok">A Java szófajok</link></emphasis>,
					illetve kicsit bővebben 
					<emphasis><link linkend="java_mondattana">A Java mondattana</link></emphasis>
					című pontokban ismerkedtünk, itt folytatjuk a téma tárgyalását.
					A szelekció kapcsán Javaban az 
					<computeroutput>if else</computeroutput>, 
					<computeroutput>if else if else</computeroutput> és 
					<computeroutput>switch case</computeroutput>
					 szerkezeteket említhetjük, e konstrukciók
					megismerését is az imént hivatkozott pontokban kezdtük meg.
					</para>

                    <sect5>
                        <title>toString()</title>
                        
                        <para>Elegáns szokás osztályainkat ellátni egy 
                        <function>toString()</function> nevű, sztringet visszaadó, 
                        paraméter nélküli metódussal. A visszaadott sztring hivatása, hogy szemléltesse valamilyen értelmes formában az objektumot. <classname>Labirintus</classname> osztályunk tekintetében ez a forma lehet a labirintus szélessége, magassága és esetleg a szerkezete is. 
                    
                        <programlisting>
                                <![CDATA[
public String toString() {

    StringBuffer stringBuffer = new StringBuffer();

    for(int i=0; i<magasság; ++i) {

        for(int j=0; j<szélesség; ++j) {

            if(szerkezet[i][j])
                stringBuffer.append("X");
            else
                stringBuffer.append("+");

        }

        stringBuffer.append("\n");

    }

    return stringBuffer.toString();

}
                            ]]>
                       </programlisting>

                       A külső
                       
                        <programlisting>
                            <![CDATA[
for(int i=0; i<magasság; ++i) {
                            ]]>
                        </programlisting>
                        
                        ciklus <varname>i</varname> indexe a tömb sorain fut majd végig
                         (nullától a 
                         <computeroutput>magasság-1</computeroutput> értékig), s egy adott 
                         <varname>i</varname>. soron belül ebbe a külső ciklusba ágyazott
                        belső

                        <programlisting>
                            <![CDATA[
    for(int j=0; j<szélesség; ++j) {
                            ]]>
                        </programlisting>

                        ciklus <varname>j</varname> indexe a tömb oszlopain fut majd végig (nullától a
                         <computeroutput>szélesség-1</computeroutput> értékig). Ennek megfelelően a belső ciklus magjában az 

                        <programlisting>
                            <![CDATA[
        if(szerkezet[i][j])
             ...
        else
             ...
                            ]]>
                        </programlisting>

                                                
                        elágazó utasítás, ha az <varname>i</varname>. sor <varname>j</varname>. oszlopában igaz érték (azaz nálunk fal és ennek megfelelően az <computeroutput>if</computeroutput> utasítás fejében lévő <computeroutput>szerkezet[i][j]</computeroutput> kifejezés szó értéke igaz) van, akkor az <literal>X</literal>-et nyomtató ágra, ha hamis, akkor a <literal>+</literal> jelet nyomtató ágra viszi a vezérlést.
                        </para>
                        
                        <para>	
                        Az így implementált <function>toString()</function>
                        függvényünk tipikusan a következő formájú sztringet 
                        adja vissza, melyen a labirintus felépítményét 
                        tanulmányozhatjuk, ahol az <literal>X</literal> betű
                        jelzi a járatot és a <literal>+</literal> betű a falat.
                        
                        <screen>
                            <![CDATA[
+++X+X+XXX
++++++++++
X+X+X+X+X+
++++X+X+++
+XX+++XX+X
++++X+++++
+X+++X+XX+
+++X+X+X++
+X+++++++X
++++X+++XX                            
                            ]]>
                        </screen>     

                        </para>                        
                        
                        </sect5>
                        
                        <sect5 id="labirintust_fajlbol">
                            <title>A labirintust állományból felépítő konstruktor</title>
                            
                        <para>
                            Itt egyben folytatjuk az 
                            <emphasis><link linkend="objektumok_letrehozasa">Objektumok létrehozása: a konstruktor</link></emphasis>
                            című fejezetben megkezdett  -  olyan konstruktorral szereljük fel a <classname>Labirintus</classname> osztályt, ami egy állományból is képes felépíteni a labirintus szerkezetét  -  példánkat.
                              A labirintus szerkezetét leíró szöveges állomány nevét
                              a konstruktor paraméterként kapja meg, <computeroutput>labirintusFájlNév</computeroutput> nevű formális paraméterében.
                        
                            <programlisting>
                                <![CDATA[
public Labirintus(String labirintusFájlNév) {

}
                                ]]>
                            </programlisting>
                        
                        </para>
                        
                        <para>
                            Először kitaláljuk annak az állománynak a szerkezetét,
                            amiben leírjuk a labirintusunkat: mondjuk a dupla
                            perjelek utáni sorokkal nem foglalkozunk, itt
                            lehetnek majd a kommentek. Aztán jöjjön négy szám:
                            a kincsek száma, a szörnyek száma és a labirintus
                            szélessége, magassága. Végül következzék maga a
                            labirintus 0, 1 jegyekkel lekódolva: az 1 jelentse a
                            falat, a 0 a járatot! S íme a mi példánk erre a 
                            szöveges állományra:
                            
                        <programlisting>
                            <![CDATA[
//
// labirintus.txt
//
// DIGIT 2005, Javat tanítok
// Bátfai Norbert, nbatfai@inf.unideb.hu
//
// A labirintus szerkezetét megadó állomány, 
// szerkezete a következő:
//
// a kincsek száma
// a szörnyek száma
// a labirintus szélessége
// magassága
// fal=1 járat=0 ... 
// .
// .
// .
6
3
10
10
0 0 0 1 0 1 0 1 1 1
0 0 0 0 0 0 0 0 0 0
1 0 1 0 1 0 1 0 1 0
0 0 0 0 1 0 1 0 0 0
0 1 1 0 0 0 1 1 0 1
0 0 0 0 1 0 0 0 0 0
0 1 0 0 0 1 0 1 1 0
0 0 0 1 0 1 0 1 0 0
0 1 0 0 0 0 0 0 0 1
0 0 0 0 1 0 0 0 1 1

                            ]]>
                        </programlisting>
                        </para>
                        
                        <para>
                            Állományból beolvasni egy Java I/O csatorna objektumon
                            keresztül tudunk, tehát első lépésünk ennek létrehozása                            

                            <programlisting>
                                <![CDATA[
java.io.BufferedReader szövegesCsatorna = new java.io.BufferedReader(
        new java.io.FileReader(labirintusFájlNév));
                                ]]>
                            </programlisting>
                            
                            a nevével megadott állomány fölött nyitunk egy
                            karakteres állományokat Olvasó <classname>FileReader</classname>
                            bejövő csatornát, majd most e fölött rögtön egy 
                            <classname>BufferedReader</classname> csatornát. 
                            Ezen keresztül akarunk olvasni az állományból, mert
                            ettől a csatorna objektumtól lehet soronkénti 
                            olvasást (<function>readLine()</function> függvénye) kérni, ami számunkra most kényelmes
                            megoldásnak tűnik. Mert a dupla perjellel
                            kezdődő sorok figyelmen kívül hagyása után
                            beolvassuk az
                            első négy sort és a megfelelő számmá alakítjuk, 
                            majd beolvasunk magasságnyi sort és soronként 
                            letördeljük, hogy az adott cella éppen fal vagy járat-e.                            
                        
                        <programlisting>
                            <![CDATA[
String sor = szövegesCsatorna.readLine();

while(sor.startsWith("//"))
    sor = szövegesCsatorna.readLine();

kincsekSzáma = Integer.parseInt(sor);

sor = szövegesCsatorna.readLine();
szörnyekSzáma = Integer.parseInt(sor);

sor = szövegesCsatorna.readLine();
szélesség = Integer.parseInt(sor);

sor = szövegesCsatorna.readLine();
magasság = Integer.parseInt(sor);
                            ]]>
                        </programlisting>

                            Ha a program eddig sikerrel futott, akkor
                            tudjuk, hogy milyen széles és magas a 
                            labirintusunk, azaz mekkora logikai tömböt
                            kell létrehoznunk, hogy ezt az adatszerkezetet
                            el tudjuk tárolni

                        <programlisting>
                            <![CDATA[
szerkezet = new boolean[magasság][szélesség];
                            ]]>
                        </programlisting>
                                                        
                        </para>
                                                
                        <para>
                            Jöhet a szövegállományban megadott labirintus
                            szerkezet beolvasása és ez alapján a 
                            szerkezetet leíró logikai tömb megfelelő
                            értékeinek megadása. Amilyen magas a labirintusunk,
                            annyi sort kell feldolgoznunk
                            
                            <programlisting>
                                <![CDATA[
for(int i=0; i<magasság; ++i) {

    sor = szövegesCsatorna.readLine(); 
    java.util.StringTokenizer st =
            new java.util.StringTokenizer(sor);    
                                ]]>
                            </programlisting>

                            A <classname>StringTokenizer</classname> objektum 
                            segítségével tudjuk a beolvasott sort darabjaira 
                            tördelni, mely szövegdarabokat szóközök 
                            választanak el egymástól. A következő darabot a 
                            <function>nextToken()</function> metódussal lehet elkérni.
                            
                            <programlisting>
                                <![CDATA[
for(int i=0; i<magasság; ++i) {

    sor = szövegesCsatorna.readLine();

    java.util.StringTokenizer st =
            new java.util.StringTokenizer(sor);

    for(int j=0; j<szélesség; ++j) {
        String tegla = st.nextToken();

        if(Integer.parseInt(tegla) == 0)
            szerkezet[i][j] = false;
        else
            szerkezet[i][j] = true;
                                ]]>
                            </programlisting>

                            A <classname>Integer</classname> osztály statikus <function>parseInt()</function>
                            módszerével a beolvasott szövegdarabból számot készítünk, 
                            s majd attól függően, hogy ez a szám 0 vagy 1, beállítjuk a labirintus szerkezetét reprezentáló tömb megfelelő elemét, hamisra vagy igazra, azaz falra vagy járatra.
                                                    
                        </para>

                        <para>
                            Az állományból beolvasó konstruktor csontvázát ezzel átvettük,
                            a hús-vér konstruktort majd  
                            <emphasis><link linkend="tiszta_oo">A tiszta OO labirintus - Labirintus Világ</link></emphasis>
                            című pontban folytatva adjuk meg.
                        </para>
                        
                        </sect5>
                        
                        <sect5>
                            <title>String hasonlító feladat</title>
                            
                        <para>Olvassuk be a labirintus szerkezetét anélkül, hogy a tégla referenciájú szövegdarabokat számmá alakítanánk! Megoldásként használjuk a <classname>String</classname> osztály
                        <function>equals()</function> módszerét:
                                                
                        <programlisting>
                            <![CDATA[
if("0".equals(tegla))
    szerkezet[i][j] = false;
else
    szerkezet[i][j] = true;
                            ]]>
                        </programlisting>
                                                
                        </para>
                                        
                    </sect5>
                    
                    <sect5>
                        <title>null referencia feladat</title>
                        
                    <para>
                    Miért szerencsésebb általában a 
                    <computeroutput>"0".equals(tegla)</computeroutput> utasítás, 
                    mint a <computeroutput>tegla.equals("0")</computeroutput>?
                    </para>
                    
                    <para>
                    Mert mi történik, ha a 
                    <varname>tegla</varname> értéke éppen 
                    <literal>null</literal>? Megtudja az Olvasó, ha 
                    az alábbi osztályt kipróbálja!
                                        
                        <programlisting>
                            <![CDATA[
public class Tégla {
    
    public static void main(String[] args) {
        
        String tegla = "QWERT";
        
        if(tegla.equals("QWERT"))
            System.out.println("A tegla tartalma most QWERT");
        
        tegla = null;
        
        if(tegla.equals("QWERT"))
            System.out.println("A tegla tartalma most QWERT");
        
    }    
}                            
                            ]]>
                        </programlisting>

                        Fordítás és futtatás után
                        
                        <screen>
                            <![CDATA[
C:\...> javac Tégla.java
C:\...> java Tégla
A tegla tartalma most QWERT
Exception in thread "main" java.lang.NullPointerException
        at Tégla.main(Tégla.java:12)    
                            ]]>
                        </screen>     
                        
                        <tip>
                            <title>Olvassuk el a hibaüzeneteket</title>
                            
                            <para>
                                Akár a fordítás, akár a futtatás során igaz,
                                hogy mindig érdemes és fontos a kiírt hibát 
                                gondosan tanulmányozni. Az egyik legalapvetőbb
                                információ, hogy a hiba hol keletkezett, mert a 
                                program szövegének ezt a jelzett helyét
                                megtekintve az idővel kialakuló rutinos szem
                                már könnyen észreveheti a hibát.
                            </para>                                
                        </tip>
                        
                        Egy futási hibával megáll a programunk, mivel
                        működése közben egy
                        <classname>java.lang.NullPointerException</classname>
                        kivétel váltódik ki, mert olyan objektumra hivatkoztunk,
                        amikor a - valójában <literal>null</literal> 
                        és nem egy vélt sztring objektum referencia 
                        értékű - <varname>tegla</varname>-nak hívni
                        akartuk az <function>equals()</function>
                        metódusát, ami gyakorlatilag nem is létezik.
                        Persze most könnyű észrevenni, hogy nem létezik,
                        hiszen a
                        <computeroutput>tegla = null;</computeroutput>
                        utasítással mi magunk töröltük, de egy bonyolultabb
                        programban ez nem mindig látszik, ezért érdemes
                        a sztring literálként megadott, ezért 
                        mindig létező <quote>0</quote> sztring objektumnak
                        hívni esetünkben az <function>equals()</function>
                        metódusát. Ezzel tipikusan megspórolunk egy
                        <computeroutput>if(tegla != null)</computeroutput>
                        jellegű
                        feltételvizsgálatot, amivel persze az ilyen típusú
                        problémákat szintén orvosolni lehetne:
                        
                        <programlisting>
                            <![CDATA[
public class Tégla {
    
    public static void main(String[] args) {
        
        String tegla = "QWERT";
        
        if(tegla.equals("QWERT"))
            System.out.println("A tegla tartalma most QWERT");
        
        tegla = null;

        if(tegla != null)
            if(tegla.equals("QWERT"))
                System.out.println("A tegla tartalma most QWERT");
        
    }    
}                            
                            ]]>
                        </programlisting>
                        
                        de láthatóan jóval hatékonyabb az alábbi
                        módon megszervezni a kódot.
                        
                        <programlisting>
                            <![CDATA[
public class Tégla {
    
    public static void main(String[] args) {
        
        String tegla = "QWERT";
        
        if(tegla.equals("QWERT"))
            System.out.println("A tegla tartalma most QWERT");
        
        tegla = null;

        if("QWERT".equals(tegla))
            System.out.println("A tegla tartalma most QWERT");
        
    }    
}                            
                            ]]>
                        </programlisting>
                        
                    </para>
                    
                    <warning id="runtime_exception">
                        <title>A RuntimeException típusú hibák kezeléséről 1.</title>
                        
                        <para>
                            A hamarosan következő 
                            <emphasis><link linkend="kivetelkezeles">Kivételkezelés</link></emphasis>
                            című pontban látjuk majd, hogy a kivéteket hogyan kezelhetjük programunkból,
                            hogyan kaphatjuk el őket. Ott fogunk egy rossz példát mutatni arra
                            a rossz gyakorlatra, amikor
                            például ezt a <classname>RuntimeException</classname>
                            kivételt kezelni próbálja a programozó. 
                            (A kapott <classname>NullPointerException</classname>
                            kivétel osztály a <classname>RuntimeException</classname>
                            gyermeke.)
                            Már itt hangsúlyozzuk,
                            hogy az ilyen típusú hibákat a program szövegének gondosabb
                            kifejlesztésével kell elkerülni és nem a kivételkezelést
                            mint tüneti kezelést alkalmazni erre.
                        </para>
                    </warning>
                    
                    </sect5>

                    </sect4>
                </sect3>

                <sect3 id="esemenykezeles">
                    <title>Eseménykezelés</title>
                        
                <para>Esemény alatt azt értjük, mint a köznyelvben is: esemény az, amikor történik valami. Speciálisan, amikor a program világában történik valami. Például megmozdítjuk az egeret, becsukjuk a program ablakát stb. Az események, mint Javaban minden, maguk is objektumok.</para>
                
                <para>Az események kezelése az adott eseménytípusnak megfelelő interfészeken
                keresztül történik. A programozó azokban az osztályaiban, ahol az események
                keletkeznek, jelzi, hogy melyik objektum dolgozza majd fel az eseményeket.
                Ennek a feldolgozó objektumnak pedig tudni kell fogadnia a megfelelő
                eseményobjektumokat. Például a mobilos labirintus példánkban egy 
                <classname>LabirintusVaszon</classname> vászon objektum uralja a mobil 
                kijelzőjét, amit a <classname>LabirintusMIDlet</classname> osztályban 
                 készítünk el:
                
                        <programlisting>
                            <![CDATA[
        labirintusVászon = new LabirintusVaszon();
        // A kilépés parancs elkészítése
        kilépésParancs = new javax.microedition.lcdui.Command("Kilép",
                javax.microedition.lcdui.Command.EXIT, 1);
        // és a labirintus vászonra helyezése
        labirintusVászon.addCommand(kilépésParancs);
        // az eseményeket (most kilépés parancs) itt dolgozzuk fel
        labirintusVászon.set(this);                            
                            ]]>
                        </programlisting>
                A telefon <guilabel>Kilép</guilabel> gombnak megfelelő szoftbillentyűjét
                 megnyomva a megfelelő <classname>Command</classname> objektummal
                 meghívódik a <varname>labirintusVászon</varname>-ba 
                a <computeroutput>labirintusVászon.setCommandListener(this);</computeroutput>
                parancs eseményfigyelőt beállító hívással bejegyzett objektum 
                <function>commandAction()</function>
                eseménykezelő függvénye. Ez a <computeroutput>this</computeroutput>
                objektum most maga a <classname>LabirintusMIDlet</classname> osztály, aminek
                fejét ennek megfelelően így írtuk:
                        <programlisting>
                            <![CDATA[
public class LabirintusMIDlet extends javax.microedition.midlet.MIDlet
        implements javax.microedition.lcdui.CommandListener {
                            ]]>
                        </programlisting>
                        azaz implementálja a <classname>CommandListener</classname>
                        parancsokat figyelő interfészt. Ennek az interfésznek egyetlen metódusa
                        van, az említett <function>commandAction()</function>. Tehát
                        a <classname>LabirintusMIDlet</classname> osztályban implementálnunk
                        kell ezt a függvényt:
                        <programlisting>
                            <![CDATA[
    /**
     * A labirintus játék parancsainak (jelen esetben egy ilyen van,
     * a kilépés) kezelése.
     *
     * @param command parancs, ami keletkezett
     * @param displayable valamelyik képernyőn
     */
    public void commandAction(javax.microedition.lcdui.Command parancs,
            javax.microedition.lcdui.Displayable képernyő) {
        
        if (képernyő == labirintusVászon) {
            if (parancs == kilépésParancs) {
                // Leállítjuk a labirintus játék szálát
                labirintusVászon.játékKilép();
                // Leállítjuk a programot
                kijelző.setCurrent(null);
                destroyApp(true);
                notifyDestroyed();
                
            }
        }
    }
                                ]]>
                        </programlisting>
                        
                
                </para>
                
                <para>
                Ha a használni kívánt eseménykezelő interfészben több metódus van, akkor
                sokszor kényelmetlen a függvény fejében jelezni az interfész implementálását, mert
                ekkor az osztályban az interfész minden metódusának meg kell adni az
                implementációját. Amivel persze éppen nem akarunk foglalkozni, azt üres
                testtel implementálva. Mégis kényelmesebb az úgynevezett adapter
                osztályok használata, akik a megfelelő interfész minden módszerének megadják
                az üres testű implementációját, mi pedig ezt az osztályt kiterjesztjük és a minket
                érintő módszereit felüldefiniáljuk: így nekünk nem kell lélekölően a számos
                 üres testű
                függvény implementációt begépelnünk. Erre számos példát tudunk mutatni a 
                kézikönyv forrásaiban, például a <classname>LabirintusJáték</classname>
                osztályban a billentyűzet eseményeket dolgozzuk fel a 
                <classname>java.awt.event.KeyAdapter</classname> adapter osztállyal:
                
                        <programlisting>
                            <![CDATA[
        // A hős mozgatása a KURZOR billenytűkkel, ESC kilép
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent billentyűEsemény) {
                
                int billentyű = billentyűEsemény.getKeyCode();
                
                if(!játékVége)
                    switch(billentyű) { // hős mozgatása
                        
                        case java.awt.event.KeyEvent.VK_UP:
                            hős.lépFöl();
                            break;
                        case java.awt.event.KeyEvent.VK_DOWN:
                            hős.lépLe();
                            break;
                        case java.awt.event.KeyEvent.VK_RIGHT:
                            hős.lépJobbra();
                            break;
                        case java.awt.event.KeyEvent.VK_LEFT:
                            hős.lépBalra();
                            break;
                            
                    }
                    // Kilépés a játékból
                    if(billentyű == java.awt.event.KeyEvent.VK_ESCAPE)
                        játékKilép = true;
                    
                    // A játékban történt változások a képernyőn 
                    // is jelenjenek meg
                    rajzolniKell();
                    
            };
        });                            
                                ]]>
                        </programlisting>
                vagy a <classname>MandelbrotHalmazNagyító</classname> osztályunkban az
                egéreseményeket dolgozzuk fel a <classname>java.awt.event.MouseAdapter</classname>
                adapterrel:

                        <programlisting>
                            <![CDATA[
        // Egér kattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            // Egérkattintással jelöljük ki a nagyítandó terület
            // bal felső sarkát vagy ugyancsak egér kattintással
            // vizsgáljuk egy adott pont iterációit:
            public void mousePressed(java.awt.event.MouseEvent m) {
                // Az egérmutató pozíciója
                x = m.getX();
                y = m.getY();
                // Az 1. egér gombbal a nagyítandó terület kijelölését
                // végezzük:
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
                    // A nagyítandó kijelölt terület bal felső sarka: (x,y)
                    // és szélessége (majd a vonszolás növeli)
                    mx = 0;
                    my = 0;
                    repaint();
                } else {
                    // Nem az 1. egér gombbal az egérmutató mutatta c
                    // komplex számból indított iterációkat vizsgálhatjuk
                    MandelbrotIterációk iterációk =
                            new MandelbrotIterációk(
                            MandelbrotHalmazNagyító.this, 50);
                    new Thread(iterációk).start();
                }
            }
            // Vonszolva kijelölünk egy területet...
            // Ha felengedjük, akkor a kijelölt terület
            // újraszámítása indul:
            public void mouseReleased(java.awt.event.MouseEvent m) {
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
...                            
                                ]]>
                        </programlisting>
                        
                        avagy ugyanitt az egérmozgásával kapcsolatos eseményeket
                        a <classname>java.awt.event.MouseMotionAdapter</classname>
                adapterrel:

                        <programlisting>
                            <![CDATA[
        // Egér mozgás események feldolgozása:
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            // Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                // A nagyítandó kijelölt terület szélessége és magassága:
                mx = m.getX() - x;
                my = m.getY() - y;
                repaint();
            }
        });                            
                                ]]>
                        </programlisting>
                
                </para>
                
                <para> Számos további példát említhetnénk még, de csak a további fő típusokra
                utalva: a <classname>GaltonDeszka</classname> osztályban foglalkozunk az ablakkal
                kapcsolatos eseményekkel:
                
                        <programlisting>
                            <![CDATA[
        // Az ablak bezárásakor kilépünk a programból.
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });                            
                                ]]>
                        </programlisting>
                
                illetve a például az <classname>ExorTitkositoGUI</classname> osztályban 
                nyomógombon való kattintást dolgozunk fel:
                        <programlisting>
                            <![CDATA[
        kódolButton.addActionListener(
                new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent
                    e) {               
                                ]]>
                        </programlisting>
                
                </para>
	
				<para>
Továbbá érdekességként említjük, hogy például a
 rendszer értesítési területéről érkező eseményeket dolgoz fel a
<classname>LabirintusAlkalmazás</classname> osztály. A <classname>Pontmátrix</classname> osztályban
pedig egy legördülő menüből vesszük át a felhasználói inputot.
                </para>
                
                    
                </sect3>
                
                <sect3 id="kivetelkezeles">
                    <title>Kivételkezelés</title>
                    
                <para>Ha a program futása közben nem azt csinálja, amit a normális működése során a programozója feltételezett, hanem valami más ritkán bekövetkezőt, nem vártat, szokatlant, 
                hibásat - egyszóval valami kivételeset -, akkor azt mondjuk, hogy kivétel keletkezett. A kivételek, mint Javaban minden, maguk is objektumok. A program szövegének azt a részét, amit a programozó figyelni akar, hogy a végrehajtása közben keletkezik-e kivétel, egy <computeroutput>try</computeroutput> kulcsszóval bevezetett blokkba kell foglalni. Ha bekövetkezik egy kivétel, akkor a program végrehajtása a tartalmazó 
                <computeroutput>try</computeroutput> blokknak megfelelő <computeroutput>catch</computeroutput> kulcsszóval bevezetett blokkban folytatódik.</para>
                <para>
                    Egyszerű példaként folytassuk a                     
<emphasis><link linkend="vezerlesi_szerkezetek">Vezérlési szerkezetek</link></emphasis>                                    pontban megkezdett, állományból olvasó
                    konstruktor írását! 
                    A labirintus szerkezetét leíró állomány a programon kívüli 
                    erőforrás, ezért is könnyű vele a játékot variálni, mert
                    nem kell a programhoz nyúlnunk, ha a labirintusnak más
                    szerkezetet szeretnénk. Viszont ez a programon kívüliség
                    számos probléma (vagy jelen terminológiánkban: kivétel) 
                    forrása lehet. Gondoljunk arra például, hogy hogyan viselkedjen
                    a program akkor, ha nincs meg ez az állomány! Ha a labirintus 
                    felépítése során valami gondunk támad, azaz a konstruktor
                    futása során kivétel keletkezik, akkor az ilyen nagyobb
                    problémákra való válaszadást a hívóra, azaz arra bízzuk,
                    aki létre akarta hozni ily módon a labirintust. Ezért a 
                    konstruktor fejében jelezzük, hogy megszakíthatja 
                    futását és egy <classname>RosszLabirintusKivétel</classname>
                    objektumot dobhat a hívónak, amely objektumba becsomagoltuk
                    ennek a valamilyen nagyobb hibának a leírását.

                    <programlisting>
                        <![CDATA[
public Labirintus(String labirintusFájlNév) throws RosszLabirintusKivétel {

}
                        ]]>
                    </programlisting>

                    Vegyük most szemügyre a <varname>br</varname>
                    referenciájú, <classname>BufferedReader</classname> osztálybeli 
                    objektum példányosításának pontos forráskódrészletét! 

                    <programlisting>
                        <![CDATA[
java.io.BufferedReader szövegesCsatorna = null;

try {
    szövegesCsatorna = new java.io.BufferedReader(
            new java.io.FileReader(labirintusFájlNév));                        
                ]]>
                    </programlisting>

                    Ez az objektum a labirintusunkat leíró szöveges 
                    állományra nyitott csatorna objektum, amin keresztül 
                    beolvassuk a labirintus szerkezetének sorait a 
                    <classname>BufferedReader</classname> osztálybeli 
                    objektum <function>readLine()</function> 
                    metódusával a külső <computeroutput>for</computeroutput>
                    ciklusban. 
                    Itt a program feltételezett normális működésétől 
                    való eltérés, azaz kivétel például az lehet, 
                    hogy a program nyitni akarja a szöveges 
                    állományra a csatorna objektumot, de a szöveges állomány 
                    nem létezik, mert például nem megfelelő helyre másoljuk.
                </para>                  
                
                
                <para>
                    De más kivételekbe is beleszaladhat a program, például
                    a beolvasott első 4 adat nem szám, hanem egy
                    egyszerű elírás miatt példának okáért egy betű
                    
                    <programlisting>
                        <![CDATA[
try {

    kincsekSzáma = Integer.parseInt(sor);

    sor = szövegesCsatorna.readLine();
    szörnyekSzáma = Integer.parseInt(sor);

    sor = szövegesCsatorna.readLine();
    szélesség = Integer.parseInt(sor);

    sor = szövegesCsatorna.readLine();
    magasság = Integer.parseInt(sor);

    szerkezet = new boolean[magasság][szélesség];

} catch(java.lang.NumberFormatException e) {

    throw new RosszLabirintusKivétel("Hibás a kincsek, szörnyek száma, " 
                                      +"szélesség, magasság megadási rész.");

}
                        ]]>
                    </programlisting>

                    Ha itt a <computeroutput>try</computeroutput> blokkba foglalt kódrészletnek 
                    bármely pontján kivétel keletkezik, akkor a 
                    végrehajtás a <computeroutput>catch</computeroutput> blokknál folytatódik, s ha ez a
                    kivétel a szövegdarabok számmá konvertálása kapcsán
                    keletkezett (amit az mutat meg, hogy a kivétel
                    objektum a <classname>NumberFormatException</classname>
                    osztálybeli) akkor a vezérlés ebben a <computeroutput>catch</computeroutput> blokkban
                    folytatódik. Ha a kincsek vagy szörnyek számával lenne
                    a baj, akkor azt itt még értelmesen is tudnánk kezelni,
                    mert például azt mondanánk, hogy legyen 3 kincs, ha a 
                    szöveges állományban a szám helyett mondjuk tévedésből egy
                    <quote>a</quote> betűt adtunk meg. Viszont a labirintus szélességénél
                    és magasságánál már nem tudunk ilyen jó hibajavítást
                    javasolni, mert ha itt mondunk egy számot hasraütésre,
                    az biztos nem lesz éppen annyi, ahány oszlop és sor
                    adat szerepel lejjebb. Ezért érdekes megoldást alkalmazunk
                    kezelésként: nem kezelünk, hanem tovább dobunk egy
                    kivételt.
                    
                    <programlisting>
                        <![CDATA[
throw new RosszLabirintusKivétel("Hibás a kincsek, szörnyek száma, 
                                    szélesség, magasság megadási rész.");
                        ]]>
                    </programlisting>

                    ne feledjük, hogy <computeroutput>try-catch</computeroutput> blokkunk egy másik
                    ilyen blokkba van ágyazva
                    <programlisting>
                        <![CDATA[
try {
    szövegesCsatorna = new java.io.BufferedReader(
            new java.io.FileReader(labirintusFájlNév));

    String sor = szövegesCsatorna.readLine();

    while(sor.startsWith("//"))
        sor = szövegesCsatorna.readLine();

    try {

        kincsekSzáma = Integer.parseInt(sor);

        sor = szövegesCsatorna.readLine();
        szörnyekSzáma = Integer.parseInt(sor);

        sor = szövegesCsatorna.readLine();
        szélesség = Integer.parseInt(sor);

        sor = szövegesCsatorna.readLine();
        magasság = Integer.parseInt(sor);

        szerkezet = new boolean[magasság][szélesség];

    } catch(java.lang.NumberFormatException e) {

        throw new RosszLabirintusKivétel("Hibás a kincsek, szörnyek száma, 
                            szélesség, magasság megadási rész.");

    }

    // ITT VAN A SOROK OSZLOPOK FELDOLGOZÁSA

} catch(java.io.FileNotFoundException e1) {

    throw new RosszLabirintusKivétel("Nincs meg a fájl: " + e1);

} catch(java.io.IOException e2) {

    throw new RosszLabirintusKivétel("IO kivétel történt: "+e2);

} catch(java.util.NoSuchElementException e3) {

    throw new RosszLabirintusKivétel("Nem jó a labirintus szerkezete: "+e3);

} finally {

    if(szövegesCsatorna != null) {

        try{
            szövegesCsatorna.close();
        } catch(Exception e) {}

    }

}
                        ]]>
                    </programlisting>
                    
                    A befoglaló <computeroutput>try</computeroutput> blokk valamely <computeroutput>catch</computeroutput> ága elkapja a dobott 
                    <classname>RosszLabirintusKivétel</classname> kivételünket?                    
                    Nem, mert nincs ilyen ága!
                    Ezért ez a kivétel tovább dobódik a hívónak. Nézzük mit
                    csinál ezzel a továbbdobott kivétellel a 
                    <classname>LabirintusVilág</classname>
                    példaprogram mint hívó. A <classname>LabirintusVilág</classname>
                    konstruktora készíti el a labirintust, de a 
                    <classname>RosszLabirintusKivétel</classname> kivételt ő sem 
                    kezeli, csak jelzi, hogy ha ilyen lenne, akkor ő 
                    dobná tovább a hívónak. 
                    
                    <programlisting>
                        <![CDATA[
public LabirintusVilág(String labirintusFájlNév) throws RosszLabirintusKivétel {

    // A labirintus elkészítése állományból
    labirintus = new Labirintus(labirintusFájlNév);
                        ]]>
                    </programlisting>

                    A hívó <function>main()</function>-jében van a megfelelő kezelő:                    
                                        
                    <programlisting>
                        <![CDATA[
public static void main(String[] args) {

    try {

        new LabirintusVilág(args[0]);

    } catch(RosszLabirintusKivétel rosszLabirintusKivétel) {

        System.out.println(rosszLabirintusKivétel);

    }

}
                        ]]>
                    </programlisting>

                    s itt találjuk a kezelést is: kiírjuk, hogy mi volt
                    a probléma a labirintus elkészítése során, majd a 
                    program leáll.
                    
                </para>
                
                 <para>
                    Milyen kivételek váltódhatnak itt ki? Ugye nem az elvárt normális működés, ha a labirintust leíró szöveges állományunk nincs meg, ekkor egy <classname>java.io.FileNotFoundException</classname> kivétel objektum keletkezik még az elején, amikor a csatornát ki akarjuk nyitni az állomány felett. Ha sikerül megnyitni az állomány felett csatornát, a sorok olvasása vagy a csatorna lezárása során keletkezhet <classname>java.io.IOException</classname> kivétel.
                    Ha mondjuk elrontjuk ezt a szöveges állományt, az egyik sorában letöröljük az utolsó számot, akkor amikor éppen ezt a hiányzó számot kellene beolvasni, azaz a                            
                    
                    <programlisting>
                        <![CDATA[
String tegla = st.nextToken();
                        ]]>
                    </programlisting>

                    utasítás végrehajtásakor egy 
                    <classname>java.util.NoSuchElementException</classname> 
                    kivétel fog kiváltódni.
                    Ha nem kitörölünk, hanem csak mondjuk 
                    átírjuk egy <quote>a</quote> betűre, akkor (lást az imént végigjátszott esetet)
                    egy <classname>java.lang.NumberFormatException</classname> 
                    kivétel váltódik ki, amikor számmá próbáljuk alakítani a már beolvasott szövegdarabot.                    
                </para>                
                
                
                <para>
                    Nézzünk egy olyan részt, ahol valódi kezelést
                    alkalmaztunk, a sorok és oszlopok feldolgozásánál:
                    
                    <programlisting>
                        <![CDATA[
for(int i=0; i<magasság; ++i) {

    sor = szövegesCsatorna.readLine();

    java.util.StringTokenizer st =
            new java.util.StringTokenizer(sor);

    for(int j=0; j<szélesség; ++j) {
        String tegla = st.nextToken();

        try {

            if(Integer.parseInt(tegla) == 0)
                szerkezet[i][j] = false;
            else
                szerkezet[i][j] = true;

        } catch(java.lang.NumberFormatException e) {

            System.out.println(i+". sor "+j+". oszlop "+e);
            szerkezet[i][j] = false;

        }
    }
}

                        ]]>
                    </programlisting>

                    Itt azt is meg tudjuk mondani, hogy a labirintust 
                    leíró állomány melyik része volt hibás és menet 
                    közben javítjuk is, azaz azt tételezzük fel, 
                    hogy ott 0 áll, ezért a kezelő blokkban hamisra 
                    állítjuk a tömb megfelelő elemét. 
                    Továbbá egy ilyen hiba miatt nem szakad meg a 
                    állomány további feldolgozása!                    
                </para>

                <example>
                        <title>A RuntimeException típusú hibák kezeléséről 2.</title>
                        
                        <para>
                            A korábbi, 
                            <emphasis><link linkend="runtime_exception">A RuntimeException típusú hibák kezeléséről 1.</link></emphasis>
                            című pontban említett elkerülendő és rossz gyakorlatot mutatjuk be
                            itt. Úgy módosítjuk a <classname>Tégla</classname> osztályt,
                            hogy elkapjuk a <classname>NullPointerException</classname>
                            kivételt:
                            
                            <programlisting>
                                <![CDATA[
public class Tégla {
    
    public static void main(String[] args) {
        
        String tegla = "QWERT";
        
        if(tegla.equals("QWERT"))
            System.out.println("A tegla tartalma most QWERT");
        
        tegla = null;

        try {
            
            if(tegla.equals("QWERT"))
                System.out.println("A tegla tartalma most QWERT");
        
        } catch(RuntimeException e) {        
            e.printStackTrace(System.out);
            System.out.flush();          
        }
        
        System.out.println("A végén vagyok.");        
    }    
}
                                ]]> 
                            </programlisting>
                    Láthatóan programunk nem állt le, a kivételt
                    kezeltük, de mégis: ennek a gyakorlatnak nincs értelme!
                    Mert a példaként tárgyalt hiba, hogy egy (már vagy még) 
                    nem
                    létező objektum metódusát akarjuk meghívni, szinte
                    bárhol
                    előfordulhat a programunk szövegében, így melyik
                    részét figyelnénk 
                    <computeroutput>try-catch</computeroutput> blokkjainkkal?
                    Az ilyen típusú hibákat a program szövegének gondos
                    kifejlesztésével, megírásával kerülhetjük el értelmesen!
                        </para>
                            
                </example>
                
                
            </sect3>
                
            <sect3>
                <title>Párhuzamos végrehajtás</title>
            
                    <para>
                       Javaban a párhuzamos végrehajtás szál objektumok
                       formájában valósul meg. A szálak az alapvető, azaz
                       a <classname>java.lang</classname> csomagbeli
                       <classname>Thread</classname> osztály leszármazottai.
                    </para>
            
                <sect4>
                    <title>Thread objektumok</title>
                    
                    <para>
                        A párhuzamosan végezhető, végezendő tevékenységeket
                        tehát olyan osztályokban implementáljuk, amik
                        kiterjesztik a <classname>java.lang.Thread</classname>
                        osztályt. Nincs más dolgunk, mint a párhuzamosan
                        végrehajtatni óhajtott tevékenységet az osztály
                        <function>run()</function> módszerében implementálni.                         
                         Viszont mivel Javaban az öröklődés egyszeres,
                        azaz csak egy osztályt szerepeltethetünk az
                        <computeroutput>extends</computeroutput> kulcsszó után, így a
                            <programlisting>
                                <![CDATA[
public class Párhuzamos extends Thread {
                                ]]>
                            </programlisting>
                            
                            osztályt például már nem tudnánk egy másik osztályból is származtatni.
                            Ebben segít a <classname>Runnable</classname> interfész.                        
                    </para>
                    
                </sect4>

                <sect4>
                    <title>Runnable objektumok</title>

                    <para>
                    A <classname>Runnable</classname> interfésznek egyetlen metódusa a 
                    <function>run()</function> metódus. A <classname>Runnable</classname> interfészt
                    implementáló osztályokat szoktuk <classname>Runnable</classname>
                     objektumoknak is nevezni. Az osztályunkat származtatjuk onnan, ahonnan
                     származtatnunk kell, jelezzük, hogy osztályunkban implementáljuk a szóban forgó
                     interfészt és osztályunk <function>run()</function> módszerében implementáljuk
                     a párhuzamosan végrehajtandó tevékenységet. Például 
                     <classname>Sejtautomata</classname> osztályunk örököl a 
                     <classname>java.awt.Frame</classname> osztályból, de a sejtautomata
                     szimulációt egy párhuzamos programszálában végzi.                     
                     
                            <programlisting>
                                <![CDATA[
public class Sejtautomata extends java.awt.Frame implements Runnable {
                                ]]>
                            </programlisting>
                            Ehhez, ennél a <classname>Runnable</classname> interfészt kiterjesztő
                            módszernél is készítünk szálat, aminek paramétereként
                            adjuk meg a <classname>Runnable</classname> objektum
                            referenciáját, például az említett osztály konstruktorában:  

                            <programlisting>
                                <![CDATA[
        new Thread(this).start();
                                ]]>
                            </programlisting>
                            
                            ahol a <function>start()</function> metódus meghívásával
                             rögtön indítottuk is az elkészített szálat. Ez a
                            <function>run()</function>, a párhuzamosan
                            végrehajtandó kódot tartalmazó módszer implicit meghívását jelenti:
                     
                            <programlisting>
                                <![CDATA[
   /** A sejttér időbeli fejlődése. */
    public void run() {
        
        while(true) {
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
            
            időFejlődés();
            repaint();
        }
    }
                                ]]>
                            </programlisting>
                     
                    </para>
                    <para>
                    A kézikönyv példái között számos további esetben láthatjuk és 
                    tanulmányozhatjuk a <classname>Runnable</classname> interfész használatát.
                    Csak néhányat kiragadva, például a <classname>LabirintusKiszolgáló</classname>
                    osztályból:
                     
                            <programlisting>
                                <![CDATA[
public class LabirintusKiszolgáló
        extends javattanitok.labirintus.TöbbHősösLabirintus
        implements LabirintusOperations, Runnable {
                                ]]>
                            </programlisting>
                    
                    vagy a <classname>LabirintusVaszon</classname> osztályt megnézve:
                    
                            <programlisting>
                                <![CDATA[
public class LabirintusVaszon extends javax.microedition.lcdui.game.GameCanvas
        implements Runnable {                                
                                ]]>
                            </programlisting>


                    </para>

               </sect4>
            </sect3>

            <sect3>
                <title>Interfészek</title>

                   <para>
                   Már számos interfésszel találkoztunk eddig is a gyakorlatban, az iménti
                   <classname>Runnable</classname> interfészt megelőzően az eseménykezelési
                   részben például, ahol az 
<emphasis><link linkend="esemenykezeles">Eseménykezelés</link></emphasis> című pontban 
megismerkedtünk a <classname>CommandListener</classname> interfész használatával. Az API
dokumentációt fellapozva láthatjuk, hogy ez
az interfész egyetlen metódus specifikációját tartalmazza:
                        <programlisting>
                        <![CDATA[
void commandAction(javax.microedition.lcdui.Command c, 
                   javax.microedition.lcdui.Displayable d);
                        ]]>
                        </programlisting>                    
A <classname>CommandListener</classname> interfészt implementáló osztály feladata, hogy
ezt a függvényt implementációval lássa el, erre láthattunk példát a 
<emphasis><link linkend="labirintusmidlet_osztaly">A LabirintusMIDlet osztály</link></emphasis>
című pontba foglalt <classname>LabirintusMIDlet</classname> osztály kódjában.

</para>
                   <para>
                   Az interfészek az osztályokhoz hasonlóak, lehetnek
                   tulajonságaik, de a függvényeiket maguk csak deklarálják, testtel nem látják
                   el őket. Nézzük meg például a JDK könyvtárában található
                                <filename>src.zip</filename> állományban -
                                ahol ugye megtaláljuk a Java SE OO világ összes 
                                osztályának forráskódját - az 
                                <filename>src.zip/java/lang/Runnable.java</filename>
                                forrásban a <classname>Runnable</classname> interfészt!
                                A <classname>Runnable</classname> interfészt 
                                számos saját példánkban kiterjesztjük, ilyenek például
                                az önálló időfejlődéssel ellátott labirintus példáink
                                vagy a grafikus felületet és egyben számítást vagy szimulációt
                                tartalmazó példáink is, mint a 
                                <emphasis><link linkend="mandelbrot_halmaz">Mandelbrot halmaz</link></emphasis> vagy a 
                                <emphasis><link linkend="galton_kiserlet">Galton deszka kísérlet</link></emphasis> vagy éppen a 
                                <emphasis><link linkend="conway">Sejtautomata szimuláció</link></emphasis> programja. 
                                
                   </para>
                   
                   <para>                   
                   Az interfészek tipikus felhasználási területe az előző pontban említett
                   többszörös öröklődés hiányának orvoslása. A kezdő fejlesztő 
                   legtöbbször az eseménykezelés és a párhuzamosság implementálása során
                   találkozik velük, de idővel saját programjait is megtanulja általánosabbá
                   tenni az interfészek használatával, mert ahová például egy formális
                   paraméterként interfészt írunk, oda aktuálisan bármilyen objektumot 
                   átadhatunk, aminek példányosító osztálya ezt az interfészt implementálja. 
                   </para>
                
            </sect3>

            <sect3>
                <title>Csomagok</title>

                   <para>
                   Ha OO világunk leírása során fejlesztett osztályaink száma
                   megszaporodik, akkor ezeket az osztályokat érdemes csoportokba szervezni.
                   Így tettünk mi is, amikor például a labirintus absztahálásával kapcsolatos
                   osztályainkat a <classname>javattanitok.labirintus</classname>
                   csomagba szerveztük. A csomagokkal kapcsolatos alapismereteket a 
				   <emphasis><link linkend="java_szofajok">A Java szófajok</link></emphasis>                   című fejezetben, a <computeroutput>package</computeroutput> ismertetésénél 
				   tárgyaltuk.
                   </para>
                   
            </sect3>       


        </sect2>
        
        <sect2>
            <title>A Java nyelv használata</title>
            
            <para>
            A programozás megtanulásához programok írásán keresztül vezet az út, 
            a 
            konkrét programozási nyelvhez - esetünkben a Javahoz - kapcsolódó 
            gyakorlati tapasztalatok ebben a 
            tanulási folyamatban nélkülözhetetlenek. Ezeknek a tapasztalatoknak a 
            megszerzését akartuk segíteni a könyvhöz készített esettanulmányokkal és a 
            szereplő további, mindenféle - általunk érdekesnek ítélt - példákkal. 
            Ezeken túl még azt tudjuk javasolni az érdeklődő Olvasónak, hogy 
            folyamatosan tanulmányozza a fejlesztői portálok cikkeit, például
            Java tekintetében a <citation>SUN JAVA CIKKEK</citation> portál cikkeit, vagy
            például mobil programozás tekintetében a 
            <citation>FORUM NOKIA CIKKEK</citation> portál fejlesztői cikkeit.            
            </para>
                        
            <sect3 id="titkosito_gui">
                <title>Bepillantás a GUI programozásba</title>
                
                    <para>
                        Grafikus felület építésére a Java SE keretein belül az
                        AWT, <classname>java.awt.*</classname>
                        és a 
                        Swing <classname>javax.swing.*</classname>
                        csomagok szolgálnak. Az előbbi a kezdetek óta része
                        a Javanak, az utóbbi a Java 1.3-tól része a JDK-nak, azaz
                        a Java 2 platform 1.3 verziójától. 
                    </para>
                        
                    <para>
                        A Java ME, MIDP keretein belül sem az AWT, sem a Swing csomag
                        nem elérhető, a mobilokon a grafikus felület felépítésére
                        a <classname>javax.microedition.lcdui.*</classname>
                        csomag használandó. Ennek a csomagnak a bevezetését a 
                        <emphasis><link linkend="labirintus_midlet">Java a mobiltelefonokban: MIDlet objektumok - Labirintus MIDlet</link></emphasis>
                        című pont alatt tárgyaljuk.
                    </para>
                        
                    <para>                        
                        Az AWT programozása
                        egyszerűbb, de az AWT-vel felépített felület kinézete
                        platformfüggő. A Swing programozása - a párhuzamosság,
                        azaz a szálkezelés - miatt némileg bonyolultabb. A
                        kézikönyvben számos AWT-s felületű példát találunk, 
                        ilyenek például a 
                        <emphasis><link linkend="galton_kiserlet">Galton deszka kísérlet</link></emphasis>,
                        a
                        <emphasis><link linkend="conway">Sejtautomata szimuláció programja</link></emphasis>                        
                        vagy például a 
                        <emphasis><link linkend="mandelbrot_halmaz">Mandelbrot halmaz programja</link></emphasis>
                        című pontokban fejlesztett osztályok.                        
                        Ebben
                        a pontban Swinges példákat fogunk fejleszteni.
                    </para>
                
                    <para>
                        A Java felületépítés erőssége, hogy nem kell pixel
                        pontossággal megterveznünk a grafikus felület kinézetét -
                        például egy nyomógomb komponens méretét, helyzetét -, 
                        hanem mindenféle elhelyezési stratégiát követhetünk, amik
                        helyettünk meghatározzák a komponensek pontos elhelyezést.
                        Kellemes ez, ha arra gondolunk, hogy programunk ablakának
                        természetes tulajdonsága az átméretezhetősége. Mi mégis egy
                        olyan példával indítunk most, ahol nem használunk elhelyezési
                        stratégiát, hanem magunk írjuk elő a használt komponensek
                        méretét és helyzetét. Ezt azért is tehetjük meg bátran, mert
                        az integrált fejlesztői környezetek, mint például az általunk
                        használni javasolt NetBeans is, hatékony támogatást adnak
                        a felület egérrel történő összehúzogatására, miközben eleve
                        azt a felületet látjuk, amit építünk éppen. Ezért térünk
                        most vissza az ősi módszerhez: négyzethálós, matekfüzet
                        lapján tervezzük meg a felületet. Egy ilyen skiccet
                        mutatunk a következő ábrán, a korábban, a
                        <emphasis><link linkend="exor_titkosito">Kizáró vagyos titkosítás</link></emphasis>                        
                        című pontban tárgyalt exor
                        titkosítást megvalósító 
                        programunkat látjuk most el grafikus felülettel.
                        
                    </para>
                    
                    <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/prog/exorgui.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az exor titkósító felületének terve.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                
                    </para>
                    <para>
                        
                        <programlisting>
                        <![CDATA[
public class ExorTitkositoGUI extends javax.swing.JFrame {
    
    public ExorTitkositoGUI() {
        // Az ablak adatai, fejléce:
        super("Javat tanitok példa");
        // az ablakot ne lehessen átméretezni, mert
        setResizable(false);
        // nem használunk elhelyezési stratégiát (hanem majd mi mondjuk meg,
        // melyik komponens melyik pozíción és mekkora legyen).
        getContentPane().setLayout(null);
        // az ablak mérete
        setBounds(100, 50, 210, 250);
        // az ablak szokásos bezár gombjára kilép a program:
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        // a titkosító kulcs szövegmezője
        final javax.swing.JTextField kulcsTextField 
                = new javax.swing.JTextField();
        kulcsTextField.setText("kulcs");
        kulcsTextField.setBounds(5, 5, 130, 20);
        kulcsTextField.setToolTipText("Titkosító kulcs");
        getContentPane().add(kulcsTextField);
        // a tiszta szöveg doboza
        final javax.swing.JTextArea tisztaTextArea
                = new javax.swing.JTextArea();
        javax.swing.JScrollPane tisztaScrollPane
                = new javax.swing.JScrollPane();
        tisztaScrollPane.setViewportView(tisztaTextArea);
        tisztaScrollPane.setBounds(5, 30, 190, 80);
        tisztaScrollPane.setToolTipText("A kódolandó/dekódolandó szöveget írd ide!");
        getContentPane().add(tisztaScrollPane);
        // a titkos szöveg doboza
        final javax.swing.JTextArea titkosTextArea
                = new javax.swing.JTextArea();
        javax.swing.JScrollPane titkosScrollPane
                = new javax.swing.JScrollPane();
        titkosScrollPane.setViewportView(titkosTextArea);
        titkosScrollPane.setBounds(5, 125, 190, 80);
        titkosScrollPane.setToolTipText("Itt kapod az eredményt.");
        getContentPane().add(titkosScrollPane);
        // a kódoló/dekódoló gomb
        javax.swing.JButton kódolButton
                = new javax.swing.JButton();
        kódolButton.setText("K/D");
        kódolButton.setBounds(140, 5, 55, 20);
        kódolButton.setToolTipText("Kódolás/Dekódolás");
        kódolButton.addActionListener(
                new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent
                    e) {
                byte [] kulcs =  kulcsTextField.getText().getBytes();
                byte [] buffer = tisztaTextArea.getText().getBytes();
                int kulcsIndex = 0;
                
                for(int i=0; i<buffer.length; ++i) {
                    
                    buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                    kulcsIndex = (kulcsIndex+1) % kulcs.length;                    
                }
                
                System.out.println(new String(buffer));
                titkosTextArea.setText(new String(buffer));
            }
        });
        getContentPane().add(kódolButton);
        // Lássuk!
        setVisible(true);
    }
    
    public static void main(String [] args) {
        new ExorTitkositoGUI();
    }
}
                        ]]>
                        </programlisting>                    

                        Az exor titkosítós, immár grafikus köntösbe
                        öltöztetett példánk kódol.
                        
                    </para>
                    <para>
                    
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/prog/exorgui1.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az exor titkósító kódol.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                
                        
                    </para>
                    <para>
                        
                        A kódolt szöveget visszamásoltuk a tiszta
                        szöveg dobozába, majd újra kódolva dekódoltuk.
                        
                    </para>
                    <para>
                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/prog/exorgui2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az exor titkósító dekódol.</phrase>
                            </textobject>	
                        </inlinemediaobject>                                                

                        </para>

                        <para>
                            A Swinges programozási tapasztalatainkat a 
                            <emphasis><link linkend="pontmatrix">Genomi, aminosav vagy akár tetszőleges szekvenciák összehasonlítása</link></emphasis>
                            című pont tanulmányozásával növelhetjük, ahol egy menüsorral
                            is felszerelt felületű programot írunk. Továbbá rámutatunk a 
                            Swing programozásban leginkább szem előtt tartandó programozási
                            gyakorlatra, miszerint ne csináltassunk időigényes dolgokat az
                            eseménykezelőkben, mert ez a felület lefagyását okozhatja. Mivel
                            az eseménykezelést és a megjelenítést ugyanaz a programszál 
                            végzi, így
                            ha az eseménykezelőt egy hosszadalmas számítással blokkoljuk, 
                            akkor
                            ezzel egyben a felület megjelenítését is blokkoljuk! (Amit
                            tipikusan a program lefagyásaként szoktunk értékelni.)
                        </para>
                        
            </sect3>
            
            <sect3>
                <title>Bepillantás a hálózati programozásba</title>

                    <para>
                        Javaban hálózati programozás tekintetében a TCP/IP
                        jelölte absztrakciós szinten és a felett URL osztályokkal,
                        Java szervletekkel, a Java távoli metódushívásával vagy
                        CORBA szinten dolgozhatunk.
                    </para>

                    <para>
                        A TCP/IP-nek megfelelő osztályok absztrakciós szintje
                        alá Javaban nem hatolhatunk, csak érdekességként 
                        jegyezzük meg, hogy ennek megfelelően például
                        Javaban nem tudunk ICMP ping jellegű programot írni.
                        A ping programot szoktuk használni, ha arra vagyunk
                        kíváncsiak, hogy egy távoli gép elérhető-e egyáltalán.
                        Elérhető például a <hardware>niobe</hardware>?
                        <screen>
                            <![CDATA[
C:\Documents and Settings\norbi> ping niobe

niobe [192.168.1.1] pingelése 32 bájt méretű adatokkal:

Válasz 192.168.1.1: bájt=32 idő<10 ezredmp. TTL=64
Válasz 192.168.1.1: bájt=32 idő<10 ezredmp. TTL=64
Válasz 192.168.1.1: bájt=32 idő<10 ezredmp. TTL=64
Válasz 192.168.1.1: bájt=32 idő<10 ezredmp. TTL=64

192.168.1.1 ping-statisztikája:
    Csomagok: küldött = 4, fogadott = 4, elveszett = 0 (0% veszteség),
Oda-vissza út ideje közelítőlegesen, milliszekundumban:
    minimum = 0ms, maximum = 0ms, átlag = 0ms                            
                            ]]>
                        </screen>     
                    </para>
                    
                    <para>
                        A ping jellegű programok és általában a nyers
                        socketek használata tekintetében a 
                        <citation>PROGRAMOZÓ PÁTERNOSZTER JEGYZET</citation> jegyzetet
                        ajánljuk az érdeklődő Olvasó figyelmébe, ahol e mélység felett, a 
                        socket interfész absztrakciós szintjén nemcsak TCP-s, hanem 
                        UDP-s Java példákat is találhatunk. 
                    </para>

                    <para>
                    Ugyancsak érdekességként jegyezzük meg,
                    hogy az 1.4 Java változatban megjelenő <classname>java.nio</classname>
                    csomag felhasználásával már Javaban is
                    írhatunk nem blokkolódó, multiplexelt szervereket!
                    E téma kapcsán ugyancsak a
                    <citation>PROGRAMOZÓ PÁTERNOSZTER JEGYZET</citation> jegyzetet
                    ajánljuk az érdeklődő Olvasók figyelmébe.
                    </para>
                    
                    
					<sect4>
					<title>A kézikönyv hálózati programjai</title>
									
						<para>
<emphasis><link linkend="elso_java">Az első Java tapasztalatok</link></emphasis>
 című pontban egy egyszerű, a socket interfész absztrakciós szintjén üzemelő
 TCP-s kliens-szerver modellt mutattunk be.   
<emphasis><link linkend="java_csharp">A Java és a C Sharp összehasonlítása</link></emphasis>
 című pontban ugyanez a példánk már többszálú változatban jelenik meg. Ugyanezen az
 absztrakciós szinten működik egy labirintusos esettanulmányunk,
  illetve egyre magasabb szintekre épülnek az alábbi labirintusos példák.
  
            <itemizedlist>
                            <listitem>
                                <para>Szerveroldali Java</para>
                                    <orderedlist numeration="loweralpha">
                                        <listitem>
                                            <para><link linkend="labirintus_socket">java.net csomag</link></para>
                                        </listitem>
                                        <listitem>
                                            <para><link linkend="labirintus_servlet">Java Servlet</link></para>
                                        </listitem>
                                        <listitem>
                                            <para><link linkend="labirintus_rmi">Java RMI</link></para>
                                        </listitem>
                                        <listitem>
                                            <para><link linkend="labirintus_idl">Java IDL</link></para>
                                        </listitem>
                                    </orderedlist>
                                </listitem>
                                <listitem>
                                    <para><link linkend="elosztott_labirintus">CORBA - elosztott programozás heterogén OO környezetben</link></para>
                            </listitem>
                            </itemizedlist>                            
  
  						</para>
                    
                    </sect4>
                                        
            </sect3>

            <sect3>
                <title>Esettanulmány: egy chat program</title>

                    <para>A következő rész labirintusos esettanulmányainak technikai
                    bevezetéseként készítsünk ebben a pontban egy csevegő (chat) programot.
                    Pontosabban egy TCP/IP és egy CORBA szinten üzemelő változatot. Vegyük majd észre,
                    hogy a CORBA implementáció mennyivel kevesebb és egyszerűbb programozási
                    munkát igényel a fejlesztőtől!
                    </para>

                       <warning>
                        <title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>                           
                           <para>
                               A következő Java nyelvű példák bevezetők a labirintusos
                               esettanulmányokhoz.
                           </para>
                           <para>                               
                               Ezen példák forrásait csupán fussa át a kezdő Olvasó,
                               hogy szeme szokja a Java nyelvet, vagy éppen a CORBA
                               architektúrát.
                               Ha eközben a források megértésében bármi 
                               zavar támadna - és a teljesen kezdőknél nyilvánvalóan támadni fog - akkor
                               most bátran hagyja ki őket, s
                               ha majd feldolgozta a 
<emphasis><link linkend="sajat_vilagok">Saját világok teremtése és Java alapok</link></emphasis>
 című fejezetet, az után, tehát a labirintusos esettanulmányok előtt
                               térjen vissza ide és írja meg (próbálja ki)
                               ezeket a programokat.
                           </para>
                       </warning>

				<sect4>
                <title>TCP/IP alapú csevegő</title>
                
					<para>
					<emphasis><link linkend="java_csharp">A Java és a C Sharp összehasonlítása</link></emphasis> című pontban feldolgozott <classname>Szerver</classname> osztályt fejlesztjük itt tovább.
					Arra kell figyelnünk, hogy az említett példa párhuzamos szálait együttesen 
					el kell tudni
					érnünk, mert a csevegő lényege, hogy az egyik klienstől érkező üzenetet
					továbbítjuk az összes éppen csatlakoztatott klienshez. Tehát a kommunikáció immár
					nem lehet a <classname>Kiszolgáló</classname> szál objektum és a kliens csak
					kettejüket érintő 
					magánügye.
                    </para>
                    
					<para>
					A csatlakozott csevegőket a <varname>csevegők</varname> 
					<classname>List</classname> osztálybeli lista objektumban 
					tartjuk nyilván. A szerver
					működésének szervezésében 
					részben követjük a <citation>JAVA PÉLDA WEBSZERVER</citation> 
					cikkben is olvasható ötletet, miszerint a szerver indulásakor 
					előre több kiszolgáló szálat
					készítünk, amiket azonnal el is altatunk. Ha egy kliens jelentkezik, akkor
					a vele való kommunikációhoz felébresztünk egy ilyen előre elkészített 
					és elaltatott szálat.
					A hivatkozott cikkel szemben viszont, ha esetünkben elfogynak 
					a hadra fogható szálak,
					akkor nem igény szerint készítünk újakat, hanem egy rövid üzenetben 
					közöljük a klienssel, hogy a csevegő szoba tele van, azaz nem tesszük
					számára lehetővé a jelen pillanatbeli csevegésbe való bekapcsolódást. 
                    </para>
                    
                    <para>
                    Egészen pontosan két listát is üzemben tartunk.
					 A <varname>csevegők</varname> listában az éppen dolgozó hálózati 
					 szálakat, azaz az éppen csevegést bonyolító szálakat tartjuk. Míg a
					 <varname>nemCsevegők</varname> listában az éppen nem dolgozó, azaz
					 alvó szálakat tartjuk.
					 
                       <programlisting>
                        <![CDATA[
    /** Itt tartjuk az éppen csevegést lebonyolító szálakat. */
    private java.util.List<Kiszolgáló> csevegők;
    /** Itt tartjuk az éppen csevegést nem bonyolító szálakat. */
    private java.util.List<Kiszolgáló> nemCsevegők;
                        ]]>
                        </programlisting>        
                        					 
					  Kezdetben minden elkészített és alvó
					  szál ebben a listában kap helyet.
					  
                       <programlisting>
                        <![CDATA[
        nemCsevegők = new java.util.ArrayList<Kiszolgáló>();
        csevegők = new java.util.ArrayList<Kiszolgáló>();
        // Csevegő szálak elkészítése
        for(int i=0; i<MAX_CSEVEGŐ; ++i)
            nemCsevegők.add(new Kiszolgáló(this));
                        ]]>
                        </programlisting>        					 
                        
                        A listák kezelését pedig az alábbi három, objektum szinten
                         szinkronizált metódusra korlátozzuk:
                       <programlisting>
                        <![CDATA[
    /**
     * Egy szálat átteszünk a nem csevegők közül a csevegőkbe.
     * Az alábbi három, az adott szerverhez tartozó nem csevegőket
     * a csevegőket kezelő módszer közül mindig csak egy futhat, ezt
     * az objektum szintű szinkronizált módszerek használatával
     * biztosítottuk.
     */
    public synchronized Kiszolgáló beszáll() {
        
        if(!nemCsevegők.isEmpty()) {
            Kiszolgáló kiszolgáló = nemCsevegők.remove(0);
            csevegők.add(kiszolgáló);
            return kiszolgáló;
        }
        return null;
    }
    /**
     * Egy szál aktuális működése végének leadminisztrálása.
     *
     * @param csevegő   szál, aki éppen befejezte működését.
     */
    public synchronized void kiszáll(Kiszolgáló csevegő) {
        csevegők.remove(csevegő);
        nemCsevegők.add(csevegő);
    }
    /**
     * Üzenet küldése a csevegő klienseknek.
     *
     * @param üzenet    amit minden kliensnek el kell küldeni.
     */
    public synchronized void mindenkihez(String üzenet) {
        
        for(Kiszolgáló csevegő: csevegők)
            csevegő.üzenet(üzenet);
        
    }                        
                        ]]>
                        </programlisting>        					 
                        
                        Ezzel biztosítjuk, hogy adott <classname>CsevegőSzerver</classname>
                        objektum e három metódusa közül egyszerre csak egy fusson, s így ne
                        zavarodjon össze a csevegő és a nem csevegő szálak adminisztrálása! 
                        
                        
                    </para>

					<sect5>
					<title>A CsevegőSzerver és a Kiszolgáló osztály</title>
					
                        <programlisting>
                        <![CDATA[
/*
 * CsevegőSzerver.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * Egy csevegőt kiszolgáló szál.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
class Kiszolgáló implements Runnable {
    /** A csevegő szerver, aki ezt a kiszolgáló szálat készítette és
     * használja. */
    CsevegőSzerver szerver;
    /** A kiszolgálást ezen a TCP/IP kapcsolatot absztraháló
     * objektumon kersztül végezzük éppen. */
    java.net.Socket socket;
    /** A kapcsolat feletti kimenő csatorna (látnia kell a többi
     * kiszolgálást végző szálnak is) */
    java.io.PrintWriter kimenőCsatorna;
    /** Dolgozik éppen vagy sem az objektum? */
    boolean kiszolgál = false;
    /**
     * A {@code Kiszolgáló} objektumot felépítő konstruktor.
     *
     * @param   szerver a csevegő szálakat összefogó szerver.
     */
    public Kiszolgáló(CsevegőSzerver szerver) {
        
        this.szerver = szerver;
        // Készítjük a szálat és indítjuk, az ennek
        // megfelelő run() módszerben pedig azonnal
        // altatjuk majd az indított szálat.
        new Thread(this).start();
        
    }
    /**
     * A szál kiszolgálását indító függvény.
     *
     * @param   socket  kapcsolat a TCP/IP-s klienssel.
     */
    public synchronized void kiszolgál(java.net.Socket socket) {
        this.socket = socket;
        kiszolgál = true;
        // A run()-ban alvó szálat ébresztjük, az ott a
        // wait()-nál várakozó végrehajtási szál elindul.
        notify();
    }
    /**
     * Üzenet a kliensnek.
     *
     * @param üzenet amit el köldünk a kliensnek.
     */
    public void üzenet(String üzenet) {
        kimenőCsatorna.println(üzenet);
        kimenőCsatorna.flush();
    }
    /**
     * A kliensek kiszolgálását végző szál.
     */
    public synchronized void run() {
        for(;;) {
            // Tétlenül várakozik addig, amig nincs kliens
            while(!kiszolgál)
                try{
                    // a várakozásból a notify() hívás ébreszti majd fel.
                    wait();
                } catch(InterruptedException e) {}
            // Kimenő és bejövő csatorna objektumokat elkészítjük.
            try {
                java.io.BufferedReader bejövőCsatorna =
                        new java.io.BufferedReader(
                        new java.io.InputStreamReader(socket.getInputStream()));
                kimenőCsatorna =
                        new java.io.PrintWriter(socket.getOutputStream());
                // Addig olvasunk, amig ki nem lép a kliens
                // a vege parancs begépelésével.
                String sor = bejövőCsatorna.readLine();
                do {
                    if("vege".equals(sor))
                        break;
                    // Visszahívjuk a szervert, hogy a klienstől
                    // beolvasott üzenetet eljutassa minden csevegőhöz:
                    szerver.mindenkihez(sor);
                    
                } while((sor = bejövőCsatorna.readLine()) != null);
                
            } catch(java.io.IOException ioE) {
                
                ioE.printStackTrace();
                
            } finally {
                
                try{
                    socket.close();
                    szerver.kiszáll(this);
                    kiszolgál = false;
                } catch(java.io.IOException ioE) {}
                
            }
        }
    }
}
/**
 * A csevegő szerver.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class CsevegőSzerver {
    /** Maximum hány csevegő fér be. */
    public static final int MAX_CSEVEGŐ = 20;
    /** Itt tartjuk az éppen csevegést lebonyolító szálakat. */
    private java.util.List<Kiszolgáló> csevegők;
    /** Itt tartjuk az éppen csevegést nem bonyolító szálakat. */
    private java.util.List<Kiszolgáló> nemCsevegők;
    /** A <code>CsevegőSzerver</code> objektumot felépítő konstruktor. */
    public CsevegőSzerver() {
        nemCsevegők = new java.util.ArrayList<Kiszolgáló>();
        csevegők = new java.util.ArrayList<Kiszolgáló>();
        // Csevegő szálak elkészítése
        for(int i=0; i<MAX_CSEVEGŐ; ++i)
            nemCsevegők.add(new Kiszolgáló(this));
        // Szerver indítása
        try {
            java.net.ServerSocket serverSocket =
                    new java.net.ServerSocket(2006);
            
            while(true) {
                java.net.Socket socket = serverSocket.accept();
                Kiszolgáló szál = beszáll();
                if(szál == null) {
                    // Ha betelt a csevegő szoba, akkor egy
                    // rövid tájékoztató üzenet a kliensnek:
                    java.io.PrintWriter kimenőCsatorna =
                            new java.io.PrintWriter(socket.getOutputStream());
                    kimenőCsatorna.println("A csevegő szoba tele van!");
                    socket.close();
                } else // Ha van szabad csevegő szál, akkor
                    // azzal elkezdődik a csevegő kliens kiszolgálása.
                    szál.kiszolgál(socket);
            }
            
        } catch(java.io.IOException ioE) {
            ioE.printStackTrace();
        }
    }
    /**
     * Egy szálat átteszünk a nem csevegők közül a csevegőkbe.
     * Az alábbi három, az adott szerverhez tartozó nem csevegőket
     * a csevegőket kezelő módszer közül mindig csak egy futhat, ezt
     * az objektum szintű szinkronizált módszerek használatával
     * biztosítottuk.
     */
    public synchronized Kiszolgáló beszáll() {
        
        if(!nemCsevegők.isEmpty()) {
            Kiszolgáló kiszolgáló = nemCsevegők.remove(0);
            csevegők.add(kiszolgáló);
            return kiszolgáló;
        }
        return null;
    }
    /**
     * Egy szál aktuális működése végének leadminisztrálása.
     *
     * @param csevegő   szál, aki éppen befejezte működését.
     */
    public synchronized void kiszáll(Kiszolgáló csevegő) {
        csevegők.remove(csevegő);
        nemCsevegők.add(csevegő);
    }
    /**
     * Üzenet küldése a csevegő klienseknek.
     *
     * @param üzenet    amit minden kliensnek el kell küldeni.
     */
    public synchronized void mindenkihez(String üzenet) {
        
        for(Kiszolgáló csevegő: csevegők)
            csevegő.üzenet(üzenet);
        
    }
    /** A csevegő szerver elindítása. */
    public static void main(String [] args) {
        new CsevegőSzerver();
    }
}
                        ]]>
                        </programlisting>                    
					
					</sect5>

					<sect5>
					<title>A csevegő kipróbálása</title>					
					
					<para>
					Az imént ismertetett <classname>Kiszolgáló</classname> és
					<classname>CsevegőSzerver</classname> osztályok forráskódját a
					 <filename>CsevegőSzerver.java</filename> állományba helyezése után
					 fordítunk, majd futtatunk:
					</para>
                        <screen>
                            <![CDATA[
C:\Documents and Settings\norbi> javac CsevegőSzerver.java
C:\Documents and Settings\norbi> java CsevegőSzerver
                            ]]>
                        </screen>
                        
					<para>
					Egy másik ablakból a 
					<command>telnet localhost 2006</command> parancs kiadásával
					csatlakozunk a szerverhez:
					</para>                             
                        <screen>                        
                            <![CDATA[
C:\Documents and Settings\norbi> telnet localhost 2006
egyik vagyok
egyik vagyok
Udv egyik, en a masik vagyok
Szia masik
Szia masik                            
                            ]]>
                        </screen>     
                        
					<para>
					Amiközben egy további másik ablakból is, ugyancsak a 
					 <command>telnet localhost 2006</command> parancs kiadásával
					csatlakozunk a szerverhez:
					</para>                             
                        <screen>                        
                            <![CDATA[
C:\Documents and Settings\norbi> telnet localhost 2006
egyik vagyok
Udv egyik, en a masik vagyok
Udv egyik, en a masik vagyok
Szia masik                            
                            ]]>
                        </screen>     

<!-- A CORBA alapú csevegő a 3. végére, majd mégis vissza!  

<para>
A CORBA implementációt a 
<emphasis><link linkend="corba_alapu_csevego">A CORBA alapú csevegő</link></emphasis> című pontban
bontjuk ki.
</para>                

-->
                        
					</sect5>
					
                </sect4>
                                
				<sect4>
                <title>CORBA alapú csevegő</title>
                
					<para>
					A CORBA alapú megoldásunkat a CORBA objektumok megtervezésével kezdjük.
					Itt természetesen az előző pont tapasztalataiból indulunk ki: a szerverbe
					a kliensek be/ki tudjanak lépni és tudjanak üzenni. A szerver pedig
					tudjon üzenni az összes bent lévő kliensnek. Egyszerű elképzelésünket
					az alábbi IDL interfészekkel írjuk le.
                    </para>
                
					<para>
					A <classname>Kliens</classname> interfésszel a kliens oldali,
					a <classname>Szerver</classname> interfésszel a szerver oldali
					CORBA objektumot írjuk le. 
					A <classname>Kliens</classname> objektumoknak csak üzenni lehet, 
					a <classname>Szerver</classname> objektumba be és kilépni is.
                    </para>
                    
					<sect5>
					<title>A szerver és a kliens oldali IDL interfészek</title>
					
					<para>
                        <programlisting>
                        <![CDATA[
module korba
{
    interface Kliens
    {
        void uzenet(in string uzenet);
    };

    interface Szerver
    {
        void beszall(in Kliens kliens);
        void kiszall(in Kliens kliens);
        void uzenet(in string uzenet);
    };
}; 
                        ]]>
                        </programlisting>                    

					Az <computeroutput>in</computeroutput> szócska annyit jelent az
					IDL nyelven, hogy az utána szereplő paraméter a CORBA objektumba
					befelé megy. A <computeroutput>beszall(in Kliens kliens);</computeroutput>
					metódus deklaráció például azt jelenti, hogy a <classname>Szerver</classname>
					CORBA objektumnak átadjuk a kliens oldali <classname>Kliens</classname> 
					CORBA objektum referenciáját.
					</para>
					
					<para>
					A sikeres tervezőmunka után kiválaszthatjuk azt a programozási nyelvet,
					melyen az IDL interfészekben megálmodott CORBA OO világunkat életre szeretnénk
					kelteni. A szóba jöhető nyelveket a <citation>NYELVI LEKÉPEZÉS</citation>
					című lapon tanulmányozhatjuk. Esetünkben ez természetesen a Java. A JDK
					csomag részeként kapott <command>idlj</command> fordító használatával 
					tudjuk elvégezni a nyelvi leképezést, aminek során az
					<command>idlj</command> legenerálja a megfelelő CORBA specifikus 
					Java forrásállományokat. Az IDL-Java leképezés például azt mondja, hogy az 
					IDL modul Java csomag lesz. Ennek megfelelően az 
					<command>idlj -fall csevego.idl</command> parancs kiadása után
					<filename>korba</filename> könyvtárban keletkeznek a POA objektumadaptereknek
					megfelelő <classname>SzerverPOA</classname> és 
					<classname>KliensPOA</classname> osztályok. (A 
					<parameter class="command">-fall</parameter> kapcsoló azt mondja a 
					fordítónak, hogy a CORBA alapú kommunikációhoz szükséges,
					 a kliens és a szerveroldali Java forrásállományokat is generálja le.)
					Tipikus megoldás, hogy a CORBA objektumok implementációit
					úgy készítjük el, hogy kiterjesztjük a megfelelő POA osztályokat.
					A következő két pontban is ezt a módszert követjük.
					</para>
										
					</sect5>
					
					<sect5>					
					<title>A SzerverKiszolgáló osztály</title>
					
					<para>
					A CORBA objektum elkészítésénél nincs más dolga a fejlesztőnek, mint a 
					<classname>korba.SzerverPOA</classname> osztály kiterjesztésében 
					implementációt írni a <classname>Szerver</classname> interfészben
					deklarált három metódushoz:
                        <programlisting>
                        <![CDATA[
        void beszall(in Kliens kliens);
        void kiszall(in Kliens kliens);
        void uzenet(in string uzenet);
                        ]]>
                        </programlisting>                    
                        Vizsgáljuk meg például az elsőnek megfelelő Java metódus
                        szignatúráját:
                        <programlisting>
                        <![CDATA[
        void beszall(korba.Kliens kliens);
                        ]]>
                        </programlisting>                    
                        
					A leképezést leginkább a szintén az <command>idlj</command> fordító
					generálta <classname>SzerverOperations</classname>
					 Java interfészben érdemes megfigyelni. Következzék most a CORBA
					 kiszolgáló objektum teljes kódja:
					</para>
					
                        <programlisting>
                        <![CDATA[
/*
 * SzerverKiszolgáló.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A <code>csevego.idl</code> leírta Szerver CORBA
 * kiszolgáló objektum megvalósítása.
 *
 * A <code>csevego.idl</code> interfész:
 * <pre>
 * module korba
 * {
 *     interface Kliens
 *     {
 *         void uzenet(in string uzenet);
 *     };
 *
 *     interface Szerver
 *     {
 *         void beszall(in Kliens kliens);
 *         void kiszall(in Kliens kliens);
 *         void uzenet(in string uzenet);
 *     };
 * };  
 * </pre>
 * A <code>korba.*</code> csomag legenerálása:
 * <pre>
 * idlj -fall csevego.idl
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see KorbaCsevegő
 * @see korba.Szerver
 * @see csevego.idl
*/
public class SzerverKiszolgáló
        extends korba.SzerverPOA {
    
    /** Itt tartjuk az éppen csevegő klienseket. */
    private java.util.List<korba.Kliens> csevegők;    
    /** A <code>SzerverKiszolgáló</code> objektum elkászítése. */
    public SzerverKiszolgáló() {
        csevegők = new java.util.ArrayList<korba.Kliens>();        
    }    
    /**
     * Egy CORBA kliens belép a csevegésbe.
     *
     * @param kliens a kliens CORBA objektum.
     */
    public void beszall(korba.Kliens kliens) {
        
        csevegők.add(kliens);
    }
    /**
     * Egy CORBA kliens kilép a csevegésből.
     *
     * @param kliens a kliens CORBA objektum.
     */
    public void kiszall(korba.Kliens kliens) {
        
        csevegők.remove(kliens);
    }
    /**
     * Egy CORBA kliens üzen a csevegőknek.
     *
     * @param üzenet az üzenet.
     */    
    public void uzenet(String üzenet) {
        
        for(korba.Kliens csevegő: csevegők)
            csevegő.uzenet(üzenet);
        
    }
}					
                        ]]>
                        </programlisting>                    
					
					</sect5>
					
					<sect5>					
					<title>A KliensKiszolgáló osztály</title>
					
<para>
Az osztály implementálásánál az előző ponthoz hasonlóan járunk el. Figyeljük meg:
a királyi úton járást jelzi, ha a kódban jóval több a megjegyzés, mint maga a 
tényleges kód!
</para>					
					
                        <programlisting>
                        <![CDATA[
/*
 * KliensKiszolgáló.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A <code>csevego.idl</code> leírta Kliens CORBA
 * kiszolgáló objektum megvalósítása.
 *
 * A <code>csevego.idl</code> interfész:
 * <pre>
 * module korba
 * {
 *     interface Kliens
 *     {
 *         void uzenet(in string uzenet);
 *     };
 *
 *     interface Szerver
 *     {
 *         void beszall(in Kliens kliens);
 *         void kiszall(in Kliens kliens);
 *         void uzenet(in string uzenet);
 *     };
 * };  
 * </pre>
 * A <code>korba.*</code> csomag legenerálása:
 * <pre>
 * idlj -fall csevego.idl
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see KorbaCsevegőKliens
 * @see korba.Kliens
 * @see csevego.idl
*/
public class KliensKiszolgáló
        extends korba.KliensPOA {            
    /**
     * Üzenetet kap a kliens, visszahívták.
     *
     * @param üzenet az üzenet.
     */
    public void uzenet(String üzenet) {        
        System.out.println(üzenet);        
    }
}					
                        ]]>
                        </programlisting>                    
					
					</sect5>

					<sect5>					
					<title>A KorbaCsevegő osztály</title>
					
					<para>
					A <classname>KorbaCsevegő</classname> a csevegőnk szerver oldala.
					Végrehajtja a szerver szokásos, a
<emphasis><link linkend="corba_szerver">A KorbásLabirintus osztály</link></emphasis>
					című pontban külön is részletezett teendőit: felveszi a kapcsolatot az
					ORB szoftverrel, elkészíti a kiszolgáló CORBA objektumot, aminek
					tulajdonságait beállítja az objektumot éltető - POA - adapter 
					segítségével, majd az elkészített objektumot bejegyzi a CORBA objektumok
					telefonkönyvébe: a névszolgáltatóba.   
					</para>
					
                        <programlisting>
                        <![CDATA[
/*
 * KorbaCsevegő.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * Létrehozza és bejegyzi a névszolgáltatóba
 * a CORBA Szervert kiszolgáló objektumot.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see KorbaCsevegőKliens
 * @see korba.Szerver
 * @see SzerverKiszolgáló
 * @see csevego.idl
 */
public class KorbaCsevegő {
    /** A <code>KorbaCsevegő</code> szerver indítása. */
    public KorbaCsevegő() {        
        // A CORBA szerver indítása
        try{
            // Az ORB tulajdonságainak megadása
            java.util.Properties orbTulajdonságok = new java.util.Properties();
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialHost", "localhost");
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialPort", "2006");
            // Az ORB (a metódushívások közvetítőjének) inicializálása
            org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init((String [])null,
                    orbTulajdonságok);
            // A gyökér POA CORBA objektum referenciájának megszerzése
            org.omg.CORBA.Object corbaObjektum =
                    orb.resolve_initial_references("RootPOA");
            // CORBA-s típuskényszerítéssel a megfelelőre
            org.omg.PortableServer.POA gyökérPoa =
                    org.omg.PortableServer.POAHelper.narrow(corbaObjektum);
            // A POA kiszolgáló állapotba kapcsolása:
            gyökérPoa.the_POAManager().activate();
            // A kiszolgáló objektum létrehozása
            SzerverKiszolgáló szerverKiszolgáló =
                    new SzerverKiszolgáló();
            // CORBA objektum referencia elkészítése
            corbaObjektum =
                    gyökérPoa.servant_to_reference(szerverKiszolgáló);
            // CORBA-s típuskényszerítéssel a megfelelőre
            korba.Szerver szerver =
                    korba.SzerverHelper.narrow(corbaObjektum);
            // A névszolgáltató gyökerének, mint CORBA objektum
            // referenciájának megszerzése
            corbaObjektum =
                    orb.resolve_initial_references("NameService");
            org.omg.CosNaming.NamingContextExt névszolgáltatóGyökere
                    = org.omg.CosNaming.NamingContextExtHelper
                    .narrow(corbaObjektum);
            // A kiszolgáló objektum bejegyzése a névszolgáltatóba
            org.omg.CosNaming.NameComponent név[] =
                    névszolgáltatóGyökere.to_name("Csevego");
            névszolgáltatóGyökere.rebind(név, szerver);
            // Várakozás a csevegők jelentkezésére
            orb.run();
        } catch (Exception e) {
            
            e.printStackTrace();
            System.exit(-1);
            
        }        
    }
    /** Elindítja a CORBA csevegő szervert. */
    public static void main(String[] args) {        
            new KorbaCsevegő();
    }
}
                        ]]>
                        </programlisting>                    
					
					</sect5>

					<sect5>					
					<title>A KorbaCsevegőKliens osztály</title>
					
					<para>
					A <classname>KorbaCsevegőKliens</classname> a csevegőnk kliens oldala.
					A kliensek szokásos: <quote>a névszolgáltatáson keresztül megszerzem a 
					kívánt szolgáltatást nyújtó CORBA objektum referenciáját</quote> 
					tevékenységén túl a kód érdekessége, hogy maga is elkészít és
					éltet egy CORBA objektumot, a visszahívható kliensoldali CORBA
					objektumot.
					
					</para>
					
                        <programlisting>
                        <![CDATA[
/*
 * KorbaCsevegőKliens.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * Csatlakozika a CORBA szerverhez és elkészíti a klienst
 * reprezentáló CORBA Kliens kiszolgáló objektumot. 
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see KorbaCsevegő
 * @see korba.Kliens
 * @see KliensKiszolgáló
 * @see csevego.idl
 */
public class KorbaCsevegőKliens {
    /**
     * Csatlakozik a névszolgáltatáson keresztül a 
     * szerverhez és elkészíti a visszahívható kliens objektumot.
     *
     * @param args[0] a csevegő beceneve.
     */
    public static void main(String[] args) {
        
        String becenév = null;
        // ha nem adtuk meg a parancssor-argumentumot,
        // akkor ez az alapértelmezés:
        if(args.length != 1)
            becenév = "Matyi";
        else
            becenév = args[0];
        
        try {
            // Az ORB tulajdonságainak megadása
            java.util.Properties orbTulajdonságok = new java.util.Properties();
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialHost", "localhost");
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialPort", "2006");
            // Az ORB (a metódushívások közvetítőjének) inicializálása
            org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init((String [])null,
                    orbTulajdonságok);
            // A névszolgáltató gyökerének, mint CORBA objektum
            // referenciájának megszerzése
            org.omg.CORBA.Object corbaObjektum =
                    orb.resolve_initial_references("NameService");
            org.omg.CosNaming.NamingContextExt névszolgáltatóGyökere
                    = org.omg.CosNaming.
                    NamingContextExtHelper.narrow(corbaObjektum);
            // A Szerver szolgáltatást nyújtó CORBA objektum
            // referenciájának megszerzése
            korba.Szerver szerver =
                    korba.SzerverHelper.narrow(
                    névszolgáltatóGyökere.resolve_str("Csevego"));
            // A kliens CORBA objektum létrehozása:            
            // A gyökér POA CORBA objektum referenciájának megszerzése
            corbaObjektum =
                    orb.resolve_initial_references("RootPOA");
            // CORBA-s típuskényszerítéssel a megfelelőre
            org.omg.PortableServer.POA gyökérPoa =
                    org.omg.PortableServer.POAHelper.narrow(corbaObjektum);
            // A POA kiszolgáló állapotba kapcsolása:
            gyökérPoa.the_POAManager().activate();
            // A kiszolgáló objektum létrehozása
            KliensKiszolgáló kliensKiszolgáló =
                    new KliensKiszolgáló();
            // CORBA objektum referencia elkészítése
            corbaObjektum =
                    gyökérPoa.servant_to_reference(kliensKiszolgáló);            
            // CORBA-s típuskényszerítéssel a megfelelőre
            korba.Kliens kliens =
                    korba.KliensHelper.narrow(corbaObjektum);
            // A kliens átadja magát a szervernek
            szerver.beszall(kliens);
            // Olvasunk majd ezen a csatornán a csevegő billentyűzetéről
            java.io.BufferedReader inputCsatorna =
                    new java.io.BufferedReader(
                    new java.io.InputStreamReader(System.in));
            // amig a vege parancsot nem gépeli
            String sor = inputCsatorna.readLine();
            do {
                if("vege".equals(sor))
                    break;
                
                szerver.uzenet(becenév+"> "+sor);
                
            } while((sor = inputCsatorna.readLine()) != null );
            // Kijelentkeztetjük magunkat
            szerver.kiszall(kliens);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
                        ]]>
                        </programlisting>                    
					
					</sect5>

					<sect5>
					<title>A csevegő kipróbálása</title>
					
					<para>Elvégezzük az IDL-Java leképezést, majd lefordítjuk a forrásokat:
                        <screen>
                            <![CDATA[
C:\... > idlj -fall csevego.idl
C:\... > javac KorbaCsevegő.java KorbaCsevegőKliens.java korba\*.java
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.                            
                            ]]>
                        </screen>     
					</para>
					
					<para>Indítjuk az ORB szoftvert:
                        <screen>
                            <![CDATA[
C:\Documents and Settings\neuro>start orbd -ORBInitialPort 2006                            
                            ]]>
                        </screen>     
					</para>

					<para>Futtatjuk a csevegő szerverünket:
                        <screen>
                            <![CDATA[
C:\... > java KorbaCsevegő                            
                            ]]>
                        </screen>     
					</para>
					
					<para>Egy másik ablakban egy klienst:
                        <screen>
                            <![CDATA[
C:\... > java KorbaCsevegőKliens
Van bent valaki?
Matyi> Van bent valaki?
Erika> Igen, en itt vagyok!
                            
                            ]]>
                        </screen>     
					</para>
					
					<para>miközben egy másik, további klienst is indítottunk:
                        <screen>
                            <![CDATA[
C:\... > java KorbaCsevegőKliens Erika
Matyi> Van bent valaki?
Igen, en itt vagyok!
Erika> Igen, en itt vagyok!                            
                            ]]>
                        </screen>     
					</para>
					
					<para>
					Megjegyezhetjük, hogy a Java IDL használata mellett lehetőségünk van olyan
					kiszolgáló CORBA objektumok létrehozására is, melyek túlélhetik az őket
					létrehozó szerverek élettartamát, ezek az úgynevezett perzisztens objektumok.
					A majd ebben vagy általában a CORBA világa iránt mélyebben
					 érdeklődő Olvasónak a Java dokumentáció 
					 <filename>docs\technotes\guides\idl\index.html</filename>, 
					 <quote>Java IDL Technology</quote> című lapját 
					  ajánljuk. (A Java dokumentáció telepítéséről
            <emphasis><link linkend="api_doksi">A Java dokumentáció, azaz az API doksi letöltése</link></emphasis> című pontban olvashatunk.)
					</para>
					
					</sect5>
					
                </sect4>
                                    
            </sect3>        
            
        </sect2>
            
    </sect1>
    
    </chapter>            
    
</part>    

<part id="prog_gepen">    
    <title>Programozás gépen</title>
    
    <partintro>
       <para>
            Ebben a részben nemcsak fejben és papíron, hanem főképp 
            gépen dolgozunk! A következő labirintus példák között
            találunk olyan, ami egy gépen, egy mobiltelefonon vagy akár
            több internetes gépen futtatható.
        </para>    
    </partintro>
    
    <chapter id="java_esettanulmanyok">

    <chapterinfo>
        <keywordset>
			  <keyword>objektumorientált programozás</keyword>
			  <keyword>OO programozás</keyword>
			  <keyword>Java programozás</keyword>
              <keyword>programozás</keyword>
              <keyword>programozási példák</keyword>
              <keyword>informatika tanítása</keyword>              
              <keyword>esettanulmányok</keyword>
              <keyword>Java esettanulmányok</keyword>                            
              <keyword>labirintus</keyword>
              <keyword>labirintus esettanulmányok</keyword>                            
              <keyword>Java</keyword>                                          
              <keyword>Java ME</keyword>                                          
              <keyword>Java SE</keyword>                                                        
              <keyword>Applet</keyword>                                          
              <keyword>MIDlet</keyword>
              <keyword>mobil Java</keyword>              
              <keyword>mobiltelefonos Java</keyword>
              <keyword>Servlet</keyword>
              <keyword>Java RMI</keyword>
              <keyword>TCP/IP</keyword>              
              <keyword>CORBA</keyword>
              <keyword>elosztott programozás</keyword>
        </keywordset>
    </chapterinfo>
    
        <title>Java esettanulmányok</title>

    <epigraph>
    <attribution>
        Kernighan-Plauger
        <citetitle>A programozás magasiskolája</citetitle>
    </attribution>
        <para>
            „Tapasztalatunk szerint a program minőségének legjobb
            kritériuma az olvashatóság: ha egy program könnyen olvasható, 
            valószínűleg jó; ha nehezen olvasható, valószínűleg nem jó.”
        </para>
    </epigraph>
                
    <abstract>
        <para>
            Az előző fejezetben kifejlesztett labirintus API számos használati
            esetét dolgozzuk fel ennek a résznek az esettanulmányaiban. 
            Kezdetben elkészítünk
            egy a „tiszta” teremtett OO világunkat bemutató karakteres példát,
            majd egy böngészős, egy mobiltelefonos és számos más, különböző
            absztrakciós szinteken működő hálózati példát. 
        </para>
    </abstract>

    <highlights>
        <para>
            Ebben a gyakorlati programozási részben a következő esettanulmányokat 
            tárgyaljuk:
            <itemizedlist>
                <listitem><para>tiszta OO labirintus</para></listitem>                    
                <listitem><para>böngészős és alkalmazásbeli labirintus</para></listitem>
                <listitem><para>játékszerű teljes képernyős labirintus</para></listitem>
                <listitem><para>mobiltelefonos labirintus</para></listitem>
                <listitem><para>szerveroldali</para>
                    <itemizedlist>
                        <listitem><para>TCP/IP</para></listitem>
                        <listitem><para>Java Servlet</para></listitem> 
                        <listitem><para>Java RMI</para></listitem>
                        <listitem><para>CORBA labirintus</para></listitem>
                    </itemizedlist>
                </listitem>    
                <listitem><para>elosztott CORBA labirintus</para></listitem>
            </itemizedlist>                
        </para>                
    </highlights>        
        
    <sect1>
        <title>Labirintus esettanulmányok Java nyelven</title>
        
        <para>
            A fejezet esettanulmányaival való konkrét, gyakorlati 
            tapasztalatszerzés
            első lépése a labirintusunk
            mikrovilágának leírását tartalmazó
            <classname>javattanitok.labirintus</classname> csomagunk felélesztése,
            ennek menetét a következő 
            <emphasis><link linkend="labirintus_elesztes">A labirintus API felélesztése</link></emphasis>
            című alpontban találjuk meg. Minden további esettanulmány ezt a 
            csomagot használja. A csomag kifejlesztését a következő pont részeként
            írjuk le.
        </para>
                    
        <sect2 id="tiszta_oo">
            <title>A tiszta OO labirintus - Labirintus Világ</title>
            
            <para> A példát az 
            <emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>                című részben vezettük be.
            Majd a korábbi, a Java programozást bevezető pontok példáiban már 
                ennek a fejlesztési munkának a - sokszor leegyszerűsített - 
                forráskód részleteit mutattuk be.           
                Itt elkészítjük labirintusunk végleges világát: magát a labirintust, kincsestől, 
                szörnyestől, hősöstől, a szokásos történettel: miszerint 
                a hős bolyong, a szörnyek próbálják megenni, a kincs várja, 
                hogy rábukkanjanak. 
                A megfelelő osztályokat a 
                <classname>javattanitok.labirintus</classname> csomagba foglaljuk,
                azaz ebben a csomagban fejlesztjük ki labirintusunk API interfészét. 
            </para>
            
            <sect3 id="labirintus_elesztes">
                <title>A labirintus API felélesztése</title>

                <para>
                    Tetszőleges munkakönyvtárunkban hozzuk létre a 
                    <filename class="directory">javattanitok</filename> könyvtárat és azon belül
                    a <filename class="directory">labirintus</filename> könyvtárat! 
                    
                <screen>
                    <![CDATA[
C:\...\Munkakönyvtár> mkdir javattanitok
C:\...\Munkakönyvtár> mkdir javattanitok\labirintus
                    ]]>
                </screen>     
                    
                    Ezzel a <classname>javattanitok.labirintus</classname> Java
                    csomagot leképeztük a munkakönyvtárunkra, a kifejlesztendő
                    osztályokat ide, a <filename class="directory">javattanitok/labirintus</filename> 
                    könyvtárban írjuk majd meg, azaz gyűjtük most össze. Másoljuk
                    ide a következő 
                    <filename>Szereplő.java</filename>,
                    <filename>Hős.java</filename>,
                    <filename>Kincs.java</filename>,                    
                    <filename>Szörny.java</filename>,
                    <filename>Labirintus.java</filename>,
                    <filename>RosszLabirintusKivétel.java</filename>
                    állományokat!
                </para>
                
                <para>
                    Az alábbi állományok kimásolása után a 
                    <emphasis><link linkend="labirintus_api_forditas">A labirintus API fordítása</link></emphasis>                    
                    című pontban folytatjuk a labirintus API lefordításával. (Az állományok 
                    <emphasis><link linkend="forras_letoltes">A példaprogramok forrásainak letöltése</link></emphasis> című pontban ismertetett archívumban is megtalálhatóak.)

                </para>
                                
            <sect4>
                <title>A Szereplő osztály</title>
              
                <para>
                A <classname>Szereplő</classname> osztály írását a 
                <emphasis><link linkend="sajat_szereplok">Saját szereplők feladat</link></emphasis>                
                című pontban kezdtük el fejleszteni. Íme itt a teljes kód:                    
                </para>
                
            <programlisting>
                <![CDATA[
/*
 * Szereplő.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.labirintus;
/**
 * A labirintus szereplőit (kincsek, szörnyek, hős) absztraháló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1 
 * @see javattanitok.labirintus.Labirintus
 */
public class Szereplő {
    /** A szereplő oszlop pozíciója. */
    protected int oszlop;
    /** A szereplő sor pozíciója. */
    protected int sor;
    /** A labirintus, melyben a szereplő van. */
    protected Labirintus labirintus;
    /** A labirintus szélessége. */
    protected int maxSzélesség;
    /** A labirintus magassága. */
    protected int maxMagasság;
    /** Véletlenszám generátor a szereplők mozgatásához. */
    protected static java.util.Random véletlenGenerátor 
            = new java.util.Random();
    /**
     * Létrehoz egy <code>Szereplő</code> objektumot.
     *
     * @param      labirintus       amibe a szereplőt helyezzük.
     */
    public Szereplő(Labirintus labirintus) {
        this.labirintus = labirintus;
        maxSzélesség = labirintus.szélesség();
        maxMagasság = labirintus.magasság();
        // A szereplő kezdő pozíciója a labirintusban
        szereplőHelyeKezdetben();
    }
    /**
     * A szereplő labirintusbeli kezdő pozíciójának meghatározása.
     */
    void szereplőHelyeKezdetben() {
        // Többször próbálkozunk elhelyezni a szereplőt a labirintusban,
        // számolja, hol tartunk ezekkel a próbálkozásokkal:
        int számláló = 0;
        
        do {
            // itt +2,-2-k, hogy a bal alsó saroktól távol tartsuk
            // a szereplőket, mert majd ezt akarjuk a hős kezdő pozíciójának
            oszlop = 2+véletlenGenerátor.nextInt(maxSzélesség-2);
            sor = véletlenGenerátor.nextInt(maxMagasság-2);
            // max. 10-szer próbálkozunk, de ha sikerül nem "falba tenni" a
            // szereplőt, akkor máris kilépünk:
        } while(++számláló<10 && labirintus.fal(oszlop, sor));
        
    }
    /**
     * A szereplő felfelé lép. Ha nem tud, helyben marad.
     */
    public void lépFöl() {
        
        if(sor > 0)
            if(!labirintus.fal(oszlop, sor-1))
                --sor;        
    }
    /**
     * A szereplő lefelé lép. Ha nem tud, helyben marad.
     */
    public void lépLe() {
        
        if(sor < maxMagasság-1)
            if(!labirintus.fal(oszlop, sor+1))
                ++sor;
        
    }
    /**
     * A szereplő balra lép. Ha nem tud, helyben marad.
     */
    public void lépBalra() {
        
        if(oszlop > 0)
            if(!labirintus.fal(oszlop-1, sor))
                --oszlop;
        
    }
    /**
     * A szereplő jobbra lép. Ha nem tud, helyben marad.
     */
    public void lépJobbra() {
        
        if(oszlop < maxSzélesség-1)
            if(!labirintus.fal(oszlop+1, sor))
                ++oszlop;
        
    }
    /**
     * A szereplő (Euklideszi) távolsága egy másik szereplőtől a labirintusban.
     *
     * @param szereplő a másik szereplő
     * @return int távolság a másik szereplőtől.
     */
    public int távolság(Szereplő szereplő) {
        
        return (int)Math.sqrt((double)
        (oszlop - szereplő.oszlop)*(oszlop - szereplő.oszlop)
        + (sor - szereplő.sor)*(sor - szereplő.sor)
        );
        
    }
    /**
     * Egy pozíció (Euklideszi) távolsága egy másik szereplőtől a 
     * labirintusban.
     *
     * @param oszlop a pozíció oszlop koordinátája
     * @param sor a pozíció sor koordinátája
     * @param szereplő a másik szereplő
     * @return int távolság a másik szereplőtől.
     */
    public int távolság(int oszlop, int sor, Szereplő szereplő) {
        
        if(!(oszlop >= 0 && oszlop <= maxSzélesség-1
                && sor >= 0 && sor <= maxMagasság-1))
            return Integer.MAX_VALUE;
        else
            return (int)Math.sqrt((double)
            (oszlop - szereplő.oszlop)*(oszlop - szereplő.oszlop)
            + (sor - szereplő.sor)*(sor - szereplő.sor)
            );
        
    }
    /**
     * Beállítja a szereplő labirintusbeli pozíciójának oszlop 
     * koordinátáját.
     *
     * @param oszlop a szereplő labirintusbeli pozíciójának oszlop 
     * koordinátája.
     */
    public void oszlop(int oszlop) {
        
        this.oszlop = oszlop;
        
    }
    /**
     * Beállítja a szereplő labirintusbeli pozíciójának sor koordinátáját.
     *
     * @param sor a szereplő labirintusbeli pozíciójának sor koordinátája.
     */
    public void sor(int sor) {
        
        this.sor = sor;
        
    }
    /**
     * Megadja a szereplő labirintusbeli pozíciójának oszlop koordinátáját.
     *
     * @return int a szereplő labirintusbeli pozíciójának oszlop koordinátája.
     */
    public int oszlop() {
        
        return oszlop;
        
    }
    /**
     * Megadja a szereplő labirintusbeli pozíciójának sor koordinátáját.
     *
     * @return int a szereplő labirintusbeli pozíciójának sor koordinátája.
     */
    public int sor() {
        
        return sor;
        
    }

    public String toString() {
    
        return "SZEREPLŐ oszlop = " 
                + oszlop
                + " sor = "
                + sor;
    }    
}                
                ]]>
            </programlisting>
                               
			<para>
			A <classname>Szereplő</classname> osztály tagként tartalmazza annak a 
			labirintusnak a referenciáját, amelybe belehelyezzük. Ez furcsa lehet annak
			az Olvasónak, 
			aki gondolkodása szerint a labirintusnak van szereplője és nem a szereplőnek
			labirintusa. Viszont az első esetben, tehát ha a 
			<classname>Szereplő</classname> osztályunk ezt a tagot nem tartalmazná, akkor
			a szereplő mozgását adó metódusoknak mindig át kellene adni a labirintus 
			referenciáját is, hogy ezek a mozgató függvények tudják, le tudják kérdezni, hogy
			hová léptethetik a szereplőt.
			</para>
                               
            </sect4>
            
            <sect4 id="hos_java">
                <title>A Hős osztály</title>

                <para>
                Ez a pont folytatása 
						<emphasis><link linkend="osztalyok_fejlodese">Az osztályok fejlődése: az öröklődés</link></emphasis> című pontban megkezdett, a labirintus hősét boncolgató gondolatmenetnek.
                </para>
                
                <programlisting>
                    <![CDATA[
/*
 * Hős.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.labirintus;
/**
 * A labirintus hősét leíró osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.labirintus.Labirintus
 */
public class Hős extends Szereplő {
    /** A labirintusban megtalált kincsek értékei. */
    protected int megtaláltÉrtékek;
    /** A hős életeinek maximális száma. */
    public static final int ÉLETEK_SZÁMA = 5;
    /** A hős életeinek száma. */
    protected int életekSzáma = ÉLETEK_SZÁMA;
    /**
     * Létrehoz egy <code>Hős</code> objektumot.
     *
     * @param      labirintus       amelyben a hős bolyongani fog.
     */
    public Hős(Labirintus labirintus) {
        super(labirintus);
        megtaláltÉrtékek = 0;
    }
    /**
     * Gyüjtögeti a megtalált kincseket.
     *
     * @param      kincs       amit éppen magtalált a hős.
     */
    public void megtaláltam(Kincs kincs) {
        
        megtaláltÉrtékek += kincs.érték();
        
    }
    /**
     * Jelzi, hogy éppen megettek.
     *
     * @return true ha a hősnek még van élete, ellenkező esetben, 
     * azaz ha az összes élete elfogyott már, akkor false.
     */
    public boolean megettek() {
        
        if(életekSzáma > 0) {
            --életekSzáma;
            return false;
        } else
            return true;
        
    }
    /**
     * megmondja, hogy élek-e még?
     *
     * @return true ha a hősnek még van élete, ellenkező esetben, azaz 
     * ha az összes élete elfogyott már, akkor false.
     */
    public boolean él() {
        
        return életekSzáma > 0;
        
    }
    /**
     * Megadja az életek számát.
     *
     * @return int az életek száma.
     */
    public int életek() {
        
        return életekSzáma;
        
    }
    /**
     * Megadja a megtalált kincsek összegyüjtögetett értékeit.
     *
     * @return int a megtalált kincsek összegyüjtögetett értékei.
     */
    public int pontszám() {
        
        return megtaláltÉrtékek;
        
    }
   /**
     * A labirintus, amiben a hős mozog.
     *
     * @return Labirintus a labirintus.
     */
    public Labirintus labirintus() {
        
        return labirintus;
        
    }      
}
                    ]]>
                </programlisting>
                                
            </sect4>
             
            <sect4>
                <title>A Kincs osztály</title>
                
                <para>
                A <classname>Kincs</classname> osztály írását a 
                <emphasis><link linkend="sajat_szereplok">Saját szereplők feladat</link></emphasis>                
                című pontban kezdtük el fejleszteni. Íme itt a teljes kód:                    
                </para>
                
                <programlisting>
                    <![CDATA[
/*
 * Kincs.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.labirintus;
/**
 * A labirintus kincseit jellemző osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.labirintus.Labirintus
 */
public class Kincs extends Szereplő {
    /** A kincs értéke. */
    protected int érték;
    /** Megtaláltak már? */
    protected boolean megtalálva;
    /**
     * Létrehoz egy {@code Kincs} objektumot.
     *
     * @param   labirintus  amibe a kincset helyezzük.
     * @param   érték       a kincs értéke.
     */
    public Kincs(Labirintus labirintus, int érték) {
        super(labirintus);
        this.érték = érték;
    }
    /**
     * A szereplő (pl. hős, szörnyek) megtalálta a kincset?
     *
     * @param   hős aki keresi a kincset.
     * @return true ha a kincset éppen most megtalálta a szereplő, 
     * ha éppen nem, vagy már eleve megvan találva a kincs, akkor false.
     */
    public boolean megtalált(Szereplő szereplő) {
        
        if(megtalálva)
        // mert egy kicset csak egyszer lehet megtalálni
            return false;
        
        if(oszlop == szereplő.oszlop()
        && sor == szereplő.sor())
            megtalálva = true;
        
        return megtalálva;
    }
    /**
     * Megadja a kincs értékét.
     *
     * @return  int a kincs értéke.
     */
    public int érték() {
        
        return érték;
        
    }
    /**
     * Megmondja, hogy megtalálták-e már a kincset?
     *
     * @return true ha a kincset már megtalálták, 
     * ha még nem akkor false.
     */
    public boolean megtalálva() {
        
        return megtalálva;
        
    }
    /**
     * A {@code Kincs} objektum sztring reprezentációját adja
     * meg.
     *
     * @return String az objektum sztring reprezentációja.
     */
    public String toString() {
    
        return "KINCS érték = " 
                + érték
                + " megtalálva = "
                + megtalálva;
    }    
}
                    ]]>
                </programlisting>
                
            </sect4>

            <sect4>
                <title>A Szörny osztály</title>

                <para>
                A <classname>Szörny</classname> osztály írását a 
                <emphasis><link linkend="sajat_szereplok">Saját szereplők feladat</link></emphasis>                
                című pontban kezdtük el fejleszteni. Íme itt a teljes kód:                    
                </para>
                
                <programlisting>
                    <![CDATA[
/*
 * Szörny.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.labirintus;
/**
 * A labirintus szörnyeit megadó osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.labirintus.Labirintus
 */
public class Szörny extends Szereplő {
    /** A megevett hősök száma. */
    int megevettHősökSzáma;
    /** A megevett kincsek száma. */
    int megevettKincsekSzáma;
    /**
     * Létrehoz egy <code>Szörny</code> objektumot.
     *
     * @param      labirintus       amibe a szörnyet helyezzük.
     */
    public Szörny(Labirintus labirintus) {
        super(labirintus);
    }
    /**
     * A szörnyek mozgásának vezérlése, ami szerint szörnyek
     * a hős felés igyekeznek.
     *
     * @param hős aki felé a szörny igyekszik
     */
    public void lép(Hős hős) {
        
        int távolság = távolság(hős);
        // Abba az irányba lévő pozícióra lép, amelyben közelebb kerül a hős.
        if(!labirintus.fal(oszlop, sor-1))
            if(távolság(oszlop, sor-1, hős) < távolság) {
            lépFöl();
            return;
            
            }
        
        if(!labirintus.fal(oszlop, sor+1))
            if(távolság(oszlop, sor+1, hős) < távolság) {
            lépLe();
            return;
            
            }
        
        if(!labirintus.fal(oszlop-1, sor))
            if(távolság(oszlop-1, sor, hős) < távolság) {
            lépBalra();
            return;
            
            }
        
        if(!labirintus.fal(oszlop+1, sor))
            if(távolság(oszlop+1, sor, hős) < távolság) {
            lépJobbra();
            return;
            
            }
        
    }
    /**
     * A szörny megette a hőst?
     *
     * @param      hős       aki bolyong a labirintusban.
     */
    public boolean megesz(Hős hős) {
        
        if(oszlop == hős.oszlop()
        && sor == hős.sor()) {
            
            ++megevettHősökSzáma;
            return true;
            
        } else
            return false;
    }    
    /**
     * Számolgatja a megevett kincseket.
     *
     * @param      kincs       amit éppen megettem.
     */
    public void megtaláltam(Kincs kincs) {
        
        ++megevettKincsekSzáma;
        
    }
        /**
     * A {@code Szörny} objektum sztring reprezentációját adja
     * meg.
     *
     * @return String az objektum sztring reprezentációja.
     */
    public String toString() {
        
        return "SZÖRNY megevett hősök = "
                + megevettHősökSzáma
                + "megevett kincsek = "
                + megevettKincsekSzáma;
    }    
}
                    ]]>
                </programlisting>
                
            </sect4>
                        
            <sect4 id="labirintus_osztaly">
                <title>A Labirintus osztály</title>
                
                <para>
                A <classname>Labirintus</classname> osztály írását a 
                <emphasis><link linkend="sajat_labirintus">Saját labirintus feladat</link></emphasis>                
                című pontban kezdtük el fejleszteni. Íme itt a teljes kód:                    
                    
                </para>
                
                <programlisting>
                    <![CDATA[
/*
 * Labirintus.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.labirintus;
/**
 * A labirintust leíró osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class Labirintus {
    /** A labirintus szélessége. */
    protected int szélesség;
    /** A labirintus magassága. */
    protected int magasság;
    /** A labirintus szerkezete: hol van fal, hol járat. */
    protected boolean[][] szerkezet;
    /** A falat a true érték jelenti. */
    final static boolean FAL = true;
    /** Milyen állapotban van éppen a játék. */
    protected int játékÁllapot = 0;
    /** Normál működés, a hőssel időközben semmi nem történt. */
    public static final int JÁTÉK_MEGY_HŐS_RENDBEN = 0;    
    /** A hőst éppen megették, de még van élete. */
    public final static int JÁTÉK_MEGY_MEGHALT_HŐS = 1;
    /** Vége a játéknak, a játékos győzött. */
    public final static int JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN = 2;
    /** Vége a játéknak, a játékos vesztett. */
    public final static int JÁTÉK_VÉGE_MEGHALT_HŐS = 3;
    /** A labirintus kincsei. */
    protected Kincs [] kincsek;
    /** A labirintus szörnyei. */
    protected Szörny [] szörnyek;
    /**
     * Létrehoz egy megadott szerkezetű
     * {@code Labirintus} objektumot.
     */
    public Labirintus() {
        szerkezet = new boolean[][]{
            
    {false, false,  false, true,  false, true,  false, true,  true,  true },
    {false, false, false, false, false, false, false, false, false, false},
    {true,  false, true,  false, true,  false, true,  false, true,  false},
    {false, false, false, false, true,  false, true,  false, false, false},
    {false, true,  true,  false, false, false, true,  true,  false, true },
    {false, false, false, false, true,  false, false, false, false, false},
    {false,  true,  false, false,  false, true,  false, true,  true,  false},
    {false,  false, false, true,  false, true,  false, true,  false, false},
    {false, true, false, false, false, false, false, false, false, true },
    {false, false, false, false,  true,  false, false, false,  true,  true }
    
        };
        
        magasság = szerkezet.length;
        szélesség = szerkezet[0].length;
        
    }
    /**
     * Létrehoz egy paraméterben kapott szerkezetű <code>Labirintus</code> 
     * objektumot.
     *
     * @param      kincsekSzáma       a kincsek száma a labirintusban.
     * @param      szörnyekSzáma      a szörnyek száma a labirintusban.
     * @exception  RosszLabirintusKivétel  ha a labirintust definiáló tömb 
     * nincs elkészítve.
     */
    public Labirintus(boolean[][] szerkezet, int kincsekSzáma, int szörnyekSzáma)
    throws RosszLabirintusKivétel {
        
        if(szerkezet == null)
            throw new RosszLabirintusKivétel("A labirintust definiáló tömb nincs elkészítve.");
        
        this.szerkezet = szerkezet;
        
        magasság = szerkezet.length;
        szélesség = szerkezet[0].length;
        
        kincsekSzörnyek(kincsekSzáma, szörnyekSzáma);
        
    }
    /**
     * Létrehoz egy megadott méretű, véletlen szerkezetű
     * <code>Labirintus</code> objektumot.
     *
     * @param      szélesség          a labirintus szélessége.
     * @param      magasság           a labirintus magassága.
     * @param      kincsekSzáma       a kincsek száma a labirintusban.
     * @param      szörnyekSzáma      a szörnyek száma a labirintusban.
     */
    public Labirintus(int szélesség, int magasság,
            int kincsekSzáma, int szörnyekSzáma) {
        
        this.magasság = magasság;
        this.szélesség = szélesség;
        
        szerkezet = new boolean[magasság][szélesség];
        java.util.Random véletlenGenerátor = new java.util.Random();
        
        for(int i=0; i<magasság; ++i)
            for(int j=0; j<szélesség; ++j)
                if(véletlenGenerátor.nextInt()%3 == 0)
                    // a labirintus egy harmada lesz fal
                    szerkezet[magasság][szélesség] = false;
                else
                    // két harmada pedig járat
                    szerkezet[magasság][szélesség] = true;
        
        kincsekSzörnyek(kincsekSzáma, szörnyekSzáma);
        
    }
    /**
     * Létrehoz egy 10x10-es, beépített szerkezetű <code>Labirintus</code>
     * objektumot.
     *
     * @param      kincsekSzáma       a kincsek száma a labirintusban.
     * @param      szörnyekSzáma      a szörnyek száma a labirintusban.
     */
    public Labirintus(int kincsekSzáma, int szörnyekSzáma) {
        
        this();
        
        magasság = szerkezet.length;
        szélesség = szerkezet[0].length;
        
        kincsekSzörnyek(kincsekSzáma, szörnyekSzáma);
        
    }
    /**
     * Egy megfelelő szerkezetű szöveges állományból elkészít egy új a 
     * <code>Labirintus</code> objektumot.
     * A szöveges állomány szerkezete a következő:
     * <pre>
     * // A labirintus szerkezetét megadó állomány, szerkezete a következő:
     * // a kincsek száma
     * // a szörnyek száma
     * // a labirintus szélessége
     * // magassága
     * // fal=1 járat=0 ...
     * // .
     * // .
     * // .
     * 6
     * 3
     * 10
     * 10
     * 0 0 0 1 0 1 0 1 1 1
     * 0 0 0 0 0 0 0 0 0 0
     * 1 0 1 0 1 0 1 0 1 0
     * 0 0 0 0 1 0 1 0 0 0
     * 0 1 1 0 0 0 1 1 0 1
     * 0 0 0 0 1 0 0 0 0 0
     * 0 1 0 0 0 1 0 1 1 0
     * 0 0 0 1 0 1 0 1 0 0
     * 0 1 0 0 0 0 0 0 0 1
     * 0 0 0 0 1 0 0 0 1 1
     * </pre>
     *
     * @param      labirintusFájlNév       a labirintust definiáló, megfelelő 
     * szerkezetű szöveges állomány neve.
     * @exception  RosszLabirintusKivétel  ha a labirintust definiáló állomány 
     * nincs meg, nem a megfelelő szerkezetű, vagy gond van az olvasásával.
     */
    public Labirintus(String labirintusFájlNév) throws RosszLabirintusKivétel {
        
        int kincsekSzáma = 6;  // ezeknek a kezdőértékeknek nincs jelentősége,
        int szörnyekSzáma = 3; // mert majd a fájlból olvassuk be, amiben ha a 
        // négy fő adat hibás, akkor nem is építjük fel a labirintust.
        
        // Csatorna a szöveges állomány olvasásához
        java.io.BufferedReader szövegesCsatorna = null;
        
        try {
            szövegesCsatorna = new java.io.BufferedReader(
                    new java.io.FileReader(labirintusFájlNév));
            
            String sor = szövegesCsatorna.readLine();
            
            while(sor.startsWith("//"))
                sor = szövegesCsatorna.readLine();
            
            try {
                
                kincsekSzáma = Integer.parseInt(sor);
                
                sor = szövegesCsatorna.readLine();
                szörnyekSzáma = Integer.parseInt(sor);
                
                sor = szövegesCsatorna.readLine();
                szélesség = Integer.parseInt(sor);
                
                sor = szövegesCsatorna.readLine();
                magasság = Integer.parseInt(sor);
                
                szerkezet = new boolean[magasság][szélesség];
                
            } catch(java.lang.NumberFormatException e) {
                
                throw new RosszLabirintusKivétel("Hibás a kincsek, szörnyek száma, szélesség, magasság megadási rész.");
                
            }
            
            for(int i=0; i<magasság; ++i) {
                
                sor = szövegesCsatorna.readLine();
                
                java.util.StringTokenizer st =
                        new java.util.StringTokenizer(sor);
                
                for(int j=0; j<szélesség; ++j) {
                    String tegla = st.nextToken();
                    
                    try {
                        
                        if(Integer.parseInt(tegla) == 0)
                            szerkezet[i][j] = false;
                        else
                            szerkezet[i][j] = true;
                        
                    } catch(java.lang.NumberFormatException e) {
                        
                        System.out.println(i+". sor "+j+". oszlop "+e);
                        szerkezet[i][j] = false;
                        
                    }
                }
            }
            
        } catch(java.io.FileNotFoundException e1) {
            
            throw new RosszLabirintusKivétel("Nincs meg a fájl: " + e1);
            
        } catch(java.io.IOException e2) {
            
            throw new RosszLabirintusKivétel("IO kivétel történt: "+e2);
            
        } catch(java.util.NoSuchElementException e3) {
            
            throw new RosszLabirintusKivétel("Nem jó a labirintus szerkezete: "
                    +e3);
            
        } finally {
            
            if(szövegesCsatorna != null) {
                
                try{
                    szövegesCsatorna.close();
                } catch(Exception e) {}
                
            }
            
        }
        
        // Ha ide eljutottunk, akkor felépült a labirintus,
        // lehet benépesíteni:
        kincsekSzörnyek(kincsekSzáma, szörnyekSzáma);
        
    }
    /**
     * Létrehozza a kincseket és a szörnyeket.
     *
     * @param      kincsekSzáma       a kincsek száma a labirintusban.
     * @param      szörnyekSzáma      a szörnyek száma a labirintusban.
     */
    private void kincsekSzörnyek(int kincsekSzáma, int szörnyekSzáma) {
        // Kincsek létrehozása
        kincsek = new Kincs[kincsekSzáma];
        for(int i=0; i<kincsek.length; ++i)
            kincsek[i] = new Kincs(this, (i+1)*100);
        // Szörnyek létrehozása
        szörnyek = new Szörny[szörnyekSzáma];
        for(int i=0; i<szörnyek.length; ++i)
            szörnyek[i] = new Szörny(this);
        
    }
    /**
     * Megadja a játék aktuális állapotát.
     *
     * @return int a játék aktuális állapota.
     */
    public int állapot() {
        
        return játékÁllapot;
        
    }
    /**
     * A labirintus mikrovilág életének egy pillanata: megnézi, hogy a bolyongó
     * hős rátalált-e a kincsekre, vagy a szörnyek a hősre. Ennek megfelelően
     * megváltozik a játék állapota.
     *
     * @param hős aki a labirintusban bolyong.
     * @return int a játék állapotát leíró kód.
     */
    public int bolyong(Hős hős) {
        
        boolean mindMegvan = true;
        
        for(int i=0; i < kincsek.length; ++i) {
            
            // A hős rátalált valamelyik kincsre?
            if(kincsek[i].megtalált(hős))
                hős.megtaláltam(kincsek[i]);
            
            // ha ez egyszer is teljesül, akkor nincs minden kincs megtalálva
            if(!kincsek[i].megtalálva())
                mindMegvan = false;
            
        }
        
        if(mindMegvan) {
            
            játékÁllapot = JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN;
            return játékÁllapot;
            
        }
        
        for(int i=0; i < szörnyek.length; ++i) {
            
            szörnyek[i].lép(hős);
            
            if(szörnyek[i].megesz(hős))  {
                játékÁllapot = JÁTÉK_MEGY_MEGHALT_HŐS;
                
                if(hős.megettek())
                    játékÁllapot = JÁTÉK_VÉGE_MEGHALT_HŐS;
                
                return játékÁllapot;
            }
            
        }
        
        return JÁTÉK_MEGY_HŐS_RENDBEN;
    }
    /**
     * Madadja, hogy fal-e a labirintus adott oszlop, sor pozíciója.
     *
     * @param oszlop a labirintus adott oszlopa
     * @param sor a labirintus adott sora
     * @return true ha a pozíció fal vagy nincs a labirintusban.
     */
    public boolean fal(int oszlop, int sor) {
        
        if(!(oszlop >= 0 && oszlop <= szélesség-1
                && sor >= 0 && sor <= magasság-1))
            return FAL;
        else
            return szerkezet[sor][oszlop] == FAL;
        
    }
    /**
     * Madadja a labirintus szélességét.
     *
     * @return int a labirintus szélessége.
     */
    public int szélesség() {
        
        return szélesség;
        
    }
    /**
     * Madadja a labirintus magasságát.
     *
     * @return int a labirintus magassága.
     */
    public int magasság() {
        
        return magasság;
        
    }
    /**
     * Megadja a labirintus szerkezetét.
     *
     * @return boolean[][] a labirintus szerkezete.
     */
    public boolean[][] szerkezet() {
        
        return szerkezet;
        
    }
    /**
     * Megadja a labirintus kincseit.
     *
     * @return Kincs[] a labirintus kincsei.
     */
    public Kincs[] kincsek() {
        
        return kincsek;
        
    }
    /**
     * Megadja a labirintus szörnyeit.
     *
     * @return Szörny[] a labirintus szörnyei.
     */
    public Szörny[] szörnyek() {
        
        return szörnyek;
        
    }
    /**
     * Kinyomtatja a labirintus szerkezetét a System.out-ra.
     */
    public void nyomtat() {
        
        for(int i=0; i<magasság; ++i) {
            for(int j=0; j<szélesség; ++j) {
                
                if(szerkezet[i][j])
                    System.out.print("|FAL");
                else
                    System.out.print("|   ");
                
            }
            
            System.out.println();
            
        }
        
    }
    /**
     * Kinyomtatja a labirintus szerkezetét és szereplőit a System.out-ra.
     *
     * @param hős akit szintén belenyomtat a labirintusba.
     */
    public void nyomtat(Hős hős) {
        
        for(int i=0; i<magasság; ++i) {
            for(int j=0; j<szélesség; ++j) {
                
                boolean vanSzörny = vanSzörny(i, j);
                boolean vanKincs = vanKincs(i, j);
                boolean vanHős = (i == hős.sor() && j == hős.oszlop());
                
                if(szerkezet[i][j])
                    System.out.print("|FAL");
                else if(vanSzörny && vanKincs && vanHős)
                    System.out.print("|SKH");
                else if(vanSzörny && vanKincs)
                    System.out.print("|SK ");
                else if(vanKincs && vanHős)
                    System.out.print("|KH ");
                else if(vanSzörny && vanHős)
                    System.out.print("|SH ");
                else if(vanKincs)
                    System.out.print("|K  ");
                else if(vanHős)
                    System.out.print("|H  ");
                else if(vanSzörny)
                    System.out.print("|S  ");
                else
                    System.out.print("|   ");
                
            }
            
            System.out.println();
            
        }
        
    }
    /**
     * Kinyomtatja a labirintus szerkezetét és szereplőit egy
     * karakteres csatornába.
     *
     * @param hős akit szintén belenyomtat a labirintusba.
     * @param csatorna ahova nyomtatunk.
     */
    public void nyomtat(Hős hős, java.io.PrintWriter csatorna) {
        
        for(int i=0; i<magasság; ++i) {
            for(int j=0; j<szélesség; ++j) {
                
                boolean vanSzörny = vanSzörny(i, j);
                boolean vanKincs = vanKincs(i, j);
                boolean vanHős = (i == hős.sor() && j == hős.oszlop());
                
                if(szerkezet[i][j])
                    csatorna.print("|FAL");
                else if(vanSzörny && vanKincs && vanHős)
                    csatorna.print("|SKH");
                else if(vanSzörny && vanKincs)
                    csatorna.print("|SK ");
                else if(vanKincs && vanHős)
                    csatorna.print("|KH ");
                else if(vanSzörny && vanHős)
                    csatorna.print("|SH ");
                else if(vanKincs)
                    csatorna.print("|K  ");
                else if(vanHős)
                    csatorna.print("|H  ");
                else if(vanSzörny)
                    csatorna.print("|S  ");
                else
                    csatorna.print("|   ");
                
            }
            
            csatorna.println();
            
        }
        
    }
    /**
     * Kinyomtatja a labirintus szerkezetét és szereplőit egy sztringbe.
     *
     * @param hős akit szintén belenyomtat a labirintusba.
     * @return String a kinyomtatott labirintus
     */
    public String kinyomtat(Hős hős) {
        
        StringBuffer stringBuffer = new StringBuffer();
        
        for(int i=0; i<magasság; ++i) {
            for(int j=0; j<szélesség; ++j) {
                
                boolean vanSzörny = vanSzörny(i, j);
                boolean vanKincs = vanKincs(i, j);
                boolean vanHős = (i == hős.sor() && j == hős.oszlop());
                
                if(szerkezet[i][j])
                    stringBuffer.append("|FAL");
                else if(vanSzörny && vanKincs && vanHős)
                    stringBuffer.append("|SKH");
                else if(vanSzörny && vanKincs)
                    stringBuffer.append("|SK ");
                else if(vanKincs && vanHős)
                    stringBuffer.append("|KH ");
                else if(vanSzörny && vanHős)
                    stringBuffer.append("|SH ");
                else if(vanKincs)
                    stringBuffer.append("|K  ");
                else if(vanHős)
                    stringBuffer.append("|H  ");
                else if(vanSzörny)
                    stringBuffer.append("|S  ");
                else
                    stringBuffer.append("|   ");
                
            }
            
            stringBuffer.append("\n");
            
        }
        
        return stringBuffer.toString();
    }
    /**
     * Madadja, hogy van-e megtalálható kincs a labirintus
     * adott oszlop, sor pozíciója.
     *
     * @param oszlop a labirintus adott oszlopa
     * @param sor a labirintus adott sora
     * @return true ha van.
     */
    boolean vanKincs(int sor, int oszlop) {
        
        boolean van = false;
        
        for(int i=0; i<kincsek.length; ++i)
            if(sor == kincsek[i].sor()
            && oszlop == kincsek[i].oszlop()
            && !kincsek[i].megtalálva()) {
            van = true;
            break;
            }
        
        return van;
    }
    /**
     * Madadja, hogy van-e szörny a labirintus adott oszlop,
     * sor pozíciója.
     *
     * @param oszlop a labirintus adott oszlopa
     * @param sor a labirintus adott sora
     * @return true ha van.
     */
    boolean vanSzörny(int sor, int oszlop) {
        
        boolean van = false;
        
        for(int i=0; i<szörnyek.length; ++i)
            if(sor == szörnyek[i].sor()
            && oszlop == szörnyek[i].oszlop()) {
            van = true;
            break;
            }
        
        return van;
    }
    /**
     * A labirintussal kapcsolatos apróságok önálló kipróbálására
     * szolgál ez az indító metódus.
     *
     * @param args parancssor-argumentumok nincsenek.
     */
    public static void main(String[] args) {
        
        Labirintus labirintus = new Labirintus(6, 3);
        Hős hős = new Hős(labirintus);
        
        System.out.println(labirintus.getClass());
        System.out.println(hős.getClass());
        
    }
}
                    ]]>
                </programlisting>
                
            </sect4>
            
            <sect4>
                <title>A RosszLabirintusKivétel osztály</title>
                
                <para>
                A <classname>RosszLabirintusKivétel</classname> osztály írását a 
                <emphasis><link linkend="kivetelkezeles">Kivételkezelés</link></emphasis>                
                című pontban kezdtük el fejleszteni. Íme itt a teljes kód:                    
                </para>
                
                <programlisting>
                    <![CDATA[
/*
 * RosszLabirintusKivétel.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.labirintus;
/**
 * Ha állomány alapján készítjük a labirintust, akkor az állomány szerkezetének
 * hibáit jelzi ez az osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.labirintus.Labirintus
 */
public class RosszLabirintusKivétel extends java.lang.Exception {    
    /**
     * Elkészít egy <code>RosszLabirintusKivétel</code> kivétel objektumot.
     *
     * @param hiba a hiba leírása
     */
    public RosszLabirintusKivétel(String hiba) {
        super(hiba);
    }
}
                    ]]>
                </programlisting>
                
            </sect4>

            <sect4 id="labirintus_api_forditas">
                <title>A labirintus API fordítása</title>
                
                <para>
                </para>
                
                <screen>
                    <![CDATA[
C:\...\Munkakönyvtár> javac javattanitok\labirintus\*.java                    
                    ]]>
                </screen>     

                <para>
                    Ha a korábbi Java osztályok kódját hiba nélkül jelöltük ki
                    és illesztettük be a megfelelő állományokba, akkor ez a fordítási
                    parancs gond nélkül lefutott és a 
                    <filename class="directory">javattanitok/labirintus</filename> 
                    könyvtárban létrejöttek az osztályoknak megfelelő 
                    <filename>.class</filename> állományok.
                </para>
                                
            </sect4>
            
            </sect3>
            
            <sect3>
                <title>A LabirintusVilág osztály</title>
            
            <para>
                Ebben a <classname>LabirintusVilág</classname> nevű 
                osztályban keltjük életre az előző pontban kifejlesztett
                <classname>javattanitok.labirintus</classname> API csomagot.
                Csupán egy 
                karakteres megjelenést készítünk, ami jól mutatja, hogyan kel 
                életre a teremtett tiszta OO mikrovilágunk: a labirintus. 
            </para>
            
            <para>
                Nincs más dolgunk, mint a következő 
                <classname>LabirintusVilág</classname> osztályt a 
                <filename class="directory">javattanitok</filename> könyvtárba bemásolni.                
                (Általában is úgy szervezzük a kódokat, hogy a 
                <classname>javattanitok.labirintus</classname> API csomagot
                használó esettanulmányok osztályait a 
                <classname>javattanitok</classname> csomagba helyezzük el.)
            </para>

            <sect4>
                <title>A LabirintusVilág osztály</title>
                
                <para>
                </para>
                
                <programlisting>
                    <![CDATA[
/*
 * LabirintusVilág.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * "tiszta" életre keltésére ad példát ez az osztály. Ennek megfelelően
 * csak egyszerű karakteres megjelenítést biztosít. Fő feladata a
 * kialakított labirintus OO mikrovilágunk API interfésze használatának
 * bemutatása. Továbbá az egyszerűség megtartása miatt ebben a példában
 * még nem vesz át adatokat a játékostól a program.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusApplet
 * @see javattanitok.LabirintusJáték
 * @see javattanitok.LabirintusMIDlet
 * @see javattanitok.LabirintusServlet
 * @see javattanitok.HálózatiLabirintus
 * @see javattanitok.TávoliLabirintus
 * @see javattanitok.KorbásLabirintus
 * @see javattanitok.ElosztottLabirintus
 */
public class LabirintusVilág implements Runnable {
    /** A labirintus. */
    protected Labirintus labirintus;
    /** A hős. */
    protected Hős hős;
    /** A játékbeli idő mérésére.*/
    private long idő = 0;
    public LabirintusVilág() {
    }
    /**
     * A <code>LabirintusVilág</code> objektum elkészítése.
     *
     * @param labirintusFájlNév a labirintust definiáló, megfelelő
     * szerkezetű szöveges állomány neve.
     * @exception RosszLabirintusKivétel ha a labirintust definiáló állomány nem
     * a megfelelő szerkezetű
     */
    public LabirintusVilág(String labirintusFájlNév)
    throws RosszLabirintusKivétel {
        
        // A labirintus elkészítése állományból
        labirintus = new Labirintus(labirintusFájlNév);
        
        // A hős elkészítése és a kezdő pozíciójának beállítása
        hős = new Hős(labirintus);
        hős.sor(9);
        hős.oszlop(0);
        
        // A játékbeli idő folyását biztosító szál elkészítése és indítása
        new Thread(this).start();
        
    }
    /**
     * A játék időbeli fejlődésének vezérlése. A labirintus mikrovilágának
     * jelen osztálybeli életre keltésében max. 10 időpillanatig játszunk,
     * mialatt a hős igyekszik mindig jobbra lépni.
     */
    public void run() {
        
        labirintus.nyomtat();
        
        boolean játékVége = false;
        
        while(!játékVége) {
            
            idoegyseg();
            
            if(idő<10)
                hős.lépJobbra();
            else
                break;
            
            switch(labirintus.bolyong(hős)) {
                
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                    break;
                case Labirintus.JÁTÉK_MEGY_MEGHALT_HŐS:
                    hős.sor(9);
                    hős.oszlop(0);
                    System.out.println("Megettek a(z) " + idő + ". lépésben!");
                    break;
                case Labirintus.JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN:
                    System.out.println("Megvan minden kincs a(z) " + idő
                            + ". lépésben!");
                    játékVége = true;
                    break;
                case Labirintus.JÁTÉK_VÉGE_MEGHALT_HŐS:
                    System.out.println("Minden életem elfogyott a(z) " + idő
                            + ". lépésben!");
                    játékVége = true;
                    break;
                    
            }
            
            System.out.println("A labirintus a(z) " + idő + ". lépésben:");
            labirintus.nyomtat(hős);
        }
        
        System.out.println("Megtalált értékek: " + hős.pontszám());
        System.out.println("Játékidő: " + idő + " lépés");
        System.out.println("Hányszor ettek meg: "
                + (Hős.ÉLETEK_SZÁMA - hős.életek()));
        
    }
    /** Megadja, hogy milyen gyorsan telik az idő a játékban. */
    private void idoegyseg() {
        
        ++idő;
        
        try {
            Thread.sleep(1000);
        } catch(InterruptedException e) {}
    }
    /**
     * Átveszi a játék indításához szükséges paramétereket, majd
     * elindítja a játék világának működését.
     *
     * @param args a labirintus tervét tartalmazó állomány neve az első
     * parancssor-argumentum.
     */
    public static void main(String[] args) {
        
        if(args.length != 1) {
            
            System.out.println("Indítás: java LabirintusVilág labirintus.txt");
            System.exit(-1);
        }
        
        try {
            
            new LabirintusVilág(args[0]);
            
        } catch(RosszLabirintusKivétel rosszLabirintusKivétel) {
            
            System.out.println(rosszLabirintusKivétel);
            
        }
    }
}
                    ]]>
                </programlisting>
              
			<para> 
			Minden esettanulmányra igaz lesz, hogy a játék időfejlődését egy külön
			szálba programozzuk be. Jelen esetben ezt a szálat is a 
			<classname>LabirintusVilág</classname> osztályban 
			
                <programlisting>
                    <![CDATA[
public class LabirintusVilág implements Runnable { 
                    ]]>
                </programlisting>
						
			implementáltuk, ennek megfelelően az időfejlődést a
			 <function>run()</function>
			módszerbe helyeztük.
			</para>
			
            </sect4>
            
            <sect4>
            <title>A tiszta OO labirintus fordítása, futtatása</title>
                
            <para>
            
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> javac javattanitok\LabirintusVilág.java
C:\...\Munkakönyvtár>java javattanitok.LabirintusVilág
Indítás: java LabirintusVilág labirintus.txt
                ]]>
            </screen>     
            
            A program sikeres futtatásához még például az alábbi, 
            <emphasis><link linkend="labirintust_fajlbol">A labirintust állományból felépítő konstruktor</link></emphasis>            
            című pontban megtárgyalt
            <filename>labirintus.txt</filename> állományt kell a             
            <filename>Munkakönyvtár</filename> munkakönyvtárukba bemásolnunk.
            
            <programlisting>
                <![CDATA[
//
// labirintus.txt
//
// DIGIT 2005, Javat tanítok
// Bátfai Norbert, nbatfai@inf.unideb.hu
//
// A labirintus szerkezetét megadó állomány, szerkezete a következő:
// a kincsek száma
// a szörnyek száma
// a labirintus szélessége
// magassága
// fal=1 járat=0 ... 
// .
// .
// .
6
3
10
10
0 0 0 1 0 1 0 1 1 1
0 0 0 0 0 0 0 0 0 0
1 0 1 0 1 0 1 0 1 0
0 0 0 0 1 0 1 0 0 0
0 1 1 0 0 0 1 1 0 1
0 0 0 0 1 0 0 0 0 0
0 1 0 0 0 1 0 1 1 0
0 0 0 1 0 1 0 1 0 0
0 1 0 0 0 0 0 0 0 1
0 0 0 0 1 0 0 0 1 1
                ]]>
            </programlisting>

            Ezután már bizonyosan sikeresen futtathatja a kedves Olvasó
            ezt a példát:
            </para>
                        
            <para>
            
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár>java javattanitok.LabirintusVilág labirintus.txt
                ]]>
            </screen>     
            
            </para>
            
            <para>
            
           <screen>
                <![CDATA[
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |   |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |   |   |FAL|   |FAL|   |   |   
|   |FAL|FAL|   |   |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|   |   |   |   |   
|   |FAL|   |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |   |   |FAL|   |   |   |FAL|FAL
A labirintus a(z) 1. lépésben:
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |S  |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |K  |   |FAL|   |FAL|S  |K  |   
|   |FAL|FAL|   |SK |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |K  |   |   
|   |FAL|K  |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |H  |   |   |FAL|   |   |   |FAL|FAL
A labirintus a(z) 2. lépésben:
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |S  |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |K  |   |FAL|   |FAL|S  |K  |   
|   |FAL|FAL|   |SK |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |K  |   |   
|   |FAL|K  |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |H  |   |FAL|   |   |   |FAL|FAL
A labirintus a(z) 3. lépésben:
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |S  |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |K  |   |FAL|   |FAL|S  |K  |   
|   |FAL|FAL|   |SK |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |K  |   |   
|   |FAL|K  |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |   |H  |FAL|   |   |   |FAL|FAL
A labirintus a(z) 4. lépésben:
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |S  |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |K  |   |FAL|   |FAL|S  |K  |   
|   |FAL|FAL|   |SK |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |K  |   |   
|   |FAL|K  |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |   |H  |FAL|   |   |   |FAL|FAL
A labirintus a(z) 5. lépésben:
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |S  |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |K  |   |FAL|   |FAL|S  |K  |   
|   |FAL|FAL|   |SK |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |K  |   |   
|   |FAL|K  |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |   |H  |FAL|   |   |   |FAL|FAL
A labirintus a(z) 6. lépésben:
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |S  |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |K  |   |FAL|   |FAL|S  |K  |   
|   |FAL|FAL|   |SK |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |K  |   |   
|   |FAL|K  |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |   |H  |FAL|   |   |   |FAL|FAL
A labirintus a(z) 7. lépésben:
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |S  |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |K  |   |FAL|   |FAL|S  |K  |   
|   |FAL|FAL|   |SK |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |K  |   |   
|   |FAL|K  |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |   |H  |FAL|   |   |   |FAL|FAL
A labirintus a(z) 8. lépésben:
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |S  |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |K  |   |FAL|   |FAL|S  |K  |   
|   |FAL|FAL|   |SK |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |K  |   |   
|   |FAL|K  |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |   |H  |FAL|   |   |   |FAL|FAL
A labirintus a(z) 9. lépésben:
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |S  |   |   |   |   |   |   |   
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|   
|   |   |K  |   |FAL|   |FAL|S  |K  |   
|   |FAL|FAL|   |SK |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |K  |   |   
|   |FAL|K  |   |   |FAL|   |FAL|FAL|   
|   |   |   |FAL|   |FAL|   |FAL|   |   
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |   |H  |FAL|   |   |   |FAL|FAL
Megtalált értékek: 0
Játékidő: 10 lépés
Hányszor ettek meg: 0
                ]]>
            </screen>     
            
            </para>
            
            </sect4>                    
            </sect3>


			<sect3>
				<title>A labirintus API és a LabirintusVilág a NetBeans IDE környezetben</title>
				
            <para>
            A példa felélesztését most a <application>NetBeans IDE</application> fejlesztői 
            környezetben is elvégezzük. Az a kedves Olvasó, aki eddig esetleg még nem
            telepítette fel gépére a <application>NetBeans IDE</application>-t, 
<emphasis><link linkend="netbeans">A NetBeans integrált fejlesztői környezet használata</link></emphasis>            
            című pontban kaphat segítséget ehhez.
            
            A <guimenuitem>File/New Project...</guimenuitem> pont kiválasztása után
            a kinyíló New Project ablakban első lépésként válasszuk a 
            <guimenuitem>General</guimenuitem>
            kategóriát, azon belül a <guimenuitem>Java Application</guimenuitem> projektet. 
            </para>
                        
            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbg1.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokPeldak projekt.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>
            
            <para>            
            A 
            <guibutton>Next</guibutton> gombra következő ablakban elég a projekt nevét
            megadni, ez legyen mondjuk a <userinput>JavatTanitokPeldak</userinput>. Ugyanitt még
            deaktiváljuk (szüntessük meg a kipipálását) a <guilabel>Create Main Class</guilabel>
            opciót. 
            </para>
                        
            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbg2.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokPeldak projekt létrehozása.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>
            
            <para>            
            A <guibutton>Finish</guibutton>
             gomb nyomásával a projekt létrehozását befejeztük.
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbg3.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokPeldak projektben csomag létrehozása.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
            A <guilabel>Source Packages/default package</guilabel> csomagon egy 
            <mousebutton>jobb egérgombot</mousebutton> nyomva válasszuk a
			<guimenuitem>New/Java Package...</guimenuitem> menüpontot! A kinyíló
            ablakban adjuk meg a <userinput>javattanitok</userinput> 
            csomag nevet. 
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbg4.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokPeldak projektben csomag létrehozása.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>            
            
            <para>            
			Miután a <guibutton>Finish</guibutton> gombbal befejezzük a létrehozást, 
			a projekt forráskönyvtárában, esetünkben a 
			<filename>C:\Documents and Settings\norbi\JavatTanitokPeldak\src</filename>
			könyvtárban megjelenik a <filename class="directory">javattanitok</filename> alkönyvtár.
			Másoljuk ide a
			kézikönyv  
			<filename>LabirintusVilág.java</filename> forrását. Továbbá másoljuk ide a
			labirintus API-t, azaz a <filename class="directory">labirintus</filename> könyvtárat, ami tartalmazza a 
			korábban ismertetett  
                    <filename>Szereplő.java</filename>,
                    <filename>Hős.java</filename>,
                    <filename>Kincs.java</filename>,                    
                    <filename>Szörny.java</filename>,
                    <filename>Labirintus.java</filename>,
                    <filename>RosszLabirintusKivétel.java</filename>	állományokat. Ha ezzel megvagyunk, akkor
                    a <application>NetBeans IDE</application> projektek füle a következőket kell mutassa:
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbg5.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokPeldak projektet összeraktuk.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>
            
            <para>
			A <application>NetBeans IDE</application> projektek fülében a 
            <computeroutput>JavatTanitokPeldak</computeroutput> projekt néven egy 
            <mousebutton>jobb egérgombot</mousebutton> nyomva a tulajdonságok
            <guimenuitem>Properties</guimenuitem> menüpontot választva a 
            kinyíló ablak <computeroutput>Run</computeroutput> pontját
            kérve  a <computeroutput>Main Class</computeroutput> és az
            <computeroutput>Arguments</computeroutput> mezőket kell beállítanunk.
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbg6.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokPeldak projekt előkészítése futtatásra.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
            Az <computeroutput>Arguments</computeroutput> mező értékének megfelelően a 
			<filename>labirintus.txt</filename>
			állományt még be kell másolnunk a 
			<filename>C:\Documents and Settings\norbi\JavatTanitokPeldak</filename>
			könyvtárba.	
            Ha ezzel megvagyunk, jöhet a tesztelés, egyszerűen nyomjunk <keycap>F6</keycap>
             funkcióbillentyűt, vagy
            a <guimenuitem>Run/Run Main Projekt</guimenuitem> menüpontot!
            </para>


		</sect3>

        </sect2>

        <sect2 id="labirintus_jatek">
            <title>Java a játékokban: egy teljes képernyős példa - Labirintus Játék</title>
            
            <para>A példát az 
            <emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>
            című pontban vezettük be, majd az előző esettanulmány           
            <emphasis><link linkend="labirintus_elesztes">A labirintus API felélesztése</link></emphasis>  című pontjában a labirintus API világát már életre
                keltettük, a jelen példában közelítünk a 
                PC-s játékokhoz, melyek tipikusan a teljes képernyőt 
                uralják, a kifejlesztendő 
                <classname>LabirintusJáték</classname>
                osztály a labirintus mikrovilágának egy olyan életre keltését 
                adja, ami hasonlóan képes erre, azaz a teljes képernyőn
                működik!
            </para>
            
            <para>
                A példa kipróbálásához a 
                <classname>LabirintusJáték</classname> osztályt a 
                <filename class="directory">javattanitok</filename> könyvtárba kell bemásolnunk.
            </para>

        <sect3>
            <title>A LabirintusJáték osztály</title>
            
				<para>
				Az osztály működése lényegében megegyezik az előző példáéval, de 
				ránézésre bonyolultabbnak tűnhet, mivel itt már grafikus felületen
				fut a program, ennek megfelelően valódi képeket 
				 - <classname>BufferedImage</classname> objektumokat - használunk, amiket
				be kell tölteni, ki kell rajzolni. De annyiban valóban komplikáltabb
				a kód, hogy a nem egyszerűen grafikus felületen, hanem teljes képernyős
				módban is dolgozik, ahol a képek kirajzolásának hatékonyságát azzal is 
				fokozzuk, hogy a <function>kompatibilisKép</function> függvénnyel a 
				grafikus rendszerünkkel kompatibilis formába is konvertáljuk őket. 
				Továbbá a játékostól átvesszük a hőst
				mozgató billentyűzet inputot, amit a <classname>KeyAdapter</classname>
				- névtelen belső, a konstruktorban definiált - adapter osztállyal kezelünk:
				az adott kurzor nyilaknak megfelelő irányokba mozgatjuk a hőst,
				illetve az <keycap>ESC</keycap> billentyű nyomására kilépünk a programból.
				</para>
            
            <programlisting>
                <![CDATA[
/*
 * LabirintusJáték.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * "teljes képernyős" (Full Screen Exclusive Mode API-s) életre
 * keltésére ad példát ez az osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusVilág
 * @see javattanitok.LabirintusApplet
 * @see javattanitok.LabirintusServlet
 * @see javattanitok.LabirintusMIDlet
 * @see javattanitok.HálózatiLabirintus
 * @see javattanitok.TávoliLabirintus
 * @see javattanitok.KorbásLabirintus
 * @see javattanitok.ElosztottLabirintus
 */
public class LabirintusJáték extends java.awt.Frame
        implements Runnable {
    /** A labirintus. */
    Labirintus labirintus;
    /** A hős. */
    Hős hős;
    /** A játékbeli idő mérésére.*/
    private long idő = 0;
    /** Jelzi a játék végét, ezután a játék álapota már nem változik. */
    private boolean játékVége = false;
    /** A játék végén a játékost tájékoztató üzenet. */
    String végeÜzenet = "Vége a játéknak!";
    /** Jelzi, hogy a program terminálhat. */
    private boolean játékKilép = false;
    /** A labirintus szereplőihez rendelt képek. Ebben a példában már
     * BufferedImage képeket használunk, mert majd a teljesítmény javitás
     * apropóján ezeket a grafikus konfigurációnkhoz igazítjuk. */
    java.awt.image.BufferedImage falKép;
    java.awt.image.BufferedImage járatKép;
    java.awt.image.BufferedImage hősKép;
    java.awt.image.BufferedImage szörnyKép;
    java.awt.image.BufferedImage kincsKép;
    // A fullscreenbe kapcsoláshoz
    java.awt.GraphicsDevice graphicsDevice;
    // A megjelenítéshez
    java.awt.image.BufferStrategy bufferStrategy;
    /**
     * A <code>LabirintusJáték</code> objektum elkészítése.
     *
     * @param      labirintusFájlNév       a labirintust definiáló, megfelelő
     * szerkezetű szöveges állomány neve.
     * @exception  RosszLabirintusKivétel  ha a labirintust definiáló állomány nem 
     * a megfelelő szerkezetű
     */
    public LabirintusJáték(String labirintusFájlNév) 
    throws RosszLabirintusKivétel {
        /* A labirintus felépítése. */
        // A labirintus elkészítése állományból
        labirintus = new Labirintus(labirintusFájlNév);
        // A hős elkészítése és a kezdő pozíciójának beállítása
        hős = new Hős(labirintus);
        // A hős kezdő pozíciója
        hős.sor(9);
        hős.oszlop(0);
        /* Teljes képernyős módba próbálunk váltani. */
        // A lokális grafikus környezet elkérése
        java.awt.GraphicsEnvironment graphicsEnvironment
                = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment();
        // A grafikus környzetből a képernyővel dolgozunk
        graphicsDevice = graphicsEnvironment.getDefaultScreenDevice();
        // Próbálunk teljes képernyős, most speciálisan 1024x768-ba váltani
        teljesKépernyősMód(graphicsDevice);
        // Átadjuk a grafikus konfigurációt a kompatibilis képek elkészítéséhez
        képErőforrásokBetöltése(graphicsDevice.getDefaultConfiguration());
        // A hős mozgatása a KURZOR billenytűkkel, ESC kilép
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent billentyűEsemény) {
                
                int billentyű = billentyűEsemény.getKeyCode();
                
                if(!játékVége)
                    switch(billentyű) { // hős mozgatása
                        
                        case java.awt.event.KeyEvent.VK_UP:
                            hős.lépFöl();
                            break;
                        case java.awt.event.KeyEvent.VK_DOWN:
                            hős.lépLe();
                            break;
                        case java.awt.event.KeyEvent.VK_RIGHT:
                            hős.lépJobbra();
                            break;
                        case java.awt.event.KeyEvent.VK_LEFT:
                            hős.lépBalra();
                            break;
                            
                    }
                    // Kilépés a játékból
                    if(billentyű == java.awt.event.KeyEvent.VK_ESCAPE)
                        játékKilép = true;
                    
                    // A játékban történt változások a képernyőn 
                    // is jelenjenek meg
                    rajzolniKell();
                    
            };
        });
        
        // A játékbeli idő folyását biztosító szál elkészítése és indítása
        new Thread(this).start();
    }
    /** A játék időbeli fejlődésének vezérlése. */
    synchronized public void run() {
        
        while(!játékKilép) {
            
            // Aktív renderelés
            rajzol();
            
            idoegyseg();
            
            switch(labirintus.bolyong(hős)) {
                
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                    break;
                case Labirintus.JÁTÉK_MEGY_MEGHALT_HŐS:
                    // Még van élete, visszatesszük a kezdő pozícióra
                    hős.sor(9);
                    hős.oszlop(0);
                    break;
                case Labirintus.JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN:
                    végeÜzenet = "Győztél, vége a játéknak!";
                    játékVége = true;
                    break;
                case Labirintus.JÁTÉK_VÉGE_MEGHALT_HŐS:
                    végeÜzenet = "Vesztettél, vége a játéknak!";
                    játékVége = true;
                    break;
                    
            }
            
        }
        // Kilépés a játékból
        setVisible(false);
        graphicsDevice.setFullScreenWindow(null);
        System.exit(0);
        
    }
    /**
     * Ébresztő az várakozó rajzolást végző szálnak, ki kell rajzolni a játék 
     * grafikus felületét.
     */
    synchronized public void rajzolniKell() {
        
        notify();
        
    }
    /**
     * Megadja, hogy milyen gyorsan telik az idő a játékban.
     */
    private void idoegyseg() {
        
        ++ idő;
        
        try {
            
            wait(1000);
            
        } catch (InterruptedException e) {}
        
    }
    /**
     * Kép erőforrások betöltése.
     *
     * @param   graphicsConfiguration   a grafikus komfigurációval kompatibilis
     * képek készítéséhez.
     */
    public void képErőforrásokBetöltése(java.awt.GraphicsConfiguration 
            graphicsConfiguration) {
        
        falKép = kompatibilisKép("fal.png", graphicsConfiguration);
        járatKép = kompatibilisKép("járat.png", graphicsConfiguration);
        hősKép = kompatibilisKép("hős.png", graphicsConfiguration);
        szörnyKép = kompatibilisKép("szörny.png", graphicsConfiguration);
        kincsKép = kompatibilisKép("kincs.png", graphicsConfiguration);
        
    }
    /**
     * A grafikus konfigurációhoz igazítot kép.
     *
     * @param   képNév   a kép állomány neve
     * @param   graphicsConfiguration   a grafikus komfigurációval kompatibilis
     * képek készítéséhez.
     */
    public java.awt.image.BufferedImage kompatibilisKép(String képNév,
            java.awt.GraphicsConfiguration graphicsConfiguration) {
        // Képet legegyszerűben a Swing-beli ImageIcon-al tölthetünk be:
        java.awt.Image kép = new javax.swing.ImageIcon
                (képNév).getImage();
        // ebből BufferedImage-et készítünk, hogy hozzáférjünk a transzparencia
        // értékhez (pl. a hős, a kincs és a szörny transzparens nálunk)
        java.awt.image.BufferedImage bufferedImage =
                new java.awt.image.BufferedImage(kép.getWidth(null), 
                kép.getHeight(null),
                java.awt.image.BufferedImage.TYPE_INT_ARGB);
        
        java.awt.Graphics2D g0 = bufferedImage.createGraphics();
        g0.drawImage(kép, 0, 0, null);
        g0.dispose();
        // Az előző lépéshez hasonló lépésben most egy olyan BufferedImage-et,
        // készítünk, ami kompatibilis a grafikus konfigurációnkkal
        java.awt.image.BufferedImage kompatibilisKép
                = graphicsConfiguration.createCompatibleImage(
                bufferedImage.getWidth(), bufferedImage.getHeight(),
                bufferedImage.getColorModel().getTransparency());
        
        java.awt.Graphics2D g = kompatibilisKép.createGraphics();
        g.drawImage(bufferedImage, 0, 0, null);
        g.dispose();
        
        return kompatibilisKép;
    }
    /**
     * A játék grafikus felületének aktív renderelése.
     */
    public void rajzol() {
        
        java.awt.Graphics g = bufferStrategy.getDrawGraphics();
        
        // A labirintus kirajzolása
        for(int i=0; i<labirintus.szélesség(); ++i) {
            for(int j=0; j<labirintus.magasság(); ++j) {
                
                if(labirintus.szerkezet()[j][i])
                    g.drawImage(falKép, i*falKép.getWidth(),
                            j*falKép.getHeight(), null);
                else
                    g.drawImage(járatKép, i*járatKép.getWidth(),
                            j*járatKép.getHeight(), null);
                
            }
        }
        
        // A kincsek kirajzolása
        Kincs[] kincsek = labirintus.kincsek();
        for(int i=0; i<kincsek.length; ++i) {
            g.drawImage(kincsKép,
                    kincsek[i].oszlop()*kincsKép.getWidth(),
                    kincsek[i].sor()*kincsKép.getHeight(), null);
            // Ha már megvan a kics, akkor áthúzzuk
            if(kincsek[i].megtalálva()) {
                g.setColor(java.awt.Color.red);
                g.drawLine(kincsek[i].oszlop()*kincsKép.getWidth(),
                        kincsek[i].sor()*kincsKép.getHeight(),
                        kincsek[i].oszlop()*kincsKép.getWidth()
                        + kincsKép.getWidth(),
                        kincsek[i].sor()*kincsKép.getHeight()
                        + kincsKép.getHeight());
                g.drawLine(kincsek[i].oszlop()*kincsKép.getWidth()
                +kincsKép.getWidth(),
                        kincsek[i].sor()*kincsKép.getHeight(),
                        kincsek[i].oszlop()*kincsKép.getWidth(),
                        kincsek[i].sor()*kincsKép.getHeight()
                        + kincsKép.getHeight());
            } else {
                // ellenkező esetben kiírjuk az értékét
                g.setColor(java.awt.Color.yellow);
                g.drawString(""+kincsek[i].érték(),
                        kincsek[i].oszlop()*kincsKép.getWidth()
                        + kincsKép.getWidth()/2,
                        kincsek[i].sor()*kincsKép.getHeight()
                        + kincsKép.getHeight()/2);
            }
        }
        
        // A szörnyek kirajzolása
        Szörny[] szörnyek = labirintus.szörnyek();
        for(int i=0; i<szörnyek.length; ++i)
            g.drawImage(szörnyKép,
                    szörnyek[i].oszlop()*szörnyKép.getWidth(),
                    szörnyek[i].sor()*szörnyKép.getHeight(), null);
        
        // A hős kirajzolása
        g.drawImage(hősKép,
                hős.oszlop()*hősKép.getWidth(),
                hős.sor()*hősKép.getHeight(), null);
        
        // A játék aktuális adataiból néhány kiíratása
        g.setColor(java.awt.Color.black);
        
        g.drawString("Életek száma: "+hős.életek(), 10, 40);
        g.drawString("Gyűjtött érték: "+hős.pontszám(), 10, 60);
        g.drawString("Idő: "+idő, 10, 80);
        
        if(játékVége)
            g.drawString(végeÜzenet, 420, 350);
        
        g.dispose();
        if (!bufferStrategy.contentsLost())
            bufferStrategy.show();
        
    }
    /**
     * Teljes képernyős módba (Full Screen Exclusive Mode) kapcsolás.
     * Ha nem támogatott, akkor sima ablak fejléc és keret nélkül.
     */
    public void teljesKépernyősMód(java.awt.GraphicsDevice graphicsDevice) {
        
        int szélesség = 0;
        int magasság = 0;
        // Nincs ablak fejléc, keret.
        setUndecorated(true);
        // Mi magunk fogunk rajzolni.
        setIgnoreRepaint(true);
        // Nincs átméretezés
        setResizable(false);
        // Át tudunk kapcsolni fullscreenbe?
        boolean fullScreenTamogatott = graphicsDevice.isFullScreenSupported();
        // Ha tudunk, akkor Full-Screen exkluzív módba váltunk
        if(fullScreenTamogatott) {
            graphicsDevice.setFullScreenWindow(this);
            // az aktuális képernyő jellemzök (szélesség, magasság, színmélység,
            // frissítési frekvencia) becsomagolt elkérése
            java.awt.DisplayMode displayMode
                    = graphicsDevice.getDisplayMode();
            // és kiíratása
            szélesség = displayMode.getWidth();
            magasság = displayMode.getHeight();
            int színMélység = displayMode.getBitDepth();
            int frissítésiFrekvencia = displayMode.getRefreshRate();
            System.out.println(szélesség
                    + "x"  + magasság
                    + ", " + színMélység
                    + ", " + frissítésiFrekvencia);
            // A lehetséges képernyő beállítások elkérése
            java.awt.DisplayMode[] displayModes
                    = graphicsDevice.getDisplayModes();
            // Megnézzük, hogy támogatja-e az 1024x768-at, mert a
            // példa játékunkhoz ehhez a felbontáshoz készítettük a képeket
            boolean dm1024x768 = false;
            for(int i=0; i<displayModes.length; ++i) {
                if(displayModes[i].getWidth() == 1024
                        && displayModes[i].getHeight() == 768
                        && displayModes[i].getBitDepth() == színMélység
                        && displayModes[i].getRefreshRate() 
                        == frissítésiFrekvencia) {
                    graphicsDevice.setDisplayMode(displayModes[i]);
                    dm1024x768 = true;
                    break;
                }
                
            }
            
            if(!dm1024x768)
                System.out.println("Nem megy az 1024x768, de a példa képméretei ehhez a felbontáshoz vannak állítva.");
            
        } else {
            setSize(szélesség, magasság);
            validate();
            setVisible(true);
        }
        
        createBufferStrategy(2);
        
        bufferStrategy = getBufferStrategy();
        
    }
    /**
     * Átveszi a játék indításához szükséges paramétereket, majd
     * elindítja a játék világának működését.
     *
     * @param args a labirintus tervét tartalmazó állomány neve az első 
     * parancssor-argumentum.
     */
    public static void main(String[] args) {
        
        if(args.length != 1) {
            
            System.out.println("Indítás: java LabirintusJáték labirintus.txt");
            System.exit(-1);
        }
        
        try {
            
            new LabirintusJáték(args[0]);
            
        } catch(RosszLabirintusKivétel rosszLabirintusKivétel) {
            
            System.out.println(rosszLabirintusKivétel);
            
        }
    }    
}
                ]]>
            </programlisting>
            
			<para>
			Az osztály <function>teljesKépernyősMód()</function> függvénye végzi el
			a program teljes képernyős módba léptetését. Itt mi konkrétan
			egy 1024x768 felbontású üzemmódba akarunk kapcsolni. Az Olvasó ezt a 
			felbontást a saját monitorjához tudja igazítani, illetve a 
			a <varname>displayModes</varname> tömbbe lekérdezett lehetséges grafikus módok közül
			választhat is.
			</para>            
            
            </sect3>

            <sect3>
            <title>A teljes képernyős labirintus fordítása, futtatása</title>
                
            <para>
            A program sikeres futtatásához az alábbi, egyenként
            102x76 pixel méretű képeket
            </para>
            
            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/jatek_kepek.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A labirintus játék példa szereplőket ábrázoló példa képei.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>
            
            <para>            
            a <filename>fal.png</filename>,
            a <filename>járat.png</filename>,
            a <filename>hős.png</filename>,
            a <filename>kincs.png</filename> 
            és a <filename>szörny.png</filename> állományokat 
            kell a             
            <filename>Munkakönyvtár</filename> munkakönyvtárukba bemásolnunk.
            (Ezek a képek <emphasis><link linkend="forras_letoltes">A példaprogramok forrásainak letöltése</link></emphasis> című pontban ismertetett archívumban is megtalálhatóak.)
            E képállományok elkészítése után már bizonyosan sikeresen 
            futtathatja a kedves Olvasó
            ezt a példát is:
            
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> javac javattanitok\LabirintusJáték.java
C:\...\Munkakönyvtár> java javattanitok.LabirintusJáték labirintus.txt
                ]]>
            </screen>     

            </para>            
            
            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/labirintus_teljes.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A teljes képernyős Labirintus Játék példa képe.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>
            
            </sect3>
            
        </sect2>
        
        <sect2 id="labirintus_applet">
            <title>Java a böngészőkben: Applet objektumok - Labirintus Applet</title>
            
            <para>
            A példát az 
            <emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>
            című pontban vezettük be.
            </para>
            
            <sect3>
            <title>A LabirintusApplet osztály</title>

			<para>
			Ennek az osztálynak a lényegi működése az előző kettővel, 
			funkcionális működése pedig az előző osztályéval egyezik meg. A grafikus 
			felület kezelését nagyban egyszerűsíti, hogy nem teljes képernyős
			módban dolgozunk. Látszólag viszont bonyolítja, hogy az osztály
			letölthető appletként és különálló alkalmazásként is kész a futásra.
			Ha a programot a böngésző tölti le, azaz appletként fog futni, akkor 
			nem a <function>main()</function>, hanem az <function>init()</function> függvénye végrehajtásával indul, azaz miután
			a böngésző példányosított a <classname>LabirintusApplet</classname> osztályból egy objektumot, akkor
			annak <function>init()</function> módszere hívódik. Ez esetben tehát nem mi magunk
			példányosítottunk az appletből. 
			</para>

            <programlisting>
                <![CDATA[
/*
 * LabirintusApplet.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * appletbeli életre keltésére ad példát ez az osztály. Ennek megfelelően
 * appletként a böngészőben, alkalmazásként külön ablakban történő
 * megjelenítést biztosít.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusVilág
 * @see javattanitok.LabirintusJáték
 * @see javattanitok.LabirintusMIDlet
 * @see javattanitok.LabirintusServlet
 * @see javattanitok.HálózatiLabirintus
 * @see javattanitok.TávoliLabirintus
 * @see javattanitok.KorbásLabirintus
 * @see javattanitok.ElosztottLabirintus
 */
public class LabirintusApplet extends java.applet.Applet
        implements java.awt.event.KeyListener {
    /** A labirintus. */
    Labirintus labirintus;
    /** A hős. */
    Hős hős;
    /** A játék vége után már nem veszünk át inputot a játékostól,
     * illetve a játék világának állapota sem változik. */
    boolean játékVége = false;
    /** A játék vége után megjelenő üzenet. */
    String végeÜzenet = "Vége a játéknak!";
    // Ha nam appletként indítjuk a programot, hanem alkalmazásként, akkor
    // ez lesz az alkalmazás ablaka
    java.awt.Frame ablak;
    // A labirintus szereplőihez rendelt képek
    java.awt.Image falKép;
    java.awt.Image járatKép;
    java.awt.Image hősKép;
    java.awt.Image szörnyKép;
    java.awt.Image kincsKép;
    /**
     * Az applet életciklusának indítása, csak akkor fut le, ha appletként
     * indítotuk a programot.
     */
    public void init() {
        
        addKeyListener(this);
        indul(true);
        
    }
    /**
     * Akár appletként, akár alkalmazásként indítjuk a programot, itt
     * végezzük el az inicializálás javát.
     */
    public void indul(boolean appletként) {
        
        ClassLoader classLoader = this.getClass().getClassLoader();
         
        falKép = new javax.swing.ImageIcon
                (classLoader.getResource("fal.png")).getImage();
        járatKép = new javax.swing.ImageIcon
                (classLoader.getResource("járat.png")).getImage();
        hősKép = new javax.swing.ImageIcon
                (classLoader.getResource("hős.png")).getImage();
        szörnyKép = new javax.swing.ImageIcon
                (classLoader.getResource("szörny.png")).getImage();
        kincsKép = new javax.swing.ImageIcon
                (classLoader.getResource("kincs.png")).getImage();
                
        labirintus = new Labirintus(6, 3);
        hős = new Hős(labirintus);
        hős.sor(9);
        hős.oszlop(0);
        // ha nem appletként indítottuk a programot
        if(!appletként) {
            // akkor nyitunk neki egy ablakot
            ablak = new java.awt.Frame("Labirintus applet alkalmazásként");
            // amit be is lehet csukni
            ablak.addWindowListener(new java.awt.event.WindowAdapter() {
                public void windowClosing(java.awt.event.WindowEvent e) {
                    ablak.setVisible(false);
                    System.exit(0);
                }
            });
            
            ablak.add(this);
            ablak.addKeyListener(this);
            ablak.setSize(1024, 768);
            ablak.setVisible(true);
            
        }
    }
    /**
     * A játékostól (aki a játék világában a hős) jövő input feldolgozása:
     * a hős mozgatása a KURZOR billenytűkkel, illetve a játék világának
     * állapot változásait is innen irányítjuk.
     */
    public void keyPressed(java.awt.event.KeyEvent billentyűEsemény) {
        // Mit nyomott le?
        int billentyű = billentyűEsemény.getKeyCode();
        
        if(!játékVége) {
            // Merre lép a hős?
            switch(billentyű) {
                // A KURZOR billentyűkkel foglalkozunk, a megfelelő irányba
                // lépünk
                case java.awt.event.KeyEvent.VK_UP:
                    hős.lépFöl();
                    break;
                case java.awt.event.KeyEvent.VK_DOWN:
                    hős.lépLe();
                    break;
                case java.awt.event.KeyEvent.VK_RIGHT:
                    hős.lépJobbra();
                    break;
                case java.awt.event.KeyEvent.VK_LEFT:
                    hős.lépBalra();
                    break;
                    
            }
            // A játék világának állapot változása: azaz a játék többi
            // szereplője is lép. Ha ezzel a lépéssel a játék világában
            // történt valami lényeges: pl. vége a játéknak vagy egy szörny
            // elkapta a hőst, akkor reagálunk:
            switch(labirintus.bolyong(hős)) {
                
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                    break;
                case Labirintus.JÁTÉK_MEGY_MEGHALT_HŐS:
                    // Még van élete, visszatesszük a kezdő pozícióra
                    hős.sor(9);
                    hős.oszlop(0);
                    break;
                case Labirintus.JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN:
                    végeÜzenet = "Győztél, vége a játéknak!";
                    játékVége = true;
                    break;
                case Labirintus.JÁTÉK_VÉGE_MEGHALT_HŐS:
                    végeÜzenet = "Vesztettél, vége a játéknak!";
                    játékVége = true;
                    break;
                    
            }
            // Amíg nincs vége a játéknak, újra rajzoljuk a
            // játék felületét, hogy látszódjanak a játék állapotában
            // bekövetkezett változások
            repaint();
        }
    }
    /**
     * A KeyListener számunkra most érdektelen további metódusait üres
     * testtel definiáljuk felül.
     */
    public void keyTyped(java.awt.event.KeyEvent billentyűEsemény) {}
    public void keyReleased(java.awt.event.KeyEvent billentyűEsemény) {}
    /**
     * Kajzolja a játék felületét, azaz a labirintust és a benne szereplőket:
     * a hőst, a kincseket és a szörnyeket.
     */
    public void paint(java.awt.Graphics g) {
        
        // A labirintus kirajzolása
        for(int i=0; i<labirintus.szélesség(); ++i) {
            for(int j=0; j<labirintus.magasság(); ++j) {
                
                if(labirintus.szerkezet()[j][i])
                    g.drawImage(falKép, i*falKép.getWidth(this),
                            j*falKép.getHeight(this), null);
                else
                    g.drawImage(járatKép, i*járatKép.getWidth(this),
                            j*járatKép.getHeight(this), null);
                
            }
        }
        // A kincsek kirajzolása
        Kincs[] kincsek = labirintus.kincsek();
        for(int i=0; i<kincsek.length; ++i) {
            g.drawImage(kincsKép,
                    kincsek[i].oszlop()*kincsKép.getWidth(this),
                    kincsek[i].sor()*kincsKép.getHeight(this), null);
            
            // Ha már megvan a kics, akkor áthúzzuk
            if(kincsek[i].megtalálva()) {
                g.setColor(java.awt.Color.red);
                g.drawLine(kincsek[i].oszlop()*kincsKép.getWidth(this),
                        kincsek[i].sor()*kincsKép.getHeight(this),
                        kincsek[i].oszlop()*kincsKép.getWidth(this)
                        + kincsKép.getWidth(this),
                        kincsek[i].sor()*kincsKép.getHeight(this)
                        + kincsKép.getHeight(this));
                g.drawLine(kincsek[i].oszlop()*kincsKép.getWidth(this)
                          + kincsKép.getWidth(this),
                        kincsek[i].sor()*kincsKép.getHeight(this),
                        kincsek[i].oszlop()*kincsKép.getWidth(this),
                        kincsek[i].sor()*kincsKép.getHeight(this)
                        + kincsKép.getHeight(this));
            } else {
                // ellenkező esetben kiírjuk az értékét
                g.setColor(java.awt.Color.yellow);
                g.drawString(""+kincsek[i].érték(),
                        kincsek[i].oszlop()*kincsKép.getWidth(this)
                        + kincsKép.getWidth(this)/2,
                        kincsek[i].sor()*kincsKép.getHeight(this)
                        + kincsKép.getHeight(this)/2);
            }
            
        }
        // A szörnyek kirajzolása
        Szörny[] szörnyek = labirintus.szörnyek();
        for(int i=0; i<szörnyek.length; ++i)
            g.drawImage(szörnyKép,
                    szörnyek[i].oszlop()*szörnyKép.getWidth(this),
                    szörnyek[i].sor()*szörnyKép.getHeight(this), null);
        // A hős kirajzolása
        g.drawImage(hősKép,
                hős.oszlop()*hősKép.getWidth(this),
                hős.sor()*hősKép.getHeight(this), null);
        
        // A játék aktuális adataiból néhány kiíratása
        g.setColor(java.awt.Color.black);
        
        g.drawString("Életek száma: "+hős.életek(), 10, 40);
        g.drawString("Gyűjtött érték: "+hős.pontszám(), 10, 60);
        
        if(játékVége) {
            
            g.setColor(java.awt.Color.black);
            g.drawString(végeÜzenet, 420, 350);
            
        }
    }    
    /**
     * A játék felületének kirajzolásakor ne legyen villogás, ezért
     * az eredeti, a felület törlését elvégző update metódust felüldefiniáljuk.
     */
    public void update(java.awt.Graphics g) {
        paint(g);
    }    
    /**
     * A program alkalmazásként való indíthatóságát szolgálja.
     */
    public static void main(String[] args) {
        
        // Ha itt van a vezérlés, akkor nem igaz az, hogy appletként indítottuk
        new LabirintusApplet().indul(false);
        
    }    
}                
                ]]>
            </programlisting>
            
			</sect3>

            <sect3>
            <title>A labirintus applet fordítása, futtatása</title>
            
            <para>
            A <classname>LabirintusApplet</classname> osztályt fordítása után
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> javac javattanitok\LabirintusApplet.java
                ]]>
            </screen>     
            alkalmazásként is futtathatjuk:
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.LabirintusApplet
                ]]>
            </screen>     
            de izgalmasabb hozzá egy HTML dokumentumot készíteni, mondjuk a
            <filename>labirintus.html</filename> néven a 
            <computeroutput>Munkakönyvtár</computeroutput> nevű munkakönyvtárunkban
            az alábbi tartalommal.
            
            <programlisting>
                <![CDATA[
<applet code="javattanitok/LabirintusApplet.class" 
	width="1024" height="768">
</applet>                
                ]]>
            </programlisting>

            Az appletet ezután
            az appletek tesztelésére használható, a JDK-beli <command>appletviewer</command>
            parancsot használva tesztelhetjük:
            
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> appletviewer labirintus.html
                ]]>
            </screen>     
            
            S a legizgalmasabb magában a böngészőben való kipróbálás, ehhez futtassuk a
            szintén a JDK részeként kapott <command>HtmlConverter.exe</command> nevű programot a JDK 
            <filename>bin</filename> 
            könyvtárából, ahol a kinyíló Swinges ablakban a 
            <guilabel>Specify a file or a directory path:</guilabel> szövegmezőbe
            böngésszük be a 
            <filename>C:\Documents and Settings\norbi\Dokumentumok\Javat_tanitok\Munkakönyvtár</filename>
            munkakönyvtárunkat, majd végezzük el a konvertálást, ami a <filename>labirintus.html</filename> állományunkat a következőre alakítja át:
            
            <programlisting>
                <![CDATA[
<!--"CONVERTED_APPLET"-->
<!-- HTML CONVERTER -->
<object
    classid = "clsid:8AD9C840-044E-11D1-B3E9-00805F499D93"
    codebase = "http://java.sun.com/update/1.6.0/jinstall-1_6-windows-i586.cab#Version=6,0,0,86"
    WIDTH = "1024" HEIGHT = "768" >
    <PARAM NAME = CODE VALUE = "javattanitok/LabirintusApplet.class" >
    <param name = "type" value = "application/x-java-applet;version=1.6">
    <param name = "scriptable" value = "false">

    <comment>
	<embed
            type = "application/x-java-applet;version=1.6" \
            CODE = "javattanitok/LabirintusApplet.class" \
            WIDTH = "1024" \
            HEIGHT = "768"
	    scriptable = false
	    pluginspage = "http://java.sun.com/products/plugin/index.html#download">
	    <noembed>
            
            </noembed>
	</embed>
    </comment>
</object>

<!--
<APPLET CODE = "javattanitok/LabirintusApplet.class" WIDTH = "1024" HEIGHT = "768">


</APPLET>
-->
<!--"END_CONVERTED_APPLET"-->
                ]]>
            </programlisting>
            
            majd ezt a konvertálás után kapott állományt nyissuk ki a böngészőnkkel:
            </para>                        
                        
            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/labirintus_applet.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A Labirintus Applet a böngészőprogramban.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>
            
</sect3>

        </sect2>
        
        <sect2 id="labirintus_midlet">
            <title>Java a mobiltelefonokban: MIDlet objektumok - Labirintus MIDlet</title>
            
                <para>
Az <emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>
            című pontban bevezetett esettanulmány végleges kódját adjuk meg itt.</para>
                        
            <para>
            A példa fejlesztését a <application>NetBeans IDE</application> környezetben végezzük.
            A <guimenuitem>File/New Project...</guimenuitem> pont kiválasztása után
            a kinyíló <guilabel>New Project</guilabel>
             ablakban első lépésként válaszuk a <guilabel>Mobile</guilabel>
            kategóriát, azon belül a <guimenuitem>Mobil Application</guimenuitem> projektet. A 
            <guibutton>Next</guibutton> gombra következő ablakban elég a projekt nevét
            megadni, ez legyen mondjuk a <userinput>JavatTanitokMobilLabirintus</userinput>. Ugyanitt még
            deaktiváljuk (szüntessük meg a kipipálását) a <guilabel>Create Hello MIDlet</guilabel>
            opciót. Majd a felkínált alapértelmezések elfogadása mellett nyomjunk újabb 
             <guibutton>Next</guibutton> gombokat a <guibutton>Finish</guibutton>
             gomb megjelenéséig, melynek nyomásával a projekt létrehozását befejeztük.
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nb1.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokMobilLabirintus projekt.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
            A <guilabel>default package</guilabel> csomagon egy 
            <mousebutton>jobb egérgombot</mousebutton> nyomva válasszuk a
			<guimenuitem>New/Java Package...</guimenuitem> menüpontot! A kinyíló
            ablakban adjuk meg a <userinput>javattanitok</userinput> 
            csomag nevet. A <mousebutton>jobb egérgomb</mousebutton> 
            újbóli nyomásával válasszuk a             
            <guimenuitem>New/MIDlet...</guimenuitem> menüpontot! A kinyíló
            ablakban adjuk meg a nevét - ez tetszőleges lehet. Viszont a 
			<guilabel>MIDP Class Name</guilabel> megadásánál nagyon
			gondosan járjunk el, egészen pontosan azt a nevet adjuk meg (kis-nagybetű helyesen)
			amely osztály azt mondja magáról, hogy <computeroutput>extends MIDlet</computeroutput>,
			esetünkben ez az osztály a <classname>LabirintusMIDlet</classname> osztály.
			Miután a <guibutton>Finish</guibutton> gombbal befejezzük a létrehozást, 
			a projekt forráskönyvtárában, esetünkben a 
			<filename>C:\Documents and Settings\norbi\JavatTanitokMobilLabirintus\src\javattanitok</filename>
			könyvtárban megjelenik a <filename>LabirintusMIDlet.java</filename> forrásállomány. Most 
			annyit tegyünk még, hogy ezt az állomány írjuk felül a kézikönyv alább bemutatott
			<filename>LabirintusMIDlet.java</filename> állományával és e mellé másoljuk még be a
			kézikönyv, szintén a következőkben bemutatott 
			<filename>LabirintusVaszon.java</filename> forrását. Továbbá másoljuk ide a
			labirintus API-t, azaz a <filename class="directory">labirintus</filename> könyvtárat, ami tartalmazza a 
			korábban ismertetett  
                    <filename>Szereplő.java</filename>,
                    <filename>Hős.java</filename>,
                    <filename>Kincs.java</filename>,                    
                    <filename>Szörny.java</filename>,
                    <filename>Labirintus.java</filename>,
                    <filename>RosszLabirintusKivétel.java</filename>	állományokat. Ha ezzel megvagyunk, akkor
                    a <application>NetBeans IDE</application> projektek füle a következőket kell mutassa:
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nb2.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokMobilLabirintus projekt összerakása.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
				Sajnos itt a labirintus API ékezetes osztálynevei problémát okoznak a projekt fordítása után, így ezeket, azaz a
                    <filename>Szereplő.java</filename>,
                    <filename>Hős.java</filename>,
                    <filename>Szörny.java</filename>,
                    <filename>RosszLabirintusKivétel.java</filename>	állományokat
				átírjuk ékezet nélküli nevekre. Mielőtt belekezdenénk ebbe a sziszifuszi munkába, van királyi út is: nyomjunk 
				<mousebutton>jobb egérgombot</mousebutton> ezeken a neveken a projektek fülben, majd a 
					<guimenuitem>Refactor/Rename...</guimenuitem> menüpont választása után kinyíló
					ablakban adjuk
					meg a megfelelő ékezet nélküli osztálynevet. 
					A <guibutton>Next</guibutton>, majd a
					<computeroutput>Do Refactoring</computeroutput> gombokat nyomva az átnevezés (és minden hivatkozás
					átnevezése) kész.
					Ha ezzel is megvagyunk, akkor
                    a <application>NetBeans IDE</application> projektek füle a következőket kell mutassa:
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nb3.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokMobilLabirintus projekt az átnevezések után.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
            Már majdnem készen állunk a projekt fordítására és futtatására. Annyi van hátra, hogy a <classname>Labirintus</classname>
            osztály tartalmaz olyan osztályokat, melyek csak a Java SE részei, így ezeket a jelen Java ME platformbeli munkánk során
            módosítanunk kell! A legegyszerűbb eljárást választjuk, ezeket töröljük, egészen pontosan
            kommentbe tesszük a <filename>Labirintus.java</filename> állományban az állományból építő konstruktort, mert ebben számos, 
            csak a Java SE-ben létező objektum, például a 
            <classname>java.io.BufferedReader</classname>, 
            <classname>java.util.StringTokenizer</classname>, 
            <classname>java.io.FileNotFoundException</classname> vagy a 
                        <classname>java.io.FileReader</classname> van. 

            <programlisting>
                <![CDATA[
public Labirintus(String labirintusFájlNév) throws RosszLabirintusKivetel {                
                ]]>
            </programlisting>

			Továbbá ugyancsak kommentezzük a <classname>java.io.PrintWriter</classname> nem Java ME 
			osztály használatából bekövetkező, hasonló problémát okozó
            
            <programlisting>
                <![CDATA[
public void nyomtat(Hos hős, java.io.PrintWriter csatorna) {                
                ]]>
            </programlisting>
            
            függvényt.
            </para>
            
            <para>
            Ezzel elkészültünk, jöhet a tesztelés, egyszerűen nyomjunk 
            <keycap>F6</keycap> funkcióbillentyűt, vagy
            a <guimenuitem>Run/Run Main Projekt</guimenuitem> menüpontot!
            </para>
            
            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nb4.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokMobilLabirintus projekt futtatása.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
            A <computeroutput>Launch</computeroutput>-nek megfelelő telefon szoftbillentyűre kattintva
            elindul a mobil labirintus játékunk.
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nb5.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A mobil labirintusunk.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
            Még a játék képeit tartalmazó <filename>png</filename> állományokat kell megadnunk a 
            projektnek, másoljuk be a 
                    <filename>hos.png</filename>,
                    <filename>kincs.png</filename> és a                    
                    <filename>szorny.png</filename> állományokat például a 
            <filename>C:\Documents and Settings\norbi\JavatTanitokMobilLabirintus\res</filename>
            könyvtárba, majd a <application>NetBeans IDE</application> projektek fülében a 
            <computeroutput>JavatTanitokMobilLabirintus</computeroutput> néven egy 
            <mousebutton>jobb egérgombot</mousebutton> nyomva a tulajdonságok
            <guimenuitem>Properties</guimenuitem> menüpontot választva a 
            kinyíló ablak <computeroutput>Libraries &amp; Resources</computeroutput> pontját
            kérve, az <computeroutput>Add Folder...</computeroutput> gombbal a 
            <filename>C:\Documents and Settings\norbi\JavatTanitokMobilLabirintus\res</filename>
				könyvtárat hozzáadva immár, ahogyan a következő kép is mutatja,  a képeinket is elérjük.
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nb6.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A mobil labirintusunk a képekkel.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <sect3 id="labirintusmidlet_osztaly">
            <title>A LabirintusMIDlet osztály</title>
            
            <para>
				A <classname>LabirintusMIDlet</classname> osztályból a 
				mobiltelefon példányosít, a konstruktor lefutása után 
				meghívódik a <function>startApp()</function> indító életciklus
				függvény. A MIDlet életciklussal a 
				<emphasis><link linkend="midlet_feladat">MIDlet feladat</link></emphasis>
				című pontban foglalkoztunk. 				
            </para>

            <para>
				A <classname>LabirintusMIDlet</classname> osztály eseménykezelését pedig az 
				<emphasis><link linkend="esemenykezeles">Eseménykezelés</link></emphasis>
				című pontban tárgyaltuk. 				
            </para>
            
            <programlisting>
                <![CDATA[
/*
 * LabirintusMIDlet.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * mobiltelefonos életre keltésére ad példát ez az osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusVilág
 * @see javattanitok.LabirintusApplet
 * @see javattanitok.LabirintusJáték
 * @see javattanitok.LabirintusServlet
 * @see javattanitok.HálózatiLabirintus
 * @see javattanitok.TávoliLabirintus
 * @see javattanitok.KorbásLabirintus
 * @see javattanitok.ElosztottLabirintus
 * @see javattanitok.LabirintusVaszon
 */
public class LabirintusMIDlet extends javax.microedition.midlet.MIDlet
        implements javax.microedition.lcdui.CommandListener {
    /** A MIDlethez tartozó kijelző. */
    private javax.microedition.lcdui.Display kijelző;
    /** Parancs a kilépéshez. */
    private javax.microedition.lcdui.Command kilépésParancs;
    /** A labirintus életre keltése és megjelenítése. */
    private LabirintusVaszon labirintusVászon;
    /**
     * A <code>LabirintusMIDlet</code> objektum elkészítése.
     */
    public LabirintusMIDlet() {
        // A MIDlethez tartozó kijelző elkérése
        kijelző = javax.microedition.lcdui.Display.getDisplay(this);
        // A labirintus elkészítése
        labirintusVászon = new LabirintusVaszon();
        // A kilépés parancs elkészítése
        kilépésParancs = new javax.microedition.lcdui.Command("Kilép",
                javax.microedition.lcdui.Command.EXIT, 1);
        // és a labirintus vászonra helyezése
        labirintusVászon.addCommand(kilépésParancs);
        // az eseményeket (most kilépés parancs) itt dolgozzuk fel
        labirintusVászon.setCommandListener(this);
    }
    /** A MIDletet indító életciklus metódus. */
    public void startApp() {
        // A kijelzőn a labirintus vászon legyen látható
        kijelző.setCurrent(labirintusVászon);
    }
    /**
     * A MIDletet felfüggesztő életciklus metódus, azaz mit tegyünk,
     * ha egy bejövő hívás vagy SMS megzavarja a programunk futását?
     * (Most semmit, mert csupán üres testes implementációját adtuk a
     * függvénynek.)
     */
    public void pauseApp() {
    }
    /**
     * A MIDletet befejező életciklus metódus, azaz mit tegyünk,
     * ha programunk befejezi futását? (Most semmit, mert csupán
     * üres testes implementációját adtuk a függvénynek.)
     */
    public void destroyApp(boolean unconditional) {
        // Leállítjuk a labirintus játék szálát
        if(labirintusVászon != null)
            labirintusVászon.játékKilép();
    }
    /**
     * A labirintus játék parancsainak (jelen esetben egy ilyen van,
     * a kilépés) kezelése.
     *
     * @param command parancs, ami keletkezett
     * @param displayable valamelyik képernyőn
     */
    public void commandAction(javax.microedition.lcdui.Command parancs,
            javax.microedition.lcdui.Displayable képernyő) {
        
        if (képernyő == labirintusVászon) {
            if (parancs == kilépésParancs) {
                // Leállítjuk a labirintus játék szálát
                labirintusVászon.játékKilép();
                // Leállítjuk a programot
                kijelző.setCurrent(null);
                destroyApp(true);
                notifyDestroyed();
                
            }
        }
    }
}                
                ]]>
            </programlisting>

			</sect3>

            <sect3>
            <title>A LabirintusVaszon osztály</title>
           
            <para>
            Mobil környezetben a GUI felépítésére - ahogyan a 
            <emphasis><link linkend="titkosito_gui">Bepillantás a GUI programozásba</link></emphasis>
            című pontban említettük - a
            <classname>javax.microedition.lcdui</classname> csomag szolgál.  
            A <classname>MIDlet</classname> objektumunkhoz tartozó kijelzőt már az iménti 
            <classname>MIDlet</classname> osztályunk konstruktorában
            elkértük a csomag <classname>Display</classname>
             osztályának statikus <function>getDisplay()</function> függvényével, majd a 
             <classname>MIDlet</classname> indulásakor
            
            <programlisting>
                <![CDATA[

    /** A MIDletet indító életciklus metódus. */
    public void startApp() {
        // A kijelzőn a labirintus vászon legyen látható
        kijelző.setCurrent(labirintusVászon);
    }
                ]]>
            </programlisting>
            
            egy azt a <classname>LabirintusVaszon</classname> osztálybeli 
            vásznunkat tettünk a kijelzőre, aminek a következő teljes kódját közöljük.
            Vásznunk egy <classname>javax.microedition.lcdui.game</classname>
            csomagbeli <classname>GameCanvas</classname>. Az ilyen játék-vásznak egyik 
            előnye,
            hogy könnyen teljes kijelzős módba kapcsolhatók, amikor is a kijelzőn 
            a szoftbillentyűknek
            fenntartott hellyel is a programozó rendelkezhet és főleg, hogy ezen a vásznon könnyű
            a szálkezelést összeegyeztetni a játék állapotváltozásaival és 
            a vászon kirajzolásával. Mert még a klasszikus
            vászon használata esetén felül kell definiálnunk a vászon
            <function>paint()</function> módszerét és ezt a program vezérlő szálából
            ciklikusan implicit hívogatnunk a <function>repaint()</function> függvény hívásával,
            addig itt mindent: az eseménykezelést, a játék állapotának változását és az
            ennek a változásnak megfelelő kirajzolást is egy helyen végezhetjük, a 
            kódunkban is jól látható <function>run()</function> módszerünkben.
            </para>

            <programlisting>
                <![CDATA[
/*
 * LabirintusVaszon.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * mobiltelefonos életre keltésére ad példát ez az osztály: elkészíti,
 * vezérli és megjeleníti a labirintust.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusMIDlet
 */
public class LabirintusVaszon extends javax.microedition.lcdui.game.GameCanvas
        implements Runnable {
    /** A vászon szélessége. */
    private int szélesség;
    /** A vászon magassága. */
    private int magasság;
    /** A labirintus. */
    Labirintus labirintus;
    /** A hős. */
    Hos hős;
    /** A játékbeli idő folyását biztosító szál. */
    private Thread játékSzál;
    /** A játékbeli idő mérésére.*/
    private long idő = 0;
    /** Jelzi a játék végét, ezután a játék álapota már nem változik. */
    private boolean játékVége = false;
    /** A játék végén a játékost tájékoztató üzenet. */
    String végeÜzenet = "Vége a játéknak!";
    /** Jelzi, hogy a program terminálhat. */
    private boolean játékKilép = false;
    /** A labirintus egy fal vagy járat cellájának szélessége. */
    private int téglaSzélesség;
    /** A labirintus egy fal vagy járat cellájának magassága. */
    private int téglaMagasság;
    /** A szereplőkhöz rendelt képek. */
    javax.microedition.lcdui.Image hősKép, szörnyKép, kincsKép;
    /**
     * A <code>LabirintusVászon</code> objektum elkészítése.
     */
    public LabirintusVaszon() {
        
        super(false);
        // A mobil kijelzője teljes képernyős módba
        setFullScreenMode(true);
        // Milyenek ekkor a méretek?
        szélesség = getWidth();
        magasság = getHeight();
        // A labirintus elkészítése
        labirintus = new Labirintus(6, 3);
        hős = new Hos(labirintus);
        hős.sor(9);
        hős.oszlop(0);
        // A labirintusnak a telefon kijelző méretéhez igazítása
        téglaSzélesség = szélesség/labirintus.szélesség();
        téglaMagasság = magasság/labirintus.magasság();
        try {
            // A szereplőkhöz rendelt képek betöltése
            hősKép = 
                    javax.microedition.lcdui.Image.createImage("/hos.png");
            kincsKép = 
                    javax.microedition.lcdui.Image.createImage("/kincs.png");
            szörnyKép = 
                    javax.microedition.lcdui.Image.createImage("/szorny.png");
            
        } catch(Exception e) {
            
            hősKép = null;
            kincsKép = null;
            szörnyKép = null;
            
        }
        // A játékbeli idő folyását biztosító szál elkészítése
        játékSzál = new Thread(this);
        // és indítása
        játékSzál.start();
        
    }
    /** A játék időbeli fejlődésének vezérlése. */
    public void run() {
        
        javax.microedition.lcdui.Graphics g = getGraphics();
        
        while(!játékKilép) {
            
            if(!játékVége) { // Ha még nincs vége, akkor érdemben
                // reagálunk a billentyűzet lenyomásokra
                int billentyű = getKeyStates();
                // A kurzor gomboknak megfelelő irányba lépéssel
                if ((billentyű & LEFT_PRESSED) != 0) {
                    hős.lépBalra();
                } else if ((billentyű & RIGHT_PRESSED) != 0) {
                    hős.lépJobbra();
                } else if ((billentyű & UP_PRESSED) != 0) {
                    hős.lépFöl();
                } else if ((billentyű & DOWN_PRESSED) != 0) {
                    hős.lépLe();
                }
            }
            
            switch(labirintus.bolyong(hős)) {
                
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                    break;                    
                case Labirintus.JÁTÉK_MEGY_MEGHALT_HŐS:
                    // Még van élete, visszatesszük a kezdő pozícióra
                    hős.sor(9);
                    hős.oszlop(0);
                    break;
                case Labirintus.JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN:
                    végeÜzenet = "Győztél, vége a játéknak!";
                    játékVége = true;
                    break;
                case Labirintus.JÁTÉK_VÉGE_MEGHALT_HŐS:
                    végeÜzenet = "Vesztettél, vége a játéknak!";
                    játékVége = true;
                    break;
                    
            }
            // A kijelző törlése
            g.setColor(0x00FFFFFF);
            g.fillRect(0, 0, getWidth(), getHeight());
            // A labirintus kirajzolása
            g.setColor(0x00ed7703);
            for(int i=0; i<labirintus.szélesség(); ++i)
                for(int j=0; j<labirintus.magasság(); ++j)
                    if(labirintus.szerkezet()[j][i])
                        g.fillRect(i*téglaSzélesség, j*téglaMagasság,
                                téglaSzélesség, téglaMagasság);
            // A kincsek kirajzolása
            Kincs[] kincsek = labirintus.kincsek();
            for(int i=0; i<kincsek.length; ++i) {
                
                if(kincsKép != null) {
                    if(!kincsek[i].megtalálva())
                        g.drawImage(kincsKép,
                                kincsek[i].oszlop()*téglaSzélesség,
                                kincsek[i].sor()*téglaMagasság,
                                javax.microedition.lcdui.Graphics.LEFT
                                |javax.microedition.lcdui.Graphics.TOP);
                } else {
                    // Ha már megvan a kics, akkor szürkébbel rajzoljuk
                    if(kincsek[i].megtalálva())
                        g.setColor(0x00d2cfb7);
                    else // Különben sárgábbal
                        g.setColor(0x00fbe101);
                    
                    g.fillRect(kincsek[i].oszlop()*téglaSzélesség,
                            kincsek[i].sor()*téglaMagasság,
                            téglaSzélesség/2, téglaMagasság);
                }
            }
            // A szörnyek kirajzolása
            g.setColor(0x00ff0000);
            Szorny[] szörnyek = labirintus.szörnyek();
            for(int i=0; i<szörnyek.length; ++i)
                if(szörnyKép != null)
                    g.drawImage(szörnyKép,
                            szörnyek[i].oszlop()*téglaSzélesség,
                            szörnyek[i].sor()*téglaMagasság,
                            javax.microedition.lcdui.Graphics.LEFT
                            |javax.microedition.lcdui.Graphics.TOP);
                else
                    g.fillRect(szörnyek[i].oszlop()*téglaSzélesség 
                            + téglaSzélesség/2,
                            szörnyek[i].sor()*téglaMagasság,
                            téglaSzélesség/2, téglaMagasság);
            // A hős kirajzolása
            if(hősKép != null)
                g.drawImage(hősKép,
                        hős.oszlop()*téglaSzélesség,
                        hős.sor()*téglaMagasság,
                        javax.microedition.lcdui.Graphics.LEFT
                        |javax.microedition.lcdui.Graphics.TOP);
            else {
                g.setColor(0x0000ff00);
                g.drawRect(hős.oszlop()*téglaSzélesség,
                        hős.sor()*téglaMagasság,
                        téglaSzélesség, téglaMagasság);
            }
            // A játék aktuális adataiból néhány kiíratása
            g.setColor(0x000000ff);
            g.drawString("Életek száma: "+hős.életek(), 10, 15,
                    javax.microedition.lcdui.Graphics.LEFT
                    |javax.microedition.lcdui.Graphics.BOTTOM);
            g.drawString("Gyűjtött érték: "+hős.pontszám(), 10, 30,
                    javax.microedition.lcdui.Graphics.LEFT
                    |javax.microedition.lcdui.Graphics.BOTTOM);
            g.drawString("Idő: "+idő/5, 10, 45,
                    javax.microedition.lcdui.Graphics.LEFT
                    |javax.microedition.lcdui.Graphics.BOTTOM);
            
            if(játékVége)
                g.drawString(végeÜzenet, 10, magasság-20,
                        javax.microedition.lcdui.Graphics.LEFT
                        |javax.microedition.lcdui.Graphics.BOTTOM);
            
            flushGraphics();
            
            idoegyseg();
        }
    }
    /** A játék szál leállítása. */
    public void játékKilép() {
        
        játékKilép = true;
        játékSzál = null;
        
    }
    /** Megadja, hogy milyen gyorsan telik az idő a játékban. */
    private void idoegyseg() {
        
        ++ idő;        
        try {            
            Thread.sleep(200);            
        } catch(InterruptedException e) {}        
    }
}               
                ]]>
            </programlisting>

			<para>
				A <citation>PROGRAMOZÓ PÁTERNOSZTER JEGYZET</citation> jegyzetben számos
				további mobil programozási példát talál az érdeklődő Olvasó. Jelen vászon
				osztályunk triviális továbbfejlesztési lehetősége, hogy a szereplőket nem
				képpel, hanem a <classname>javax.microedition.lcdui.game</classname>
				csomagbeli <classname>Sprite</classname> objektumokkal reprezentálnánk. Ebben a 
				feladatban is segít az imént hivatkozott jegyzet.
			</para>

			</sect3>

        </sect2>
        
        <sect2 id="labirintus_servlet">
            <title>Java a webszerverekben: Servlet objektumok - Labirintus Servlet</title>
            
            
<para>
Az <emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>
            című pontban bevezetett esettanulmány végleges kódját adjuk meg itt.
            </para>            
            
            <para>
            Ennek a példának a fejlesztését is a <application>NetBeans IDE</application> fejlesztői környezetben végezzük.
            A <guimenuitem>File/New Project...</guimenuitem> pont kiválasztása után
            a kinyíló New Project ablakban első 
            lépésként válasszuk a <guilabel>Web</guilabel>
            kategóriát, azon belül a <guilabel>Web Application</guilabel> projektet. A 
            <guibutton>Next</guibutton> gombra következő ablakban elég a projekt nevét
            megadni, ez legyen mondjuk a <userinput>JavatTanitokWebes</userinput>. 
            Majd a felkínált alapértelmezések elfogadása mellett nyomjunk újabb 
             <guibutton>Next</guibutton> gombokat a <guibutton>Finish</guibutton>
             gomb megjelenéséig, melynek nyomásával a projekt létrehozását befejeztük.
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbw1.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokWebes projekt.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
            Az előző esettanulmányok felélesztéséhez hasonlóan a
             <guilabel>Source Packages/default package</guilabel> csomagon egy 
            <mousebutton>jobb egérgombot</mousebutton> nyomva válasszuk a
			<guimenuitem>New/Java Package...</guimenuitem> menüpontot! A kinyíló
            ablakban adjuk meg a <userinput>javattanitok</userinput> 
            csomag nevet. 
			Miután a <guibutton>Finish</guibutton> gombbal befejezzük a csomag létrehozását, 
			a projekt forráskönyvtárában, esetünkben a 
			<filename>C:\Documents and Settings\norbi\JavatTanitokWebes\src\java</filename>
			könyvtárban megjelenik a <filename class="directory">javattanitok</filename> alkönyvtár.
			Másoljuk ebbe a frissen létrejött könyvtárba a
			kézikönyv 
			<filename>LabirintusServlet.java</filename> forrását.  A labirintus API-t most nem másoljuk ide,
			hanem csak megmondjuk a <application>NetBeans IDE</application>  környezetnek, hogy
			hol találja a használni kívánt labirintus API-t, azaz a <classname>javattanitok.labirintus</classname> csomagot. 
			Például a korábban elkészített <filename class="directory">javattanitokPeldak.jar</filename> Java archívum állományban.
			Ehhez a <application>NetBeans IDE</application> projektek fülében a 
            <computeroutput>JavatTanitokWebes</computeroutput> projekt néven egy 
            <mousebutton>jobb egérgombot</mousebutton> nyomva a tulajdonságok
            <guimenuitem>Properties</guimenuitem> menüpontot választva a 
            kinyíló ablak <computeroutput>Libraries</computeroutput> pontját
            kérve, az <computeroutput>Add JAR/Folder...</computeroutput> gombbal a 
            <filename>C:\Documents and Settings\norbi\JavatTanitokPeldak\dist\JavatTanitokPeldak.jar</filename>
			jar állományt hozzáadva a projekt fordítása már menni fog. 			
			</para>      

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbw2.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokWebes projektnek megadjuk a labirintus API jar állományát.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
			A projekt futtatásához azonban még a projekt webalkalmazásként való létét is konfigurálnunk kell.
			Ehhez a <application>NetBeans IDE</application> projektek fülében a 
            <computeroutput>JavatTanitokWebes</computeroutput> projekt 
            <computeroutput>Configuration Files</computeroutput> pontját lenyitva a 
            <filename>web.xml</filename> állomány kell kinyitnunk. Itt a 
            <computeroutput>Servlet</computeroutput> fülre kattintva az alábbi beállításokat végezzük el:
            </para>
            
            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbw3.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokWebes webalkalmazás szervletjének beállítása.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
			Itt az <guilabel>Add Servlet Element</guilabel> gomb nyomása után a 
            <computeroutput>Servlet Class</computeroutput> böngészéssel való megadása és a 
            <computeroutput>URL Pattern(s)</computeroutput> tetszőleges magadása fontos. A jelen beállítással
            a <classname>javattanitok.LabirintusServlet</classname> osztályt a weben, azaz egy böngészőprogramon
            keresztül majd a <computeroutput>http://localhost:8084/JavatTanitokWebes/labirintus</computeroutput> URL címen érjük el.
            </para>
            
            <para>
            Ha ezzel megvagyunk, jöhet a tesztelés, egyszerűen nyomjunk 
            <keycap>F6</keycap> funkcióbillentyűt, vagy
            a <guimenuitem>Run/Run Main Projekt</guimenuitem> menüpontot! Majd az internetes böngészőnkben
            keressük fel a 
            <computeroutput>http://localhost:8084/JavatTanitokWebes/labirintus</computeroutput> URL címet.
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbw4.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokWebes webalkalmazás kimenete a böngészőben.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <para>
            A megfelelő linkek választásával a böngészőben akár győzhetünk is!
            </para>

            <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/labirintus/nbw5.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A JavatTanitokWebes példában éppen győzött a játékos.</phrase>
                    </textobject>	
                </inlinemediaobject>                    
            </para>

            <sect3>
            <title>A LabirintusServlet osztály</title>
            
            <para>
            Ha szervletünket a HTTP protokoll GET kérésével felkeressük, akkor a 
            <classname>HttpServlet</classname> osztály <function>doGet</function> metódusa fog
            meghívódni. A hívásban az aktuális paraméterként kapott 
            <classname>HttpServletRequest</classname> és 
            <classname>HttpServletResponse</classname> objektumok reprezentálják a HTTP
            kérést és választ szervletünk mikrovilágában. A válasz objektumtól elkért
            csatorna érdekessége, hogy a másik vége a szervletünket felkereső böngészőben van.
            Ennek megfelelően a csatornát karakteresre nyitjuk és szöveget, HTML szöveget
            nyomunk ki rá. A példa további érdekessége, hogy arra is példát mutat, hogyan tudunk
            a szerver oldalon információt megőrizni az egyébként független - de egy játékostól jövő
             - HTTP kérések között.
            </para>
            
            <programlisting>
                <![CDATA[
/*
 * LabirintusServlet.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * HTTP szervletes életre keltésére ad példát ez az osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusVilág
 * @see javattanitok.LabirintusApplet
 * @see javattanitok.LabirintusJáték
 * @see javattanitok.LabirintusMIDlet
 * @see javattanitok.HálózatiLabirintus
 * @see javattanitok.TávoliLabirintus
 * @see javattanitok.KorbásLabirintus
 */
public class LabirintusServlet extends javax.servlet.http.HttpServlet {
    /**
     * A HTTP GET kérés kiszolgálása.
     *
     * @param httpKérés a HTTP kérést reprezentáló objektum
     * @param httpVálasz a HTTP választ reprezentáló objektum
     */
    protected void doGet(javax.servlet.http.HttpServletRequest httpKérés,
            javax.servlet.http.HttpServletResponse httpVálasz)
            throws javax.servlet.ServletException, java.io.IOException {
        // A válasz csatornán küldött adatokat a böngésző
        // mint html oldalt értelmezze 
        httpVálasz.setContentType("text/html;charset=UTF-8");
        // Elkérjük a böngészőbe menő csatornát
        java.io.PrintWriter csatornaBöngészőbe = httpVálasz.getWriter();
        // Elkezdjük beleírni válaszunkat html-ben
        csatornaBöngészőbe.println("<html>");
        csatornaBöngészőbe.println("<head>");
        // A böngészőablek címe
        csatornaBöngészőbe.println("<title>Javat tanítok LabirintusServlet</title>");
        csatornaBöngészőbe.println("</head>");
        csatornaBöngészőbe.println("<body>");
        // Ez a böngésző kapcsolatban van már a szerverünkkel?
        javax.servlet.http.HttpSession session = httpKérés.getSession();
        // A hőst és a labirintust majd ebben a kapcsolatot
        // reprezentáló objektumban tároljuk.
        Labirintus labirintus = null;
        Hős hős = null;
        // Ha a kapcsolat most épült fel        
        if(session.isNew()) {
            // akkor elkészítünk egy új labirintust és hőst
            csatornaBöngészőbe.println("Helló, új játékot kezdünk!<br>");
            labirintus = new Labirintus(6, 3);
            hős = new Hős(labirintus);
            hős.sor(9);
            hős.oszlop(0);
            // majd betesszük a kapcsolatot reprezentáló objektumba, hogy a
            // legközelebbi kérésével jövő ugyanazon játékos ki tudja venni
            session.setAttribute("labirintus", labirintus);
            session.setAttribute("hos", hős);
        
        // Különben, azaz, ha már volt kapcslat
        } else {
            // akkor kivesszük a kapcsolatot reprezentáló objektumból
            csatornaBöngészőbe.println("Helló, régi játékot folytatjuk<br>");
            labirintus = (Labirintus)session.getAttribute("labirintus");
            hős = (Hős)session.getAttribute("hos");
            
            if(hős == null || labirintus == null) {
                // Ha esetleg a tesztelés során gond lenne a session kezeléssel...
                log("Új labirintust készítettünk...");
                labirintus = new Labirintus(6, 3);
                hős = new Hős(labirintus);
                hős.sor(9);
                hős.oszlop(0);
                session.setAttribute("labirintus", labirintus);
                session.setAttribute("hos", hős);
                
            }
            
        }        
        // A válasz lapra kiírjuk a hős lépésénél a választási lehetőségeket
        // a ?lepes= megfelelő irány formában
        csatornaBöngészőbe.println("<br>Merre lépjen a hős?<br>");
        csatornaBöngészőbe.println("<a href=\"/JavatTanitokWebes/" +
                "labirintus?lepes=fol\">Föl</a>");
        csatornaBöngészőbe.println("<br>");
        csatornaBöngészőbe.println("<a href=\"/JavatTanitokWebes/" +
                "labirintus?lepes=le\">Le</a>");
        csatornaBöngészőbe.println("<br>");
        csatornaBöngészőbe.println("<a href=\"/JavatTanitokWebes/" +
                "labirintus?lepes=jobbra\">Jobbra</a>");
        csatornaBöngészőbe.println("<br>");
        csatornaBöngészőbe.println("<a href=\"/JavatTanitokWebes/" +
                "labirintus?lepes=balra\">Balra</a>");        

        // A mostani kérésben jött valami infó a lépéssel kapcsolatban?
        String lepesString = httpKérés.getParameter("lepes");
        // Ha igen, akkor annak megfelelően lépünk
        if("fol".equals(lepesString))
            hős.lépFöl();
        else if("le".equals(lepesString))
            hős.lépLe();
        else if("jobbra".equals(lepesString))
            hős.lépJobbra();
        else if("balra".equals(lepesString))
            hős.lépBalra();
        
        // Történt ezzel a lépéssel valami érdekes a labirintusban?
            switch(labirintus.bolyong(hős)) {
                
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                    break;
                case Labirintus.JÁTÉK_MEGY_MEGHALT_HŐS:
                    // Még van élete, visszatesszük a kezdő pozícióra
                    hős.sor(9);
                    hős.oszlop(0);
                    break;                    
                case Labirintus.JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN:
                    csatornaBöngészőbe.println("<h1>GYŐZTÉL</h1>");
                    session.invalidate();                    
                    break;                    
                case Labirintus.JÁTÉK_VÉGE_MEGHALT_HŐS:
                    session.invalidate();
                    csatornaBöngészőbe.println("<h1>VESZTETTÉL</h1>");
                    break;                    
            }
            // Kinyomtatjuk a labirintus aktuális állapotát
            csatornaBöngészőbe.println("<pre>");
            csatornaBöngészőbe.println(labirintus.kinyomtat(hős));
            csatornaBöngészőbe.println("</pre>");
            // és néhány infót a játék aktuális adataiból
            csatornaBöngészőbe.println("<br>");
            csatornaBöngészőbe.println("<br>Életek száma: " + hős.életek());
            csatornaBöngészőbe.println("<br>Gyűjtött érték: "+hős.pontszám());            
            csatornaBöngészőbe.println("</body>");
            csatornaBöngészőbe.println("</html>");
            // Zárjuk a böngészőbe irányuló csatornát.
            csatornaBöngészőbe.close();
    }    
}
                ]]>
            </programlisting>

			</sect3>

            
        </sect2>
        
        <sect2>
            <title>Java a hálózaton</title>
            
            <para>
            A következő példák a socket programozás absztrakciós szintjéről
            indulva egyre magasabb szinteken üzemelnek.
            </para>
            
            <sect3 id="labirintus_socket">
                <title>TCP/IP - Hálózati Labirintus</title>
            
            <para>            
Az <emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>
            című pontban bevezetett esettanulmány végleges kódját adjuk meg itt.            
            </para>
            
            <para>
            A példa kipróbálásához szükségünk van a 
			<emphasis><link linkend="labirintus_elesztes">A labirintus API felélesztése</link></emphasis>
			című pontban beállított labirintus API-ra, sőt,  ezt ebben a pontban tovább is kell fejlesztenünk. A
			<classname>javattanitok.labirintus</classname> csomagbeli 
			<classname>Labirintus</classname> osztályt kiterjesztjük a <classname>TöbbHősösLabirintus</classname>
			osztállyal, amelyben egy hős halála immár nem jelenti a labirintus játék végét is egyben.
            </para>

            <para>
            A <filename>HálózatiLabirintus.java</filename> és a 
            <filename>LabirintusKiszolgálóSzál.java</filename> forrásokat másoljuk a 
           <filename>Munkakönyvtár</filename> nevű munkakönyvtárunkból nyíló 
           <filename class="directory">javattanitok</filename> könyvtárba, mert ezek az osztályok a 
           <classname>javattanitok</classname> csomag részei. A <classname>TöbbHősösLabirintus</classname>
           osztályt a <classname>javattanitok.labirintus</classname> csomag részeként fejlesztettük ki, ezért
           a <filename>TöbbHősösLabirintus.java</filename> állományt a 
           <filename class="directory">javattanitok/labirintus</filename> könyvtárba másoljuk be.
            </para>
            
            <sect4>
            <title>A HálózatiLabirintus osztály</title>
            
<para>
Az osztály elindítja a szerver programot és a játék 
a <constant>LABIRINTUS_PORT</constant> kapunál várakozik a kliensekre. Mindeközben a 
szokásos párhuzamosan indított programszálon vezérli a labirintus mikrovilágának életét.
Fontos továbbfejlesztés, hogy ugyanabban a - <classname>Labirintus</classname>
osztály továbbfejlesztéseként megírt <classname>TöbbHősösLabirintus</classname> 
osztálybeli - labirintusunkban több hősünk lehet, akiket egy
<classname>Hashtable</classname> adatszerkezetben foglal csokorba a szerver.
</para>            
            <programlisting>
                <![CDATA[
public class HálózatiLabirintus implements Runnable {
    /** A játék aktuális labirintusa, minden hálózati hős ebben mozog. */
    TöbbHősösLabirintus labirintus;
    /** A hősök. */
    java.util.Hashtable hősök;
    /** Melyik porton megy a játék. */
    private static final int LABIRINTUS_PORT = 2006;                
                ]]>
            </programlisting>
<para>
A hősök adminisztrációját a <classname>HálózatiLabirintus</classname> osztály <function>hős()</function>
módszere intézi, ami a szerver és a kliensei közötti kommunikációt lebonyolító <classname>LabirintusKiszolgálóSzál</classname> a szerver végrehajtási szálával párhuzamosan futó 
<function>run()</function> metódusából hívódik.	
</para>            
            <programlisting>
                <![CDATA[
/*
 * HálózatiLabirintus.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * TCP/IP-s hálózati életre keltésére ad példát ez az osztály.
 * Tesztelése például a telnet TCP klienssel:
 * <pre>
 * telnet niobe 2006
 * A hős neve?
 * Matyi
 * Parancsok: l = le, f = föl, j = jobbra, b = balra k = kilép
 *            sima ENTER = megmutatja a labirintust
 *
 * --- Labirintusszerinti idő: 13. pillanat -------
 * --- Összes hősök száma: 1
 * --- Életek száma: 5
 * --- Gyűjtött érték: 0
 * --- A labirintus: (13. pillanat) -------
 * |   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
 * |   |   |   |   |K  |   |   |   |   |
 * |FAL|   |FAL|   |FAL|   |FAL|   |FAL|
 * |   |   |   |K  |FAL|   |FAL|   |   |S
 * |   |FAL|FAL|S  |   |   |FAL|FAL|   |FAL
 * |   |   |   |   |FAL|K  |   |   |   |
 * |   |FAL|   |   |   |FAL|K  |FAL|FAL|
 * |   |   |K  |FAL|   |FAL|S  |FAL|   |
 * |   |FAL|   |   |   |   |   |   |   |FAL
 * |H  |   |   |   |FAL|   |   |   |FAL|FAL
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusVilág
 * @see javattanitok.LabirintusApplet
 * @see javattanitok.LabirintusJáték
 * @see javattanitok.LabirintusMIDlet
 * @see javattanitok.LabirintusServlet
 * @see javattanitok.TávoliLabirintus
 * @see javattanitok.KorbásLabirintus
 * @see javattanitok.ElosztottLabirintus
 * @see LabirintusKiszolgálóSzál
 */
public class HálózatiLabirintus implements Runnable {
    /** A játék aktuális labirintusa, minden hálózati hős ebben mozog. */
    TöbbHősösLabirintus labirintus;
    /** A hősök. */
    java.util.Hashtable hősök;
    /** Melyik porton megy a játék. */
    private static final int LABIRINTUS_PORT = 2006;
    /** A játékbeli idő mérésére.*/
    private long idő = 0;
    /** Jelzi a játék végét, ezután a játék álapota már nem változik. */
    private boolean játékVége = false;
    /**
     * Argumentum nélküli konstruktor, gyerekek implicit super()-éhez.
     */
    public HálózatiLabirintus(){}
    /**
     * A <code>HálózatiLabirintus</code> objektum elkészítése.
     *
     * @param      labirintusFájlNév       a labirintust definiáló, megfelelő 
     * szerkezetű szöveges állomány neve.
     * @exception  RosszLabirintusKivétel  ha a labirintust definiáló állomány 
     * nem a megfelelő szerkezetű
     */
    public HálózatiLabirintus(String labirintusFájlNév) throws 
            RosszLabirintusKivétel {
        // A labirintus elkészítése állományból
        labirintus = new TöbbHősösLabirintus(labirintusFájlNév);
        // A hős elkészítése és a kezdő pozíciójának beállítása
        hősök = new java.util.Hashtable();
        // A játékbeli idő folyását biztosító szál elkészítése és indítása
        new Thread(this).start();
        // A TCP szerver indítása
        try {
            java.net.ServerSocket serverSocket =
                    new java.net.ServerSocket(LABIRINTUS_PORT);
            while(true) {
                // Várakozás a játékosok jelentkezésére
                java.net.Socket socket = serverSocket.accept();
                // akiket külön szálban szolgálunk ki
                new LabirintusKiszolgálóSzál(socket, this);
            }
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    /**
     * A hálózaton keresztül jelentkező hős elkészítése.
     *
     * @param   név     a hős neve (= "hoszt IP : név").
     * @return Hős      a névhez tartozó, esetleg újonan létrehozott hős.
     */
    public Hős hős(String név) {
        
        // Ha már létező hős jelentkezett be újra a játékba
        if(hősök.containsKey(név))
            return (Hős)hősök.get(név);
        // Vagy új játékos jön
        else {
            // aki még nincs a hősök között
            // akkor új hősként létrehozzuk
            Hős hős = new Hős(labirintus);
            // A hős kezdő pozíciója
            hős.sor(9);
            hős.oszlop(0);
            // Felvétele a hősök közé
            hősök.put(név, hős);
            
            return hős;
        }        
    }
    /**
     * A valamikor hálózaton keresztül jelentkező hős törlése.
     *
     * @param   név     a hős neve (= "hoszt IP : név").
     */
    public void hősMeghalt(String név) {        
            // Törlés a hősök közül
            hősök.remove(név);
    }
    /**
     * A hősök száma.
     *
     * @return int a hősök száma.
     */
    public int hősökSzáma() {
        
        return hősök.size();
        
    }
    /**
     * A labirintus játék világának ideje.
     *
     * @return long labirintus játék világának ideje.
     */
    public long idő() {
        
        return idő;
        
    }
    /**
     * A játék aktuális labirintusa, minden hálózati hős ebben mozog.
     *
     * @return Labirintus a labirintus.
     */
    public Labirintus labirintus() {
        
        return labirintus;
        
    }
    /** A játék időbeli fejlődésének vezérlése. */
    public void run() {
        
        while(!játékVége) {
            
            idoegyseg();
            
            System.out.println("Hősök száma: " + hősök.size());
            java.util.Enumeration e = hősök.elements();
            while(e.hasMoreElements()) {
                
                Hős hős = (Hős)e.nextElement();
                
                    switch(labirintus.bolyong(hős)) {
                        
                        case TöbbHősösLabirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                            break;
                        case Labirintus.JÁTÉK_MEGY_MEGHALT_HŐS:
                            hős.sor(9);
                            hős.oszlop(0);
                            System.out.println("Megettek a(z) " + idő 
                                    + ". lépésben!");
                            break;
                        case Labirintus.JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN:
                            System.out.println("Megvan minden kincs a(z) " 
                                    + idő + ". lépésben!");
                            játékVége = true;
                            break;
                        case Labirintus.JÁTÉK_VÉGE_MEGHALT_HŐS:
                            System.out.println("Minden életem elfogyott a(z) " 
                                    + idő + ". lépésben!");
                            // Ebben a változatban több hős bolyong, 
                            // így immár egyikük halála nem jelenti a 
                            // játék végét is:
                            // játékVége = true; 
                            break;                            
                    }
            }                        
        }                
    }
    /** Megadja, hogy milyen gyorsan telik az idő a játékban. */
    private void idoegyseg() {
        
        ++idő;        
        try {            
            Thread.sleep(1000);            
        } catch(InterruptedException e) {}        
    }
    /**
     * Átveszi a játék indításához szükséges paramétereket, majd
     * elindítja a játék világának működését.
     *
     * @param args a labirintus tervét tartalmazó állomány neve az első 
     * parancssor-argumentum.
     */
    public static void main(String[] args) {
        
        if(args.length != 1) {
            
            System.out.println("Indítás: " +
                    "java javattanitok.HálózatiLabirintus labirintus.txt");
            System.exit(-1);
        }
        
        try {
            
            new HálózatiLabirintus(args[0]);
            
        } catch(RosszLabirintusKivétel rosszLabirintusKivétel) {
            
            System.out.println(rosszLabirintusKivétel);
            
        }
    }
}                
                ]]>
            </programlisting>
            
<para>
A <classname>HálózaiLabirintus</classname> szerver <function>accept()</function> függvényében
megjelenő kliensekkel a következő osztály foglalkozik.
</para>
            
			</sect4>
				
            <sect4>
            <title>A LabirintusKiszolgálóSzál osztály</title>
            
<para>
Ez az osztály kommunikál a bejelentkező TCP-s kliensekkel.
</para>            
            
            <programlisting>
                <![CDATA[
/*
 * LabirintusKiszolgálóSzál.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának
 * TCP/IP-s hálózati életre keltését bemutató
 * <code>javattanitok.HálózatiLabirintus</code> osztály hálózati
 * kiszolgálását végző szál. A kommunikációs socket kapcsolattól
 * elkéri a kimeneti és bemeneti csatornát, majd a játékos inputját
 * átvéve végtehajtja a hős mozgatását.
 *
 * Egy pillanatfelvétel a kiszolgálásról:
 * <pre>
 * telnet niobe 2006
 * A hős neve?
 * Matyi
 * Parancsok: l = le, f = föl, j = jobbra, b = balra k = kilép
 *            sima ENTER = megmutatja a labirintust
 *
 * --- Labirintusszerinti idő: 13. pillanat -------
 * --- Összes hősök száma: 1
 * --- Életek száma: 5
 * --- Gyűjtött érték: 0
 * --- A labirintus: (13. pillanat) -------
 * |   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
 * |   |   |   |   |K  |   |   |   |   |
 * |FAL|   |FAL|   |FAL|   |FAL|   |FAL|
 * |   |   |   |K  |FAL|   |FAL|   |   |S
 * |   |FAL|FAL|S  |   |   |FAL|FAL|   |FAL
 * |   |   |   |   |FAL|K  |   |   |   |
 * |   |FAL|   |   |   |FAL|K  |FAL|FAL|
 * |   |   |K  |FAL|   |FAL|S  |FAL|   |
 * |   |FAL|   |   |   |   |   |   |   |FAL
 * |H  |   |   |   |FAL|   |   |   |FAL|FAL
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.HálózatiLabirintus
 */
public class LabirintusKiszolgálóSzál implements Runnable {
    /** TCP-s kommunikációs kapcsolat a játékossal. */
    java.net.Socket socket;
    HálózatiLabirintus hálózatiLabirintus;
    /**
     * A <code>LabirintusKiszolgálóSzál</code> objektum elkészítése.
     *
     * @param   socket              TCP socket kapcsolat a játékossal.
     * @param   hálózatiLabirintus  A labirintust tartalmazó TCP szerver
     * <code>javattanitok.HálózatiLabirintus</code> osztály
     */
    public LabirintusKiszolgálóSzál(java.net.Socket socket, 
            HálózatiLabirintus hálózatiLabirintus) {
        this.socket = socket;
        this.hálózatiLabirintus = hálózatiLabirintus;
        new Thread(this).start();
    }
    /** A jelentkező játékosokat párhuzamosan kiszolgáló szál. */
    public void run() {
        try {
            // A socket kapcsolat feletti bejövő csatorna elkérése
            java.io.BufferedReader bejövőCsatorna =
                    new java.io.BufferedReader(
                    new java.io.InputStreamReader(socket.
                    getInputStream()));
            // A socket kapcsolat feletti kimenő csatorna elkérése
            java.io.PrintWriter kimenőCsatorna =
                    new java.io.PrintWriter(socket.getOutputStream());
            // A hős nevének beolvasása
            kimenőCsatorna.println("A hős neve?");
            kimenőCsatorna.flush();
            String játékostól = bejövőCsatorna.readLine();
            // Vagy új vagy régi a hős, a hős neve = "hoszt IP : név"
            String hősNév = socket.getInetAddress().getHostAddress() +
                    " : " + játékostól;
            Hős hős = hálózatiLabirintus.hős(hősNév);
            // Informáljuk a játékost a játék használatáról
            kimenőCsatorna.println("Parancsok: l = le, f = föl, " +
                    "j = jobbra, b = balra k = kilép");
            kimenőCsatorna.println("           sima ENTER = " +
                    "megmutatja a labirintust");
            kimenőCsatorna.flush();
            
            játékostól = bejövőCsatorna.readLine();
            
            while(játékostól != null) {
                // A játékostól érkező parancsok feldolgozása
                if("l".equals(játékostól))
                    hős.lépLe();
                else if("f".equals(játékostól))
                    hős.lépFöl();
                else if("j".equals(játékostól))
                    hős.lépJobbra();
                else if("b".equals(játékostól))
                    hős.lépBalra();
                else if("k".equals(játékostól))
                    break;
                
                kimenőCsatorna.println("--- Labirintusszerinti idő: "
                        + hálózatiLabirintus.idő() + ". pillanat -------");
                kimenőCsatorna.println("--- Összes hősök száma: " 
                        + hálózatiLabirintus.hősökSzáma());
                kimenőCsatorna.println("--- Életek száma: " + hős.életek());
                kimenőCsatorna.println("--- Gyűjtött érték: " + hős.pontszám());
                kimenőCsatorna.println("--- A labirintus: (" 
                        + hálózatiLabirintus.idő()+". pillanat) -------");
                // Megmutatjuk a labirintus aktuális állapotát
                hálózatiLabirintus.labirintus().nyomtat(hős, kimenőCsatorna);
                kimenőCsatorna.flush();
                if(hős.életek() <= 0) {
                    hálózatiLabirintus.hősMeghalt(hősNév);
                    break;
                }
                játékostól = bejövőCsatorna.readLine();                
            }
            
            socket.close();
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();
            
        } finally {
            
            if(socket != null) {
                
                try{
                    socket.close();
                } catch(Exception e) {}                
            }
            
        }        
    }    
}               
                ]]>
            </programlisting>
			</sect4>

            <sect4 id="tobbhososlabirintus_osztaly">
            <title>A TöbbHősösLabirintus osztály</title>

<para>
Ebben az osztályban felüldefiniáljuk az ős <classname>Labirintus</classname>
osztály vezérlő <function>bolyong()</function> módszerét, itt egy hős halála már nincs
hatással a játék állapotára.
</para>
            
            <programlisting>
                <![CDATA[
/*
 * TöbbHősösLabirintus.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.labirintus;
/**
 * A több hősös labirintust leíró osztály, ahol egy hős halála
 * már nem jelenti a labirintus játék végét. A játék állapotát
 * a korábbi játékokban a labirintushoz kapcsoltuk, most, hogy
 * olyan továbbfejlesztett labirintust akarunk, amiben több hős
 * is bolyonghat, úgy érezzük, hogy a játék vége inkább a hőshöz
 * tartozik, semmint a labirintushoz. Mindkettő igaz: mert, ha a
 * kincsek fogynak el, akkor a labirintus oldaláról van vége a
 * játéknak.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class TöbbHősösLabirintus extends Labirintus {
    /**
     * Argumentum nélküli konstruktor, gyerekek implicit super()-éhez.
     */
    public TöbbHősösLabirintus() {}
    /**
     * A <code>TöbbHősösLabirintus</code> objektum elkészítése.
     *
     * @param      labirintusFájlNév       a labirintust definiáló, megfelelő 
     * szerkezetű szöveges állomány neve.
     * @exception  RosszLabirintusKivétel  ha a labirintust definiáló állomány nem 
     * a megfelelő szerkezetű
     */
    public TöbbHősösLabirintus(String labirintusFájlNév) throws 
            RosszLabirintusKivétel {
        
        super(labirintusFájlNév);
        
    }
    /**
     * Az ős megfelelő metódusának elfedése, mert ez a JÁTÉK_VÉGE_MEGHALT_HŐS
     * csak a hős végét jelenti, a labirintusét nem!
     *
     * @see Labirintus#bolyong(Hős hős)
     * @param hős aki a labirintusban bolyong.
     * @return int a játék állapotát leíró kód.
     */
    public int bolyong(Hős hős) {
        
        boolean mindMegvan = true;
        
        for(int i=0; i < kincsek.length; ++i) {
            
            // A hős rátalált valamelyik kincsre?
            if(kincsek[i].megtalált(hős))
                hős.megtaláltam(kincsek[i]);
            
            // ha ez egyszer is teljesül, akkor nincs minden kincs megtalálva
            if(!kincsek[i].megtalálva())
                mindMegvan = false;
            
        }
        
        if(mindMegvan) {
            
            játékÁllapot = JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN;
            return játékÁllapot;
            
        }
        
        for(int i=0; i < szörnyek.length; ++i) {
            
            szörnyek[i].lép(hős);
            
            if(szörnyek[i].megesz(hős))  {
                
                if(hős.megettek())
                    // De ez a játék vége csak a hős végét
                    // jelenti, a labirintusét nem!
                    return JÁTÉK_VÉGE_MEGHALT_HŐS;
                else
                    return JÁTÉK_MEGY_MEGHALT_HŐS;
                
            }            
        }
        
        return JÁTÉK_MEGY_HŐS_RENDBEN;
    }
}               
                ]]>
            </programlisting>
			</sect4>

            <sect4>
            <title>A HálózatiLabirintus fordítása, futtatása</title>
            
		   <para>
		   A szerver oldalon fordítunk és futtatjuk a programot.
           <screen>
                <![CDATA[
[norbi@niobe Munkakönyvtár]$ javac javattanitok/HálózatiLabirintus.java
Note: javattanitok/HálózatiLabirintus.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
[norbi@niobe Munkakönyvtár]$ java javattanitok.HálózatiLabirintus labirintus.txt
Hősök száma: 0
Hősök száma: 0
Hősök száma: 0
...
                ]]>
            </screen>     
            </para>                

		   <para>
		   A szerver futtattása után egy másik ablakban (vagy akár egy másik gépen) futtassuk a klienst, ami most
		   egyszerűen a <application>telnet</application> program. A <command>telnet</command> parancs után a
		   szerver programot futtató hoszt nevét írjuk, ha ez ugyanaz a gép, mint amelyiken a klienst is éppen
		   futtatni akarjuk, akkor - akár Windows, akár Linux alatt - a <computeroutput>localhost</computeroutput>
		   nevet írhatjuk. A második megadott parancssor-argumentum annak a TCP kapunak a sorszáma, amin a 
		   szerver figyeli a kliensek kapcsolatfelvételi kérelmeit, most a 2006.
           <screen>
                <![CDATA[
[norbi@niobe ~]$ telnet localhost 2006
Trying 127.0.0.1...
Connected to localhost.localdomain (127.0.0.1).
Escape character is '^]'.
A hős neve?
Matyi
Parancsok: l = le, f = föl, j = jobbra, b = balra k = kilép
           sima ENTER = megmutatja a labirintust

--- Labirintusszerinti idő: 36. pillanat -------
--- Összes hősök száma: 1
--- Életek száma: 5
--- Gyűjtött érték: 0
--- A labirintus: (36. pillanat) -------
|   |   |K  |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |   |   |   |K  |K  |   |   |K
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|
|   |   |   |   |FAL|   |FAL|   |   |
|   |FAL|FAL|SK |   |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |   |S  |
|   |FAL|   |   |   |FAL|S  |FAL|FAL|
|   |   |   |FAL|   |FAL|   |FAL|   |
|   |FAL|   |   |   |   |   |   |   |FAL
|H  |   |   |   |FAL|   |   |   |FAL|FAL
                ]]>
            </screen>     
            </para>                

		   <para>
		   A szerver oldalon a kliens belépésének megfelelően látjuk, hogy nőtt a hősök száma.
           <screen>
                <![CDATA[
...
Hősök száma: 1
Hősök száma: 1
Hősök száma: 1
...
                ]]>
            </screen>     
            </para>                

		   <para>
			A játékos a fenti <userinput>ENTER</userinput> alkalmazása után most az 
			 <userinput>f</userinput> felfelé léptető parancsot adja ki:
           <screen>
                <![CDATA[
f
--- Labirintusszerinti idő: 415. pillanat -------
--- Összes hősök száma: 2
--- Életek száma: 5
--- Gyűjtött érték: 0
--- A labirintus: (415. pillanat) -------
|   |   |K  |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |   |   |   |K  |K  |   |   |K
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|
|   |   |   |   |FAL|   |FAL|   |   |
|   |FAL|FAL|SK |   |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|K  |   |   |S  |
|   |FAL|   |   |   |FAL|S  |FAL|FAL|
|   |   |   |FAL|   |FAL|   |FAL|   |
|H  |FAL|   |   |   |   |   |   |   |FAL
|   |   |   |   |FAL|   |   |   |FAL|FAL
                ]]>
            </screen>    
            Majd a <userinput>k</userinput> billentyűvel lépjünk ki a jelen <userinput>Matyi</userinput> nevű hősös kliensünkből. Ha újra 
            jelentkezünk egy klienssel ugyanerről a gépről és a <userinput>Matyi</userinput> hősnevet adjuk meg, akkor
            a szerver emlékezni fog a hős aktuális pozíciójára.
            </para>                

		   <para>
		Léptessünk be további hősöket, megint csak egy másik ablakban, vagy akár egy másik gépen!  Figyeljük meg, hogy a 
		szerver tovább növeli a hősök számát. Vegyük észre, hogy a kliensek kilépésétől függetlenül a hősök a labirintusban
		maradnak, csak akkor kerülnek ki, ha minden életük elfogy és pusztán akkor nem, ha a játékos éppen kilép a kliens programból
		és ennek megfelelően nem jön létre új hős, ha ugyanarról a gépről, ugyanazzal a hős névvel jelentkezik egy kliens.
Mindezt a <classname>HálózatiLabirintus</classname> osztály <function>hős()</function>
módszere intézi, ami a kommunikációt végző <classname>LabirintusKiszolgálóSzál</classname>
<function>run()</function> metódusából hívódik.		
            </para>                

            </sect4>
            
			</sect3>        

            <sect3 id="labirintus_rmi">
                <title>Java RMI - Távoli Labirintus </title>

            <para>            
Az <emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>
            című pontban bevezetett esettanulmány végleges kódját adjuk meg itt.            
            </para>
                        
            <para>
            A példa kipróbálásához szükségünk van a 
			<emphasis><link linkend="labirintus_elesztes">A labirintus API felélesztése</link></emphasis>
			című pontban beállított labirintus API-ra és az előző pontban továbbfejlesztésként készített
			<classname>TöbbHősösLabirintus</classname> osztályra. Sőt, a - szintén az előző pontbeli -
			<classname>HálózatiLabirintus</classname> osztályra is, mert jelen
			<classname>TávoliLabirintus</classname> osztályunkat ennek kiterjesztéseként fogjuk elkészíteni.
            </para>

            <para>
            Az új <filename>TávoliLabirintus.java</filename>, 
            <filename>TávoliHősíthető.java</filename> és a 
            <filename>TávoliKliens.java</filename> forrásokat másoljuk a 
           <filename>Munkakönyvtár</filename> nevű munkakönyvtárunkból nyíló 
           <filename class="directory">javattanitok</filename> könyvtárba, mert ezeket az osztályokat 
           szokásosan a 
           <classname>javattanitok</classname> csomag részeiként írjuk meg. 
            </para>
                        

            <sect4>
                <title>A TávoliLabirintus osztály</title>
                
<para>
Az osztály indítja az RMI szervert és <literal>TavoliLabirintus</literal> néven bejegyzi a távolról 
elérhető, a <classname>TávoliHősíthatő</classname> interfészt implementáló objektumot. Miközben a 
szokásos párhuzamos programszálon vezényli a labirintus mikrovilágának életét.
</para>
                
                
            <programlisting>
                <![CDATA[
/*
 * TávoliLabirintus.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * Java RMI-s hálózati, szerver oldali életre keltésére ad példát 
 * ez az osztály: a hősök távolról történő jelentkezését és 
 * mozgatását biztosítja.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusVilág
 * @see javattanitok.LabirintusApplet
 * @see javattanitok.LabirintusJáték
 * @see javattanitok.LabirintusMIDlet
 * @see javattanitok.LabirintusServlet
 * @see javattanitok.HálózatiLabirintus
 * @see javattanitok.KorbásLabirintus
 * @see javattanitok.ElosztottLabirintus
 * @see TávoliKliens
 * @see TávoliHősíthető
 */
public class TávoliLabirintus extends HálózatiLabirintus
        implements TávoliHősíthető {
    /**
     * A <code>TávoliLabirintus</code> objektum elkészítése.
     *
     * @param      labirintusFájlNév       a labirintust definiáló, megfelelő 
     * szerkezetű szöveges állomány neve.
     * @exception  RosszLabirintusKivétel  ha a labirintust definiáló állomány 
     * nem a megfelelő szerkezetű
     */
    public TávoliLabirintus(String labirintusFájlNév) throws 
            RosszLabirintusKivétel {
        // A labirintus elkészítése állományból
        labirintus = new TöbbHősösLabirintus(labirintusFájlNév);
        // A hős elkészítése és a kezdő pozíciójának beállítása
        hősök = new java.util.Hashtable();
        // A játékbeli idő folyását biztosító szál elkészítése és indítása
        new Thread(this).start();
        // Az RMI szerver indítása
        try {
            // A távoli objektum 
            TávoliHősíthető távoliHősíthető = (TávoliHősíthető)
            java.rmi.server.UnicastRemoteObject.exportObject(this, 0);
            // bejegyzése a névszolgáltatóba        
            java.rmi.registry.Registry registry =
                    java.rmi.registry.LocateRegistry.getRegistry();
            registry.bind("TavoliLabirintus", távoliHősíthető);
            
        } catch (java.rmi.AlreadyBoundException be) {
            be.printStackTrace();
            System.exit(-1);            
        } catch (java.rmi.RemoteException re) {
            re.printStackTrace();
            System.out.println("Fut az rmiregistry?");
            System.exit(-1);            
        }        
    }
    /**
     * Az RMI-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve. 
     * @return String a labirintus állapotát bemutató string. 
     */
    public String lépLe(String hősNév) throws java.rmi.RemoteException {
        Hős hős = null;
        try {
            // a hős neve (= "hoszt IP : név")
            hős = hős(java.rmi.server.RemoteServer.getClientHost() +
                    " : " + hősNév);
            
        } catch(java.rmi.server.ServerNotActiveException e) {
            e.printStackTrace();
        }        
        
        hős.lépLe();
        
        return labirintus.kinyomtat(hős);
    }
    /**
     * Az RMI-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve. 
     * @return String a labirintus állapotát bemutató string. 
     */
    public String lépFöl(String hősNév) throws java.rmi.RemoteException {
        Hős hős = null;
        try {
            
            hős = hős(java.rmi.server.RemoteServer.getClientHost() +
                    " : " + hősNév);
            
        } catch(java.rmi.server.ServerNotActiveException e) {
            e.printStackTrace();
        }        
        
        hős.lépFöl();
        
        return labirintus.kinyomtat(hős);
        
    }
    /**
     * Az RMI-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve. 
     * @return String a labirintus állapotát bemutató string. 
     */    
    public String lépJobbra(String hősNév) throws java.rmi.RemoteException {
        Hős hős = null;
        try {

            hős = hős(java.rmi.server.RemoteServer.getClientHost() +
                    " : " + hősNév);
            
        } catch(java.rmi.server.ServerNotActiveException e) {
            e.printStackTrace();
        }        
        
        hős.lépJobbra();
        
        return labirintus.kinyomtat(hős);
    }
    /**
     * Az RMI-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve. 
     * @return String a labirintus állapotát bemutató string. 
     */    
    public String lépBalra(String hősNév) throws java.rmi.RemoteException {
        Hős hős = null;
        try {

            hős = hős(java.rmi.server.RemoteServer.getClientHost() +
                    " : " + hősNév);
            
        } catch(java.rmi.server.ServerNotActiveException e) {
            e.printStackTrace();
        }   
        
        hős.lépBalra();
        
        return labirintus.kinyomtat(hős);        
    }    
    /**
     * Átveszi a játék indításához szükséges paramétereket, majd
     * elindítja a játék világának működését.
     *
     * @param args a labirintus tervét tartalmazó állomány neve az első 
     * parancssor-argumentum.
     */
    public static void main(String[] args) {
        
        if(args.length != 1) {
            
            System.out.println("Indítás: " +
                    "java javattanitok.TávoliLabirintus labirintus.txt");
            System.exit(-1);
            
        }
        
        try {
            
            new TávoliLabirintus(args[0]);
            
        } catch(RosszLabirintusKivétel rosszLabirintusKivétel) {
            
            System.out.println(rosszLabirintusKivétel);
            
        }
    }
}                
                ]]>
            </programlisting>
            </sect4>
            
            <sect4>
                <title>A TávoliHősíthető osztály</title>
                
<para>
Az interfész a távolról meghívható függvényeket deklarálja.
</para>                
                
            <programlisting>
                <![CDATA[
/*
 * TávoliHősíthető.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

/**
 * A labirintusba távolról történő jelentkezést biztosít a hősök számára.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see TávoliKliens
 * @see TávoliLabirintus
 */
public interface TávoliHősíthető extends java.rmi.Remote {
    /**
     * Az RMI-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve.
     */
    public String lépLe(String hősNév) throws java.rmi.RemoteException;
    /**
     * Az RMI-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve.
     */
    public String lépFöl(String hősNév) throws java.rmi.RemoteException;
    /**
     * Az RMI-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve.
     */
    public String lépJobbra(String hősNév) throws java.rmi.RemoteException;
    /**
     * Az RMI-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve.
     */
    public String lépBalra(String hősNév) throws java.rmi.RemoteException;    
}               
                ]]>
            </programlisting>
            </sect4>

            <sect4>
                <title>A TávoliKliens osztály</title>
                
<para>
Az osztály a <literal>TavoliLabirintus</literal> név feloldásával megszerzi a távoli Java RMI objektum referenciáját
és (innen távolról) meghívja például a <function>lépJobbra()</function> módszerét. 
</para>                
                
            <programlisting>
                <![CDATA[
/*
 * TávoliKliens.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * Java RMI-s hálózati, kliens oldali életre keltésére ad példát 
 * ez az osztály: a hős távolról történő mozgatását biztosítja.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see TávoliLabirintus
 * @see TávoliHősíthető
 */
public class TávoliKliens {
    /**
     * Elindítja a távolról jelentkező hős klienst.
     *
     * @param args a hős neve.
     */
    public static void main(String[] args) {
        
        String hősNév = null;
        // ha nem adtuk meg a parancssor-argumentumot, 
        // akkor ez az alapértelmezés:
        if(args.length != 1)
            hősNév = "Matyi";
        else
            hősNév = args[0];
        // Megszerezzük a távoli labirintus (TávoliHősíthető) referenciáját
        try {
            java.rmi.registry.Registry registry =
                    java.rmi.registry.LocateRegistry.getRegistry();
            TávoliHősíthető távoliHősíthető = 
                    (TávoliHősíthető) registry.lookup("TavoliLabirintus");
            // és jobbra mozgatjuk a labirintusban a hősünket 
            System.out.println(távoliHősíthető.lépJobbra(hősNév));
            
        } catch (java.rmi.NotBoundException be) {
            be.printStackTrace();
        } catch (java.rmi.RemoteException re) {
            re.printStackTrace();
        }
    }    
}               
                ]]>
            </programlisting>
            </sect4>
            
            
            <sect4>
                <title>A TávoliLabirintus fordítása és futtatása</title>

		   <para>
Egyelőre egy gépen futtatjuk a példát, így lefordítjuk a szervert és a klienst is.		   
           <screen>
                <![CDATA[


C:\...\Munkakönyvtár> javac javattanitok\TávoliLabirintus.java
C:\...\Munkakönyvtár> javac javattanitok\TávoliKliens.java
                ]]>
            </screen>     
		   </para>

		   <para>
Elindítjuk az RMI registry programot, ez a program szolgáltatja a szerveren távolról elérhető objetumok referenciáit.
A távoli objektum referenciájához a bejegyzett - esetünkben a  <literal>TavoliLabirintus</literal> - név szerint jutunk.
		   
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> start rmiregistry
                ]]>
            </screen>     
		   </para>

		   <para>
		   Majd futtatjuk a szervert és a klienst.
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.TávoliLabirintus labirintus.txt
Hősök száma: 0
Hősök száma: 0
Hősök száma: 0
...
                ]]>
            </screen>     
		   </para>

		   <para>
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.TávoliKliens
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |   |   |   |   |S  |   |   |
|FAL|   |FAL|   |FAL|   |FAL|K  |FAL|
|   |   |   |   |FAL|K  |FAL|   |   |
|   |FAL|FAL|   |   |K  |FAL|FAL|   |FAL
|   |   |   |   |FAL|   |   |   |S  |K
|   |FAL|   |S  |K  |FAL|   |FAL|FAL|
|   |   |   |FAL|   |FAL|   |FAL|   |
|   |FAL|   |   |   |   |   |   |   |FAL
|   |H  |   |   |FAL|   |   |   |FAL|FAL

C:\...\Munkakönyvtár> java javattanitok.TávoliKliens
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |   |   |   |S  |   |   |   |
|FAL|   |FAL|   |FAL|   |FAL|K  |FAL|
|   |   |   |   |FAL|K  |FAL|   |   |
|   |FAL|FAL|   |   |K  |FAL|FAL|   |FAL
|   |   |   |   |FAL|   |   |   |   |K
|   |FAL|   |S  |K  |FAL|S  |FAL|FAL|
|   |   |   |FAL|   |FAL|   |FAL|   |
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |H  |   |FAL|   |   |   |FAL|FAL

                ]]>
            </screen>     
		   </para>
   
   
		   <para>
		   Másoljuk át egy Linuxos gépre a példát és a <filename>TávoliKliens.java</filename>
		   forrást módosítsuk, hogy ne a localhost-hoz akarjon kapcsolódni, hanem a távoli, a
		   <hardware>kalapacs</hardware> nevű, természetesen a szervert futtató gépen keresse
		   az <command>rmiregistry</command> programot:
		   
            <programlisting>
                <![CDATA[
           java.rmi.registry.Registry registry =
                    java.rmi.registry.LocateRegistry.getRegistry("kalapacs");                
                ]]>
            </programlisting>
		   
		   
           <screen>
                <![CDATA[
[norbi@niobe Munkakönyvtár]$ javac javattanitok/TávoliKliens.java                
[norbi@niobe Munkakönyvtár]$ java javattanitok.TávoliKliens
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |   |   |   |   |   |   |   |
|FAL|   |FAL|   |FAL|   |FAL|K  |FAL|
|   |   |   |   |FAL|K  |FAL|   |   |
|   |FAL|FAL|   |   |SK |FAL|FAL|   |FAL
|   |   |   |   |FAL|   |   |   |   |K
|   |FAL|   |S  |K  |FAL|   |FAL|FAL|
|   |   |   |FAL|   |FAL|S  |FAL|   |
|   |FAL|   |   |   |   |   |   |   |FAL
|   |H  |   |   |FAL|   |   |   |FAL|FAL

[norbi@niobe Munkakönyvtár]$ java javattanitok.TávoliKliens
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |   |   |   |   |   |   |   |
|FAL|   |FAL|   |FAL|   |FAL|K  |FAL|
|   |   |   |   |FAL|K  |FAL|   |   |
|   |FAL|FAL|   |   |K  |FAL|FAL|   |FAL
|   |   |   |   |FAL|S  |   |   |   |K
|   |FAL|   |S  |K  |FAL|   |FAL|FAL|
|   |   |   |FAL|   |FAL|S  |FAL|   |
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |H  |   |FAL|   |   |   |FAL|FAL

                ]]>
            </screen>     
		   </para>
   
            
            </sect4>                
            
            </sect3>
            
            <sect3 id="labirintus_idl">
                <title>CORBA - Korbás Labirintus</title>
            
            <para>            
Az <emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>
            című pontban bevezetett esettanulmány végleges kódját adjuk meg itt.            
            </para>
        
             <sect4 id="corba_szerver">
                <title>A KorbásLabirintus osztály</title>

<para>
Az osztály elindítja a CORBA szervert: elkészíti a kiszolgáló CORBA objektumot, 
amit <literal>TavoliHos</literal>
néven a CORBA névszolgáltatóba is bejegyez. Miközben a szokásosan indított párhuzamos programszálban
vezérli a labirintus mikrovilágának életét.
</para>

<para>
A szerver CORBA specifikus logikáját külön is részletezzük. A CORBA világában a programok az ORB szoftveren,
az <emphasis>Object Request Broker</emphasis>, 
a metódushívások közvetítőjén keresztül tudnak kapcsolódni. A szerver első dolga
ezért - az esetünkben a localhost 2006-os kapujánál futó - ORB szerverrel felvenni a kapcsolatot.

            <programlisting>
                <![CDATA[
// Az ORB tulajdonságainak megadása
java.util.Properties orbTulajdonságok = new java.util.Properties();
orbTulajdonságok.put("org.omg.CORBA.ORBInitialHost", "localhost");
orbTulajdonságok.put("org.omg.CORBA.ORBInitialPort", "2006");
// Az ORB (a metódushívások közvetítőjének) inicializálása
org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init((String [])null,
                    orbTulajdonságok);                
                ]]>
            </programlisting>

</para>

<para>
A CORBA környezetben méginkább igaz, ami Javaban is igaz volt: minden objektum. S ez itt szinte minden 
programsorban következetesen tetten érhető. Mert például a szerver következő lépése egy objektum adapter
elérése. Az objektum adapterek éltetik a kiszolgáló CORBA objektumainkat, s itt jön a következetesség: ezek az 
adapterek maguk is
CORBA objektumok.  Az adapterek fába szervezhetők, attól függően, hogy milyen tulajdonságokkal akarjuk 
felruházni őket, most a gyökér POA-t használjuk.
            <programlisting>
                <![CDATA[
// A gyökér POA CORBA objektum referenciájának megszerzése
org.omg.CORBA.Object corbaObjektum =
                  orb.resolve_initial_references("RootPOA");                
                ]]>
            </programlisting>

</para>

<para>
Az ORB-től elkért objektumok általános <classname>org.omg.CORBA.Object</classname> osztálybeli objektumok,
amiket a CORBA világában honos típuskényszerítéssel a megfelelő típusúra kasztolunk a céltípus <classname>Helper</classname>
osztályának <function>narrow</function> módszerét használva:
            <programlisting>
                <![CDATA[
// CORBA-s típuskényszerítéssel a megfelelőre
org.omg.PortableServer.POA gyökérPoa =
     org.omg.PortableServer.POAHelper.narrow(corbaObjektum);                
                ]]>
            </programlisting>
            Majd a közben elkészített kiszolgáló CORBA 
            objektumunkat <literal>TavoliHos</literal> néven bejegyezzük a névszolgáltatóba.

</para>

<para>
A CORBA OO világ telefonkönyve a CORBA névszolgáltató. Ez a szolgáltatás is CORBA objektumként került megvalósításra.
A névszolgáltatás egy fa szerkezetbe van szervezve, ahol a gyökeret reprezentáló CORBA objektum referenciáját 
ugyanúgy szerezzük meg, mint az imént a POA adapterét.
            <programlisting>
                <![CDATA[
// A névszolgáltató gyökerének, mint CORBA objektum
// referenciájának megszerzése
corbaObjektum =
     orb.resolve_initial_references("NameService");
org.omg.CosNaming.NamingContextExt névszolgáltatóGyökere
     = org.omg.CosNaming.NamingContextExtHelper
                    .narrow(corbaObjektum);                
                ]]>
            </programlisting>

</para>

            <tip>
            <title>A CORBA névszolgáltatása</title>
                <para>
                Mint már említettük, CORBA-ban is minden objektum, maga a névszolgáltatás
                is. Ennek megfelelően a névszolgáltatást a megfelelő IDL nyelvű interfész
                megismerésén keresztül is tanulmányozhatja az érdeklődő Olvasó. Ezt a 
                <filename>cosnaming.idl</filename> állományban találjuk meg a 
                    <ulink url="http://www.omg.org/docs/formal/04-10-07.txt">http://www.omg.org/docs/formal/04-10-07.txt</ulink> címen.
                </para>            
            </tip>

				<programlisting>
					<![CDATA[
/*
 * KorbásLabirintus.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * CORBA-s, szerver oldali életre keltésére ad példát ez az osztály:
 * a hősök távolról történő jelentkezését és mozgatását biztosítja.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusVilág
 * @see javattanitok.LabirintusApplet
 * @see javattanitok.LabirintusJáték
 * @see javattanitok.LabirintusMIDlet
 * @see javattanitok.LabirintusServlet
 * @see javattanitok.HálózatiLabirintus
 * @see javattanitok.TávoliLabirintus
 * @see javattanitok.ElosztottLabirintus
 * @see TávoliHősKiszolgáló
 * @see KorbásKliens
 * @see tavolihos.idl
 */
public class KorbásLabirintus extends HálózatiLabirintus {
    /**
     * A <code>TávoliLabirintus</code> objektum elkészítése.
     *
     * @param      labirintusFájlNév       a labirintust definiáló, megfelelő
     * szerkezetű szöveges állomány neve.
     * @exception  RosszLabirintusKivétel  ha a labirintust definiáló állomány nem
     * a megfelelő szerkezetű
     */
    public KorbásLabirintus(String labirintusFájlNév) throws
            RosszLabirintusKivétel {
        // A labirintus elkészítése állományból
        labirintus = new TöbbHősösLabirintus(labirintusFájlNév);
        // A hősöket tartalmazó adatszerkezet elkészítése
        hősök = new java.util.Hashtable();
        // A játék valóságának (világának) indítása:
        new Thread(this).start();
        // A CORBA szerver indítása
        try{
            // Az ORB tulajdonságainak megadása
            java.util.Properties orbTulajdonságok = new java.util.Properties();
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialHost", "localhost");
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialPort", "2006");
            // Az ORB (a metódushívások közvetítőjének) inicializálása
            org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init((String [])null,
                    orbTulajdonságok);
            // A gyökér POA CORBA objektum referenciájának megszerzése
            org.omg.CORBA.Object corbaObjektum =
                    orb.resolve_initial_references("RootPOA");
            // CORBA-s típuskényszerítéssel a megfelelőre
            org.omg.PortableServer.POA gyökérPoa =
                    org.omg.PortableServer.POAHelper.narrow(corbaObjektum);
            // A POA kiszolgáló állapotba kapcsolása:
            gyökérPoa.the_POAManager().activate();
            // A kiszolgáló objektum létrehozása
            TávoliHősKiszolgáló távoliHősKiszolgáló =
                    new TávoliHősKiszolgáló(this);
            // CORBA objektum referencia elkészítése
            corbaObjektum =
                    gyökérPoa.servant_to_reference(távoliHősKiszolgáló);
            // CORBA-s típuskényszerítéssel a megfelelőre
            javattanitok.korbas.TavoliHos távoliHős =
                    javattanitok.korbas.TavoliHosHelper.narrow(corbaObjektum);
            // A névszolgáltató gyökerének, mint CORBA objektum
            // referenciájának megszerzése
            corbaObjektum =
                    orb.resolve_initial_references("NameService");
            org.omg.CosNaming.NamingContextExt névszolgáltatóGyökere
                    = org.omg.CosNaming.NamingContextExtHelper
                    .narrow(corbaObjektum);
            // A kiszolgáló objektum bejegyzése a névszolgáltatóba
            org.omg.CosNaming.NameComponent név[] =
                    névszolgáltatóGyökere.to_name("TavoliHos");
            névszolgáltatóGyökere.rebind(név, távoliHős);
            // Várakozás a játékosok jelentkezésére
            orb.run();
        } catch (Exception e) {
            
            e.printStackTrace();
            System.exit(-1);
            
        }        
    }
    /**
     * Átveszi a játék indításához szükséges paramétereket, majd
     * elindítja a játék világának működését.
     *
     * @param args a labirintus tervét tartalmazó állomány neve az első 
     * parancssor-argumentum.
     */
    public static void main(String[] args) {
        
        if(args.length != 1) {
            
            System.out.println("Indítás: " +
                    "java javattanitok.KorbásLabirintus labirintus.txt");
            System.exit(-1);
            
        }
        
        try {
            
            new KorbásLabirintus(args[0]);
            
        } catch(RosszLabirintusKivétel rosszLabirintusKivétel) {            
            System.out.println(rosszLabirintusKivétel);            
        }
    }
}					
					]]>
				</programlisting>

				</sect4>
            
             <sect4>
                <title>A KorbásKliens osztály</title>

<para>
A kliens a szerverhez hasonlóan felveszi a kapcsolatot az ORB szoftverrel, majd azon keresztül megszerzi a névszolgáltató
objektum referenciáját, akitől elkéri a <literal>TavoliHos</literal> névhez bejegyzett kiszolgáló CORBA objetumunk referenciáját, akitől
a hős jobbra léptetését kéri.
</para>

				<programlisting>
					<![CDATA[
/*
 * KorbásKliens.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * CORBA-s hálózati, kliens oldali életre keltésére ad példát ez az osztály:
 * a hős távolról történő mozgatását biztosítja.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see KorbásLabirintus
 * @see TávoliHősKiszolgáló
 */
public class KorbásKliens {
    /**
     * Elindítja a távolról jelentkező hős klienst.
     *
     * @param args a hős neve.
     */
    public static void main(String[] args) {
        
        String hősNév = null;
        // ha nem adtuk meg a parancssor-argumentumot, 
        // akkor ez az alapértelmezés:
        if(args.length != 1)
            hősNév = "Matyi";
        else
            hősNév = args[0];
        
        try {
            // Az ORB tulajdonságainak megadása
            java.util.Properties orbTulajdonságok = new java.util.Properties();
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialHost", "localhost");
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialPort", "2006");
            // Az ORB (a metódushívások közvetítőjének) inicializálása
            org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init((String [])null, 
                    orbTulajdonságok);
            // A névszolgáltató gyökerének, mint CORBA objektum
            // referenciájának megszerzése
            org.omg.CORBA.Object corbaObjektum =
                    orb.resolve_initial_references("NameService");
            org.omg.CosNaming.NamingContextExt névszolgáltatóGyökere
                    = org.omg.CosNaming.
                    NamingContextExtHelper.narrow(corbaObjektum);
            // A TavoliHos szolgáltatást nyújtó CORBA objektum
            // referenciájának megszerzése
            javattanitok.korbas.TavoliHos távoliHős =
                    javattanitok.korbas.TavoliHosHelper.narrow(
                    névszolgáltatóGyökere.resolve_str("TavoliHos"));
            
            System.out.println(távoliHős.lépJobbra(hősNév));
            
        } catch (Exception e) {            
            e.printStackTrace();            
        }        
    }    
}					
					]]>
				</programlisting>

				</sect4>

             <sect4>
                <title>A TavoliHos interfész</title>

<para>
A kiszolgáló CORBA objektum távolról is elérhető módszereit egy IDL nyelvű interfészben deklaráljuk,
az alábbi <filename>tavolihos.idl</filename> állományban.
</para>

				<programlisting>
					<![CDATA[
module javattanitok
{
    module korbas
    {
        interface TavoliHos
        {
            string lépLe(in string hosNev);
            string lépFöl(in string hosNev);
            string lépJobbra(in string hosNev);
            string lépBalra(in string hosNev);
        };
    };
};					
					]]>
				</programlisting>
<para>
Az egymásba ágyazott két IDL modul a <classname>javattanitok.korbas</classname> Java csomagra képeződik majd le. 
Az <command>idlj</command> fordító majd az ennek megfelelő <filename class="directory">javattanitok/korbas</filename> könyvtárba generálja le a
CORBA specifikus Java forrásokat.
</para>
				</sect4>

             <sect4>
                <title>A TávoliHősKiszolgáló osztály</title>

<para>
Ebben az osztályban kell megadnunk az IDL interfészben deklarált módszerek implementációját. A kiszolgáló objektum
megvalósítására több lehetőség adódik, most azt választjuk, hogy az osztályt az interfésznek megfelelő POA osztályból,
esetünkben a <classname>TavoliHosPOA</classname> osztályból származtatjuk.
</para>


				<programlisting>
					<![CDATA[
/*
 * TávoliHősKiszolgáló.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.labirintus.*;
/**
 * A <code>tavolihos.idl</code> leírta TávoliHős CORBA
 * kiszolgáló objektum megvalósítása.
 *
 * A <code>tavolihos.idl</code> interfész:
 * <pre>
 * module javattanitok
 * {
 *   module korbas
 *   {
 *   interface TavoliHos
 *     {
 *       string lépLe(in string hosNev);
 *       string lépFöl(in string hosNev);
 *       string lépJobbra(in string hosNev);
 *       string lépBalra(in string hosNev);
 *     };
 *   };
 * };
 * </pre>
 * A <code>javattanitok.korbas.*</code> csomag legenerálása:
 * <pre>
 * idlj -fall tavolihos.idl
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see KorbásLabirintus
 * @see KorbásKliens
 */
public class TávoliHősKiszolgáló
        extends javattanitok.korbas.TavoliHosPOA {
    /** A labirintus játékot futtató osztály. */
    KorbásLabirintus korbásLabirintus;
    /**
     * A <code>TávoliHősKiszolgáló</code> objektum elkészítése.
     *
     * @param      korbásLabirintus       A labirintus játékot futtató osztály.
     */
    public TávoliHősKiszolgáló(KorbásLabirintus korbásLabirintus) {
        
        this.korbásLabirintus = korbásLabirintus;
        
    }    
    /**
     * Az ORB-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve.
     * @return String a labirintus állapotát bemutató string. 
     */
    public String lépLe(String hősNév) {
        Hős hős = null;
        
        hős = korbásLabirintus.hős(hősNév);
        
        hős.lépLe();
        
        return korbásLabirintus.labirintus().kinyomtat(hős);
    }
    /**
     * Az ORB-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve.
     * @return String a labirintus állapotát bemutató string. 
     */
    public String lépFöl(String hősNév) {
        Hős hős = null;
        hős = korbásLabirintus.hős(hősNév);
        
        hős.lépFöl();
        
        return korbásLabirintus.labirintus().kinyomtat(hős);
        
    }
    /**
     * Az ORB-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve.
     * @return String a labirintus állapotát bemutató string. 
     */
    public String lépJobbra(String hősNév) {
        Hős hős = null;
        hős = korbásLabirintus.hős(hősNév);
        
        hős.lépJobbra();
        
        return korbásLabirintus.labirintus().kinyomtat(hős);
    }
    /**
     * Az ORB-n keresztül jelenetkező hős lépése.
     *
     * @param hősNév a hős neve.
     * @return String a labirintus állapotát bemutató string. 
     */
    public String lépBalra(String hősNév) {
        Hős hős = null;
        hős = korbásLabirintus.hős(hősNév);
        hős.lépBalra();
        
        return korbásLabirintus.labirintus().kinyomtat(hős);
    }
}					
					]]>
				</programlisting>

				</sect4>

             <sect4>
                <title>A KorbásLabirintus fordítása és futtatása</title>

		   <para>
Az <command>idlj</command> fordító használatát a 
<emphasis><link linkend="corba_oo">Objektumok mindenütt: a CORBA OO világ</link></emphasis> című pontban vezettük be.
		   
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> idlj -fall tavolihos.idl
                ]]>
            </screen> 
A <filename>tavolihos.idl</filename> modul szerkezetének megfelelően a kliens és a szerveroldali 
CORBA specifikus Java források megjelentek a 
<filename class="directory">javattanitok/korbas</filename> könyvtárban. 
Lefordítjuk a szervert                
			</para>

		   <para>
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> javac javattanitok\KorbásLabirintus.java
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.                
                ]]>
            </screen>     
			</para>

		   <para>és a kliens oldalt
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> javac javattanitok\KorbásKliens.java
                ]]>
            </screen>     
			</para>

		   <para>Indítjuk az ORB szoftvert:
           <screen>
                <![CDATA[
C:\Documents and Settings\norbi> start orbd -ORBInitialPort 2006 
                ]]>
            </screen>     
			</para>

		   <para>Majd a szerveroldalt:
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.KorbásLabirintus labirintus.txt
Hősök száma: 0
Hősök száma: 0
Hősök száma: 0
...
                ]]>
            </screen>     
			</para>

		   <para>és a kliens oldalt:
           <screen>
                <![CDATA[ 
C:\...\Munkakönyvtár> java javattanitok.KorbásKliens
|   |   |K  |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |   |S  |   |   |   |S  |   |
|FAL|   |FAL|   |FAL|K  |FAL|   |FAL|K
|   |   |   |   |FAL|   |FAL|   |   |
|   |FAL|FAL|   |   |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|   |   |   |   |
|   |FAL|K  |   |   |FAL|   |FAL|FAL|
|   |   |SK |FAL|   |FAL|   |FAL|   |K
|   |FAL|   |   |   |   |   |   |   |FAL
|   |H  |   |   |FAL|   |   |   |FAL|FAL              
C:\...\Munkakönyvtár> java javattanitok.KorbásKliens
|   |   |K  |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |   |   |   |   |   |   |   |
|FAL|   |FAL|   |FAL|K  |FAL|   |FAL|K
|   |   |   |   |FAL|   |FAL|S  |   |
|   |FAL|FAL|   |   |   |FAL|FAL|   |FAL
|   |   |   |   |FAL|   |   |   |   |
|   |FAL|K  |S  |   |FAL|   |FAL|FAL|
|   |   |K  |FAL|   |FAL|   |FAL|   |K
|   |FAL|S  |   |   |   |   |   |   |FAL
|   |   |H  |   |FAL|   |   |   |FAL|FAL

                ]]>
            </screen>     
			</para>
<para>
Izgalmasabb a tesztelés, ha a klienst átmásoljuk egy másik gépre, s az alábbi módosítás
</para>
            <programlisting>
                <![CDATA[
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialHost", "kalapacs");                
                ]]>
            </programlisting>
<para>
majd fordítás után futtatjuk ezen a másik gépen, a niobén:
</para>

		   <para>
           <screen>
                <![CDATA[
[norbi@niobe Munkakönyvtár]$ java javattanitok.KorbásKliens Herkules
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |K  |   |K  |   |   |   |   |
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|
|   |   |   |   |FAL|K  |FAL|   |   |
|   |FAL|FAL|   |   |   |FAL|FAL|S  |FAL
|   |   |   |K  |FAL|K  |   |   |   |
|   |FAL|   |   |   |FAL|   |FAL|FAL|S
|   |   |K  |FAL|   |FAL|   |FAL|S  |
|   |FAL|   |   |   |   |   |   |   |FAL
|   |H  |   |   |FAL|   |   |   |FAL|FAL

[norbi@niobe Munkakönyvtár]$ java javattanitok.KorbásKliens Herkules
|   |   |   |FAL|   |FAL|   |FAL|FAL|FAL
|   |   |K  |   |K  |   |   |   |   |
|FAL|   |FAL|   |FAL|   |FAL|   |FAL|
|   |   |   |   |FAL|K  |FAL|   |   |
|   |FAL|FAL|   |   |   |FAL|FAL|S  |FAL
|   |   |   |K  |FAL|K  |   |   |   |
|   |FAL|   |   |   |FAL|   |FAL|FAL|S
|   |   |K  |FAL|   |FAL|   |FAL|S  |
|   |FAL|   |   |   |   |   |   |   |FAL
|   |   |H  |   |FAL|   |   |   |FAL|FAL
                ]]>
            </screen>     
			</para>


			</sect4>                
			
            </sect3>

        </sect2>
        
        <sect2 id="elosztott_labirintus">
            <title>Elosztott objektumok - Elosztott labirintus</title>
            
            <para>            
Az <emphasis><link linkend="pelda_bemutatas">Előzetes a példaprogramokból</link></emphasis>
            című pontban bevezetett esettanulmány végleges kódját adjuk meg itt.            
            </para>
            
		<sect3>
			<title>Az elosztott labirintus API felélesztése</title>

                <para>
					Feltesszük, hogy a korábbi esettanulmányok alapján a labirintus
					API-t már felélesztettük, sőt a hálózati példáknál kifejlesztett
					<classname>TöbbHősösLabirintus</classname>
					osztállyal is bővítettük már ezt az API-t. Az alábbiakban az
					elosztott labirintus API-t állítjuk be.
                </para>

                <para>					 
                    Tetszőleges munkakönyvtárunkban hozzuk létre - a labirintus
                    API rendelkezésre állása miatt már létező -  
                    <filename class="directory">javattanitok</filename> könyvtáron belül az
                    <filename>elosztott</filename> könyvtárat. 
                    
                <screen>
                    <![CDATA[
C:\...\Munkakönyvtár> mkdir javattanitok\elosztott
                    ]]>
                </screen>     
                    
                    Ezzel a <classname>javattanitok.elosztott</classname> Java
                    csomagot leképeztük a munkakönyvtárunkba, a kifejlesztendő
                    osztályokat ide, a <filename class="directory">javattanitok/elosztott</filename> 
                    könyvtárban írjuk majd meg, azaz gyűjtük most össze. Másoljuk
                    ide a következő 
                    <filename>SzereplőKiszolgáló.java</filename>,
                    <filename>HősKiszolgáló.java</filename>,
                    <filename>KincsKiszolgáló.java</filename>,                    
                    <filename>SzörnyKiszolgáló.java</filename>,
                    <filename>LabirintusKiszolgáló.java</filename>
                    állományokat! A következő pontokban ismertetjük ezeknek - 
                    az <filename>elosztott.idl</filename> interfészben deklarált CORBA objektumoknak 
                    - az implementációit.

                </para>
                
             <sect4>
                <title>A SzereplőKiszolgáló osztály</title>
                
				<para>
A kiszolgáló objektumokban implementálnunk kell az <filename>elosztott.idl</filename> interfészben specifikált
metódusokat, illetve lekérdező és beállító módszereket kell írnunk a szereplő attribútumokhoz.	
A <classname>Szereplo</classname> IDL interfésznek nincsenek módszerei, így csupán az
<varname>oszlop</varname>, <varname>sor</varname> attribútumaihoz kell egy-egy, a
tulajdonságokkal megegyező nevű beállító és 
lekérdező függvényt implementálnunk az interfészt kiszolgáló CORBA objektum,
a <classname>SzereplőKiszolgáló</classname> osztály testében.			
				</para>
                
				<programlisting>
					<![CDATA[
/*
 * SzereplőKiszolgáló.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.elosztott;
/**
 * Az <code>elosztott.idl</code> leírta Szereplő CORBA objektumot
 * kiszolgáló objektum megvalósítása.
 *
 * Az <code>elosztott.idl</code> interfész:
 * <pre>
 * module javattanitok
 * {
 *   module elosztott
 *   {
 *     module objektumok
 *     {
 *       interface Szereplo
 *       {
 *         attribute long oszlop;
 *         attribute long sor;
 *       };
 *       interface Kincs;
 *       interface Hos : Szereplo
 *       {
 *         attribute long megtalaltErtekek;
 *         readonly attribute long eletek;
 *         void megtalaltam(in Kincs kincs);
 *         boolean megettek();
 *       };
 *       interface Kincs : Szereplo
 *       {
 *         attribute long ertek;
 *         readonly attribute boolean megtalalva;
 *         boolean megtalalt(in Hos hos);
 *       };
 *       interface Szorny : Szereplo
 *       {
 *         boolean lep(in Hos hos);
 *       };
 *       interface Labirintus
 *       {
 *         wstring belepHos(in Hos hos);
 *         wstring belepKincs(in Kincs kincs);
 *         wstring belepSzorny(in Szorny szorny);
 *       };
 *     };
 *   };
 * };
 * </pre>
 * A <code>javattanitok.elosztott.objektumok.*</code> csomag legenerálása:
 * <pre>
 * idlj -fall -falltie elosztott.idl
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see ElosztottLabirintus
 * @see ElosztottKliens
 * @see LabirintusKiszolgáló
 * @see HősKiszolgáló
 * @see SzörnyKiszolgáló
 * @see KincsKiszolgáló
 */
public class SzereplőKiszolgáló
        extends javattanitok.elosztott.objektumok.SzereploPOA {
    /** A szereplő oszlop pozíciója. */
    int oszlop;
    /** A szereplő sor pozíciója. */
    int sor;
    /** A <code>SzereplőKiszolgáló</code> objektum elkészítése. */
    public SzereplőKiszolgáló() {}
    /**
     * Beállítja a szereplő labirintusbeli pozíciójának oszlop
     * koordinátáját.
     *
     * @param oszlop a szereplő labirintusbeli pozíciójának oszlop
     * koordinátája.
     */
    public void oszlop(int oszlop) {
        
        this.oszlop = oszlop;
        
        System.out.println("SZEREPLŐ> Beállították a pozíciómat.");
    }
    /**
     * Megadja a szereplő labirintusbeli pozíciójának oszlop koordinátáját.
     *
     * @return int a szereplő labirintusbeli pozíciójának oszlop koordinátája.
     */
    public int oszlop() {
        
        System.out.println("SZEREPLŐ> Lekérdezték a pozíciómat.");
        
        return oszlop;
    }
    /**
     * Beállítja a szereplő labirintusbeli pozíciójának sor koordinátáját.
     *
     * @param sor a szereplő labirintusbeli pozíciójának sor koordinátája.
     */
    public void sor(int sor) {
        
        this.sor = sor;
        
    }
    /**
     * Megadja a szereplő labirintusbeli pozíciójának sor koordinátáját.
     *
     * @return int a szereplő labirintusbeli pozíciójának sor koordinátája.
     */
    public int sor() {
        
        return sor;
        
    }
}					
					]]>					
				</programlisting>
				
             </sect4>
             
             <sect4>
                <title>A HősKiszolgáló osztály</title>
                
				<para>
				Az osztályt a <classname>SzereplőKiszolgáló</classname> osztályból 
				szeretnénk származtatni, s mivel Javaban nincs többszörös öröklődés, így nem tudjuk
				a CORBA objektum implementációjánál a szokásos utunkat követni: a
				<classname>HosPOA</classname> <command>idlj</command> generálta osztályt kiterjeszteni. 
				Ezért a <classname>Hos</classname> IDL interfészt kiszolgáló CORBA objektum 
				elkészítésénél a tie delegációs modellt követjük: kiterjesztjük a 
				<classname>SzereplőKiszolgáló</classname>-t és implementáljuk a 
				 <classname>HosOperations</classname> <command>idlj</command> generálta, az 
				 IDL interfészben deklarált metódusok specifikációját tartalmazó
				 Java interfészt.
				</para>
                
				<programlisting>
					<![CDATA[
/*
 * HősKiszolgáló.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.elosztott;
// Itt vannak a CORBA objektumaink, bár nem szokásunk,
// most importálunk, mert a teljes csomagnévvel
// való osztálynév minősítést, a hossza miatt nehézkes
// lenne kezelni a könyv kapcsán a szövegszerkesztőnkben.
import javattanitok.elosztott.objektumok.*;
/**
 * Az <code>elosztott.idl</code> leírta Hős CORBA objektumot
 * kiszolgáló objektum megvalósítása.
 *
 * Az <code>elosztott.idl</code> interfész:
 * <pre>
 * module javattanitok
 * {
 *   module elosztott
 *   {
 *     module objektumok
 *     {
 *       interface Szereplo
 *       {
 *         attribute long oszlop;
 *         attribute long sor;
 *       };
 *       interface Kincs;
 *       interface Hos : Szereplo
 *       {
 *         attribute long megtalaltErtekek;
 *         readonly attribute long eletek;
 *         void megtalaltam(in Kincs kincs);
 *         boolean megettek();
 *       };
 *       interface Kincs : Szereplo
 *       {
 *         attribute long ertek;
 *         readonly attribute boolean megtalalva;
 *         boolean megtalalt(in Hos hos);
 *       };
 *       interface Szorny : Szereplo
 *       {
 *         boolean lep(in Hos hos);
 *       };
 *       interface Labirintus
 *       {
 *         wstring belepHos(in Hos hos);
 *         wstring belepKincs(in Kincs kincs);
 *         wstring belepSzorny(in Szorny szorny);
 *       };
 *     };
 *   };
 * };
 * </pre>
 * A <code>javattanitok.elosztott.objektumok.*</code> csomag legenerálása:
 * <pre>
 * idlj -fall -falltie elosztott.idl
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see ElosztottLabirintus
 * @see ElosztottKliens
 * @see LabirintusKiszolgáló
 * @see SzereplőKiszolgáló
 * @see HősKiszolgáló
 * @see SzörnyKiszolgáló
 * @see KincsKiszolgáló
 */
public class HősKiszolgáló
        extends SzereplőKiszolgáló
        implements HosOperations {
    
    /** A labirintusban megtalált kincsek értékei. */
    protected int megtaláltÉrtékek;
    /** A hős életeinek maximális száma. */
    public static final int ÉLETEK_SZÁMA = 5;
    /** A hős életeinek száma. */
    protected int életekSzáma = ÉLETEK_SZÁMA;
    /** A <code>HősKiszolgáló</code> objektum elkészítése. */
    public HősKiszolgáló() {}
    /**
     * Életek számának lekérdezése.
     *
     * @return int az életek száma.
     */
    public int eletek() {
        
        return életekSzáma;
    }
    /**
     * A megtalált értékek beállítása.
     *
     * @param megtaláltÉrtékek a megtalált értékek.
     */
    public void megtalaltErtekek(int megtaláltÉrtékek) {
        
        this.megtaláltÉrtékek = megtaláltÉrtékek;
    }
    /**
     * A megtalált értékek lekérdezése.
     *
     * @return int a megtalált értékek.
     */
    public int megtalaltErtekek() {
        
        return megtaláltÉrtékek;
    }
    /**
     * Jelzi, hogy éppen megettek.
     *
     * @return true ha a hősnek még van élete, ellenkező esetben,
     * azaz ha az összes élete elfogyott már, akkor false.
     */
    public boolean megettek() {
        
        if(életekSzáma > 0) {
            --életekSzáma;
            return false;
        } else
            return true;
        
    }
    /**
     * Gyüjtögeti a megtalált kincseket.
     *
     * @param kincs amit éppen magtalált a hős.
     */
    public void megtalaltam(Kincs kincs) {
        
        megtaláltÉrtékek += kincs.ertek();
        System.out.println("HŐS> Kincset találtam.");
        
    }
}					
					]]>					
				</programlisting>
				
             </sect4>

             <sect4>
                <title>A KincsKiszolgáló osztály</title>
                
				<para>
				Az osztály megvalósításánál a <classname>HősKiszolgáló</classname> osztálynál
				is alkalmazott módszert követjük.
				</para>
                
				<programlisting>
					<![CDATA[
/*
 * KincsKiszolgáló.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.elosztott;
/**
 * Az <code>elosztott.idl</code> leírta Kincs CORBA objektumot
 * kiszolgáló objektum megvalósítása.
 *
 * Az <code>elosztott.idl</code> interfész:
 * <pre>
 * module javattanitok
 * {
 *   module elosztott
 *   {
 *     module objektumok
 *     {
 *       interface Szereplo
 *       {
 *         attribute long oszlop;
 *         attribute long sor;
 *       };
 *       interface Kincs;
 *       interface Hos : Szereplo
 *       {
 *         attribute long megtalaltErtekek;
 *         readonly attribute long eletek;
 *         void megtalaltam(in Kincs kincs);
 *         boolean megettek();
 *       };
 *       interface Kincs : Szereplo
 *       {
 *         attribute long ertek;
 *         readonly attribute boolean megtalalva;
 *         boolean megtalalt(in Hos hos);
 *       };
 *       interface Szorny : Szereplo
 *       {
 *         boolean lep(in Hos hos);
 *       };
 *       interface Labirintus
 *       {
 *         wstring belepHos(in Hos hos);
 *         wstring belepKincs(in Kincs kincs);
 *         wstring belepSzorny(in Szorny szorny);
 *       };
 *     };
 *   };
 * };
 * </pre>
 * A <code>javattanitok.elosztott.objektumok.*</code> csomag legenerálása:
 * <pre>
 * idlj -fall -falltie elosztott.idl
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see ElosztottLabirintus
 * @see ElosztottKliens
 * @see LabirintusKiszolgáló
 * @see SzereplőKiszolgáló
 * @see HősKiszolgáló
 * @see SzörnyKiszolgáló
 */
public class KincsKiszolgáló
        extends SzereplőKiszolgáló
        implements javattanitok.elosztott.objektumok.KincsOperations {
    /** A kincs értéke. */
    protected int érték;
    /** Megtaláltak már? */
    protected boolean megtalálva;
    /** A <code>KincsKiszolgáló</code> objektum elkészítése. */
    public KincsKiszolgáló() {}
    /**
     * Az érték beállítása.
     *
     * @param érték az a kincs értéke.
     */
    public void ertek(int érték) {
        
        this.érték = érték;
    }
    /**
     * Az érték lekérdezése.
     *
     * @return int az érték.
     */
    public int ertek() {
        
        return érték;
    }
    /**
     * Megtalált ez a hős?
     *
     * @param hős aki rámbukkant éppen.
     * @return boolean megtalál?
     */
    public boolean megtalalt(javattanitok.elosztott.objektumok.Hos hős) {
        
        if(megtalálva) {
            System.out.println("KINCS> Már korábban rámtalált egy hős.");
            // mert egy kicset csak egyszer lehet megtalálni
            return false;
        }
        
        if(oszlop == hős.oszlop() && sor == hős.sor()) {
            
            megtalálva = true;
            System.out.println("KINCS> Rámtalált.");
            
        } else
            System.out.println("KINCS> Nem talált rám.");
        
        return megtalálva;
    }
    /**
     * Megmondja, hogy megtalálták-e már a kincset?
     *
     * @return true ha a kincset már megtalálták,
     * ha még nem akkor false.
     */
    public boolean megtalalva() {
        
        return megtalálva;
        
    }
}					
					]]>					
				</programlisting>
				
             </sect4>

             <sect4>
                <title>A SzörnyKiszolgáló osztály</title>
                
				<para>
				Az osztály megvalósításánál a <classname>HősKiszolgáló</classname> osztálynál
				is alkalmazott módszert követjük.
				</para>
                
				<programlisting>
					<![CDATA[
/*
 * SzörnyKiszolgáló.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.elosztott;
/**
 * Az <code>elosztott.idl</code> leírta Szörny CORBA objektumot
 * kiszolgáló objektum megvalósítása.
 *
 * Az <code>elosztott.idl</code> interfész:
 * <pre>
 * module javattanitok
 * {
 *   module elosztott
 *   {
 *     module objektumok
 *     {
 *       interface Szereplo
 *       {
 *         attribute long oszlop;
 *         attribute long sor;
 *       };
 *       interface Kincs;
 *       interface Hos : Szereplo
 *       {
 *         attribute long megtalaltErtekek;
 *         readonly attribute long eletek;
 *         void megtalaltam(in Kincs kincs);
 *         boolean megettek();
 *       };
 *       interface Kincs : Szereplo
 *       {
 *         attribute long ertek;
 *         readonly attribute boolean megtalalva;
 *         boolean megtalalt(in Hos hos);
 *       };
 *       interface Szorny : Szereplo
 *       {
 *         boolean lep(in Hos hos);
 *       };
 *       interface Labirintus
 *       {
 *         wstring belepHos(in Hos hos);
 *         wstring belepKincs(in Kincs kincs);
 *         wstring belepSzorny(in Szorny szorny);
 *       };
 *     };
 *   };
 * };
 * </pre>
 * A <code>javattanitok.elosztott.objektumok.*</code> csomag legenerálása:
 * <pre>
 * idlj -fall -falltie elosztott.idl
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see ElosztottLabirintus
 * @see ElosztottKliens
 * @see LabirintusKiszolgáló
 * @see SzereplőKiszolgáló
 * @see HősKiszolgáló
 * @see SzereplőKiszolgáló
 * @see KincsKiszolgáló
 */
public class SzörnyKiszolgáló
        extends SzereplőKiszolgáló
        implements javattanitok.elosztott.objektumok.SzornyOperations {
    /** A <code>SzörnyKiszolgáló</code> objektum elkészítése. */
    public SzörnyKiszolgáló() {}
    /**
     * Lépek a hős felé.
     *
     * @param hős aki felé mozgok.
     * @return boolean elkaptam ez a hőst?
     */
    public boolean lep(javattanitok.elosztott.objektumok.Hos hos) {
        // ... a hős felé lépést nem implementáltuk ebben a példában.
        System.out.println("SZÖRNY> Lépek egy hős felé.");
        // ... soha nem eszem meg ebben az implementációban.
        return false;
    }
}					
					]]>					
				</programlisting>
				
             </sect4>

             <sect4>
                <title>A LabirintusKiszolgáló osztály</title>
                
				<para>
				</para>
                
				<programlisting>
					<![CDATA[
/*
 * LabirintusKiszolgáló.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok.elosztott;

import java.util.List;
import java.util.Iterator;
// Itt vannak a CORBA objektumaink, bár nem szokásunk,
// most importálunk, mert a teljes csomagnévvel
// való osztálynév minősítést, a hossza miatt nehézkes
// lenne kezelni a könyv kapcsán a szövegszerkesztőnkben.
import javattanitok.elosztott.objektumok.*;
/**
 * Az <code>elosztott.idl</code> leírta Labirintus CORBA objektumot
 * kiszolgáló objektum megvalósítása.
 *
 * Az <code>elosztott.idl</code> interfész:
 * <pre>
 * module javattanitok
 * {
 *   module elosztott
 *   {
 *     module objektumok
 *     {
 *       interface Szereplo
 *       {
 *         attribute long oszlop;
 *         attribute long sor;
 *       };
 *       interface Kincs;
 *       interface Hos : Szereplo
 *       {
 *         attribute long megtalaltErtekek;
 *         readonly attribute long eletek;
 *         void megtalaltam(in Kincs kincs);
 *         boolean megettek();
 *       };
 *       interface Kincs : Szereplo
 *       {
 *         attribute long ertek;
 *         readonly attribute boolean megtalalva;
 *         boolean megtalalt(in Hos hos);
 *       };
 *       interface Szorny : Szereplo
 *       {
 *         boolean lep(in Hos hos);
 *       };
 *       interface Labirintus
 *       {
 *         wstring belepHos(in Hos hos);
 *         wstring belepKincs(in Kincs kincs);
 *         wstring belepSzorny(in Szorny szorny);
 *       };
 *     };
 *   };
 * };
 * </pre>
 * A <code>javattanitok.elosztott.objektumok.*</code> csomag legenerálása:
 * <pre>
 * idlj -fall -falltie elosztott.idl
 * </pre>
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see ElosztottLabirintus
 * @see ElosztottKliens
 * @see SzereplőKiszolgáló
 * @see HősKiszolgáló
 * @see SzörnyKiszolgáló
 * @see KincsKiszolgáló
 */
public class LabirintusKiszolgáló
        extends javattanitok.labirintus.TöbbHősösLabirintus
        implements LabirintusOperations, Runnable {
    /** A labirintus szörnyei, elemei távoli CORBA objektumok. */
    protected List<Szorny> szörnyek;
    /** A labirintus kincsei, elemei távoli CORBA objektumok. */
    protected List<Kincs> kincsek;
    /** A labirintus hősei, elemei távoli CORBA objektumok. */
    protected List<Hos> hősök;
    /** A játékbeli idő mérésére.*/
    private long idő = 0;
    /** Véletlenszám generátor a szereplők mozgatásához. */
    protected static java.util.Random véletlenGenerátor =
            new java.util.Random();
    /** A <code>LabirintusKiszolgáló</code> objektum elkészítése. */
    public LabirintusKiszolgáló() {
        // Az ős megfelelő konstruktorának hívása
        super();
        // A kincseket tartalmazó adatszerkezet létrehozása,
        // elemei majd távoli CORBA objektumok lesznek
        kincsek = new java.util.ArrayList<Kincs>();
        // A kincseket tartalmazó adatszerkezet létrehozása,
        // elemei majd távoli CORBA objektumok lesznek
        szörnyek = new java.util.ArrayList<Szorny>();
        // A kincseket tartalmazó adatszerkezet létrehozása,
        // elemei majd távoli CORBA objektumok lesznek
        hősök = java.util.Collections.synchronizedList(
                new java.util.ArrayList<Hos>());
        
        // A játékbeli idő folyását biztosító szál elkészítése és indítása
        new Thread(this).start();
    }
    /**
     * A Hos CORBA objektum az ORB-n keresztül belép a labirintusba.
     *
     * @param hős a Hos CORBA objektum referenciája.
     * @return String a labirintus állapotát bemutató string.
     */
    public String belepHos(Hos hős) {
        System.out.println("LABIRINTUS> Belépett egy hős: " + hős);
        hősök.add(hős);
        szereplőHelyeKezdetben(hős);
        
        return toString();
        
    }
    /**
     * A Kincs CORBA objektum az ORB-n keresztül belép a labirintusba.
     *
     * @param hős a Kincs CORBA objektum referenciája.
     * @return String a labirintus állapotát bemutató string.
     */
    public String belepKincs(Kincs kincs) {
        
        System.out.println("LABIRINTUS> Belépett egy kincs.");
        kincsek.add(kincs);
        szereplőHelyeKezdetben(kincs);
        
        return toString();
        
    }
    /**
     * A Szorny CORBA objektum az ORB-n keresztül belép a labirintusba.
     *
     * @param hős a Szorny CORBA objektum referenciája.
     * @return String a labirintus állapotát bemutató string.
     */
    public String belepSzorny(Szorny szörny) {
        
        System.out.println("LABIRINTUS> Belépett egy szörny.");
        szörnyek.add(szörny);
        szereplőHelyeKezdetben(szörny);
        
        return toString();
        
    }
    /**
     * A szereplő labirintusbeli kezdő pozíciójának meghatározása.
     */
    void szereplőHelyeKezdetben(Szereplo szereplő) {
        // Többször próbálkozunk elhelyezni a szereplőt a labirintusban,
        // számolja, hol tartunk ezekkel a próbálkozásokkal:
        int számláló = 0, oszlop = 0, sor = 0;
        do {
            // itt +2,-2-k, hogy a bal alsó saroktól távol tartsuk
            // a szereplőket, mert majd ezt akarjuk a hős kezdő pozíciójának
            oszlop = 2+véletlenGenerátor.nextInt(szélesség-2);
            sor = véletlenGenerátor.nextInt(magasság-2);
            // max. 10-szer próbálkozunk, de ha sikerül nem "falba tenni" a
            // szereplőt, akkor máris kilépünk:
        } while(++számláló<10 && fal(oszlop, sor));
        
        szereplő.oszlop(oszlop);
        szereplő.sor(sor);
        
    }
    /** A játék időbeli fejlődésének vezérlése. */
    public void run() {
        
        while(true) {
            
            idoegyseg();
            
            System.out.println(this);
            
            synchronized(hősök) {
                Iterator i = hősök.iterator();
                
                while(i.hasNext()) {
                    Hos hős = (Hos)i.next();
                    try {
                        switch(bolyong(hős)) {
                            
                            case JÁTÉK_MEGY_HŐS_RENDBEN:
                                break;
                            case JÁTÉK_MEGY_MEGHALT_HŐS:
                                break;
                            case JÁTÉK_VÉGE_MEGHALT_HŐS:
                                i.remove();
                                break;
                                
                        }
                        
                    } catch (org.omg.CORBA.SystemException e) {
                        
                        i.remove();
                        System.out.println("LABIRINTUS> " +
                                "Egy hőst eltávolítottam.");
                        
                    }
                }
            }
        }
    }
    /**
     * Az ős megfelelő metódusának elfedése, az új CORBA szereplőket
     * használva.
     *
     * @see TöbbHősösLabirintus#bolyong(Hős hős)
     * @param hős aki a labirintusban bolyong.
     * @return int a játék állapotát leíró kód.
     */
    public int bolyong(Hos hős) {
        
        for(Kincs kincs : kincsek) {
            
            if(kincs.megtalalt(hős))
                hős.megtalaltam(kincs);
            
        }
        
        for(Szorny szörny : szörnyek) {
            
            if(szörny.lep(hős))  {
                
                if(hős.megettek())
                    return JÁTÉK_VÉGE_MEGHALT_HŐS;
                else
                    return JÁTÉK_MEGY_MEGHALT_HŐS;
            }
            
        }
        
        return JÁTÉK_MEGY_HŐS_RENDBEN;
    }
    /**
     * Megadja, hogy milyen gyorsan telik az idő a játékban.
     */
    private void idoegyseg() {
        
        ++idő;
        
        try {
            Thread.sleep(1000);
        } catch(InterruptedException e) {}
    }
    /**
     * Madadja, hogy van-e szörny a labirintus adott oszlop,
     * sor pozíciója.
     *
     * @param oszlop a labirintus adott oszlopa
     * @param sor a labirintus adott sora
     * @return true ha van.
     */
    boolean vanSzörny(int sor, int oszlop) {
        
        boolean van = false;
        
        for(Szorny szörny: szörnyek)
            if(sor == szörny.sor()
            && oszlop == szörny.oszlop()) {
            van = true;
            break;
            }
        
        return van;
    }
    /**
     * Madadja, hogy van-e megtalálható kincs a labirintus
     * adott oszlop, sor pozíciója.
     *
     * @param oszlop a labirintus adott oszlopa
     * @param sor a labirintus adott sora
     * @return true ha van.
     */
    boolean vanKincs(int sor, int oszlop) {
        
        boolean van = false;
        
        for(Kincs kincs: kincsek)
            if(sor == kincs.sor()
            && oszlop == kincs.oszlop()
            && !kincs.megtalalva()) {
            van = true;
            break;
            }
        
        return van;
    }
    /**
     * Kinyomtatja a labirintus szerkezetét és szereplőit a System.out-ra.
     *
     * @param hős akit szintén belenyomtat a labirintusba.
     */
    public void nyomtat(Hos hős) {
        
        for(int i=0; i<magasság; ++i) {
            for(int j=0; j<szélesség; ++j) {
                
                boolean vanSzörny = vanSzörny(i, j);
                boolean vanKincs = vanKincs(i, j);
                boolean vanHős = (i == hős.sor() && j == hős.oszlop());
                
                if(szerkezet[i][j])
                    System.out.print("|FAL");
                else if(vanSzörny && vanKincs && vanHős)
                    System.out.print("|SKH");
                else if(vanSzörny && vanKincs)
                    System.out.print("|SK ");
                else if(vanKincs && vanHős)
                    System.out.print("|KH ");
                else if(vanSzörny && vanHős)
                    System.out.print("|SH ");
                else if(vanKincs)
                    System.out.print("|K  ");
                else if(vanHős)
                    System.out.print("|H  ");
                else if(vanSzörny)
                    System.out.print("|S  ");
                else
                    System.out.print("|   ");
                
            }            
            System.out.println();            
        }
    }
    /**
     * A labirintus sztring reprezentációja.
     *
     * @return String labirintus sztring reprezentációja.
     */
    public String toString() {
        
        return " Idő:" + idő
                + " hős:" + hősök.size()
                + " kincs:" + kincsek.size()
                + " szörny:" + szörnyek.size();        
    }
}					
					]]>					
				</programlisting>
				
             </sect4>

             <sect4>
                <title>A CORBA interfész definíciók</title>
                
			 <para>
			 Az előző pontokban ismertetett öt Java osztály 
			 a <filename>elosztott.idl</filename> interfész definíciós
			 állományban leírt öt CORBA objektum kiszolgálói. A valóságban persze
			 ezzel kezdődik a tervezés. A játék OO világát ezekkel az IDL nyelvű
			 interfészekkel feszítjük ki. Ezt követheti az implementációs nyelv
			 kiválasztása, ami esetünkben a Java, majd az ennek a választásnak megfelelő
			 fordítót, esetünkben a JDK-beli idlj fordítót használva a CORBA kommunikációhoz
			 szükséges Java források legenerálása és a saját kiszolgáló objektumok megírása.
			 Ez királyi út, csupán az implementálandó szolgáltatások megvalósítására
			 kell figyelnünk.
			 </para>

			 <programlisting>
					<![CDATA[
module javattanitok
{
    module elosztott
    {
        module objektumok
        {        
            interface Szereplo
            {
                attribute long oszlop;
                attribute long sor;
            };
            interface Kincs;
            interface Hos : Szereplo
            {
                attribute long megtalaltErtekek;
                readonly attribute long eletek;
                void megtalaltam(in Kincs kincs);
                boolean megettek();
            };
            interface Kincs : Szereplo
            {
                attribute long ertek;
                readonly attribute boolean megtalalva;
                boolean megtalalt(in Hos hos);
            };
            interface Szorny : Szereplo
            {
                boolean lep(in Hos hos);
            };
            interface Labirintus
            {            
                wstring belepHos(in Hos hos);
                wstring belepKincs(in Kincs kincs);
                wstring belepSzorny(in Szorny szorny);
            };    
        };    
    };
};					
					]]>					
			 </programlisting>

 			 </sect4>
			
             <sect4>
                <title>Az ElosztottLabirintus osztály</title>
                
				<para>
				Ez az osztály tölti be leginkább a szerver szerepét, mert ő
				élteti a labirintust kiszolgáló objektumot.				
				</para>
                
				<programlisting>
					<![CDATA[
/*
 * ElosztottLabirintus.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.elosztott.*;
/**
 * Az elosztott CORBA-s labirintus csomag absztrahálta elosztott labirintus
 * mikrovilágának egy szerver oldali (delegációs POA/Tie leképezéses) életre
 * keltésére ad példát ez az osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusVilág
 * @see javattanitok.LabirintusApplet
 * @see javattanitok.LabirintusJáték
 * @see javattanitok.LabirintusMIDlet
 * @see javattanitok.LabirintusServlet
 * @see javattanitok.HálózatiLabirintus
 * @see javattanitok.TávoliLabirintus
 * @see ElosztottKliens
 * @see LabirintusKiszolgáló
 * @see elosztott.idl
 */
public class ElosztottLabirintus {
    /** A <code>ElosztottLabirintus</code> objektum elkészítése. */
    public ElosztottLabirintus() {
        // A CORBA szerver indítása
        try{
            // Az ORB tulajdonságainak megadása
            java.util.Properties orbTulajdonságok =
                    new java.util.Properties();
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialPort", "2006");
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialHost", "localhost");
            // Az ORB (a metódushívások közvetítőjének) inicializálása
            org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init((String [])null,
                    orbTulajdonságok);
            // A gyökér POA CORBA objektum referenciájának megszerzése
            org.omg.CORBA.Object corbaObjektum = orb.
                    resolve_initial_references("RootPOA");
            // CORBA-s típuskényszerítéssel a megfelelőre
            org.omg.PortableServer.POA gyökérPoa =
                    org.omg.PortableServer.POAHelper.narrow(corbaObjektum);
            // A POA kiszolgáló állapotba kapcsolása:
            gyökérPoa.the_POAManager().activate();
            // A Labirintus kiszolgáló objektum elkészítése,
            // a delegációs/POA/Tie modell szerinti leképezéssel
            javattanitok.elosztott.objektumok.LabirintusPOATie tie =
                    new javattanitok.elosztott.objektumok.LabirintusPOATie(
                    new LabirintusKiszolgáló(), gyökérPoa);
            // A Labirintus CORBA objektum
            javattanitok.elosztott.objektumok.Labirintus labirintus =
                    tie._this(orb);
            // A névszolgáltató gyökerének, mint CORBA objektum
            // referenciájának megszerzése
            corbaObjektum =
                    orb.resolve_initial_references("NameService");
            org.omg.CosNaming.NamingContextExt névszolgáltatóGyökere
                    = org.omg.CosNaming.
                    NamingContextExtHelper.narrow(corbaObjektum);
            // A kiszolgáló objektum bejegyzése a névszolgáltatóba
            org.omg.CosNaming.NameComponent név[] =
                    névszolgáltatóGyökere.to_name("ElosztottLabirintus");
            névszolgáltatóGyökere.rebind(név, labirintus);
            // Várakozás a szereplők (hősök, kincsek, szörnyek) jelentkezésére
            orb.run();
            
        } catch (Exception e) {
            
            e.printStackTrace();
            System.exit(-1);
            
        }
    }
    /**
     * Elindítja az elosztott labirintust világának labirintus részét.
     *
     * @param args nincsenek parancssor-argumentumok.
     */
    public static void main(String[] args) {
        
        new ElosztottLabirintus();
        
    }
}					
					]]>					
				</programlisting>
				
             </sect4>

             <sect4>
                <title>Az ElosztottKliens osztály</title>
                
				<para>
				Ez az osztály tölti be leginkább a kliens szerepét, mert ő
				élteti a labirintust szereplőit kiszolgáló objektumokat, akiket számtalan
				esetben hívnak vissza más szereplők vagy a labirintus: ebben az értelemben
				viszont szerver.				
				</para>
                
				<programlisting>
					<![CDATA[
/*
 * ElosztottKliens.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import javattanitok.elosztott.*;
/**
 * Az elosztott CORBA-s labirintus csomag absztrahálta elosztott labirintus
 * mikrovilágának egy kliens oldali életre keltésére ad példát ez az osztály,
 * mely egyben a szereplő objektumok visszahívható szervere is.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see ElosztottLabirintus
 * @see SzereplőKiszolgáló
 * @see HősKiszolgáló
 * @see SzörnyKiszolgáló
 * @see KincsKiszolgáló
 */
public class ElosztottKliens implements Runnable {
    org.omg.CORBA.ORB orb; // hogy a run()-ból elérjük őket
    javattanitok.elosztott.objektumok.Labirintus labirintus;
    /**
     * Elkészíti a távol gépre bejelentkező hős, szörny vagy
     * kincs visszahívható kliens CORBA objektumot. Hősként
     * való indításakor feldolgozza a játékostól jövő billentyű
     * parancsokat.
     *
     * @param args első tagja "hős" - Hos objektum, "kincs" -
     * Kincs objektum, "szörny" - Szorny objektum lesz a kliens,
     * alapértelmezés a "kincs".
     */
    public ElosztottKliens(String[] args) {
        
        String ki = null;
        // ha nem adtuk meg a parancssor-argumentumot,
        // akkor ez az alapértelmezés:
        if(args.length != 1)
            ki = "Kincs";
        else
            ki = args[0];
        
        try {
            // Az ORB tulajdonságainak megadása
            java.util.Properties orbTulajdonságok = new java.util.Properties();
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialHost",
                    "172.21.0.152");
            orbTulajdonságok.put("org.omg.CORBA.ORBInitialPort", "2006");
            // Az ORB (a metódushívások közvetítőjének) inicializálása
            orb = org.omg.CORBA.ORB.init((String [])null,
                    orbTulajdonságok);
            // A névszolgáltató gyökerének, mint CORBA objektum
            // referenciájának megszerzése
            org.omg.CORBA.Object corbaObjektum =
                    orb.resolve_initial_references("NameService");
            org.omg.CosNaming.NamingContextExt névszolgáltatóGyökere
                    = org.omg.CosNaming.
                    NamingContextExtHelper.narrow(corbaObjektum);
            // A labirintus CORBA objektum referenciájának megszerzése
            labirintus =
                    javattanitok.elosztott.objektumok.
                    LabirintusHelper.narrow(névszolgáltatóGyökere.
                    resolve_str("ElosztottLabirintus"));
            // A gyökér POA CORBA objektum referenciájának megszerzése
            corbaObjektum = orb.resolve_initial_references("RootPOA");
            // CORBA-s típuskényszerítéssel a megfelelőre
            org.omg.PortableServer.POA gyökérPoa =
                    org.omg.PortableServer.POAHelper.narrow(corbaObjektum);
            // A POA kiszolgáló állapotba kapcsolása:
            gyökérPoa.the_POAManager().activate();
            // Miként indították ezt a klienst?
            if("hős".equals(ki)) {
                // Ha a kliens hősként működik
                
                // A Hos kiszolgáló objektum elkészítése,
                // a delegációs/POA/Tie modell szerinti leképezéssel
                javattanitok.elosztott.objektumok.HosPOATie tie =
                        new javattanitok.elosztott.objektumok.HosPOATie(
                        new HősKiszolgáló(), gyökérPoa);
                // A Hos CORBA objektum
                javattanitok.elosztott.objektumok.Hos hős = tie._this(orb);
                
                System.out.println("HŐS> ELkészültem: " + hős);
                
                // Távoli metódus hívása, a távoli CORBA labirintus
                // objektumnak átadkuk a Hos CORBA objektum referenciáját
                System.out.println(labirintus.belepHos(hős));
                
                new Thread(this).start();
                
                // CORBA szerverként is üzemelünk, mert a Hos
                // objektumot a Labirintus objektum majd visszahívogatja
                orb.run();
                
            } else if("szörny".equals(ki)) {
                // Ha a kliens szörnyként működik
                javattanitok.elosztott.objektumok.SzornyPOATie tie =
                        new javattanitok.elosztott.objektumok.SzornyPOATie(
                        new SzörnyKiszolgáló(), gyökérPoa);
                javattanitok.elosztott.objektumok.Szorny szörny =
                        tie._this(orb);
                
                System.out.println(labirintus.belepSzorny(szörny));
                
                orb.run();
                
            } else  {
                // Ha a kliens kincsként működik
                javattanitok.elosztott.objektumok.KincsPOATie tie =
                        new javattanitok.elosztott.objektumok.KincsPOATie(
                        new KincsKiszolgáló(), gyökérPoa);
                javattanitok.elosztott.objektumok.Kincs kincs =
                        tie._this(orb);
                
                System.out.println(labirintus.belepKincs(kincs));
                
                orb.run();
                
            }
            
        } catch (Exception e) {
            
            e.printStackTrace();
            
        }
    }
    /** A hős játékostól jövő billentyűzet input feldolgozása. */
    public void run() {
        
        try {
            // Feldolgozzuk a játékostól jövő billentyű parancsokat
            java.io.BufferedReader konzol =
                    new java.io.BufferedReader(
                    new java.io.InputStreamReader(System.in));
            
            String parancs = null;
            while((parancs = konzol.readLine()) != null) {
                System.out.println(parancs);
                // A Hos CORBA objektum kilép a labirintusból
                if("k".equals(parancs))
                    break;
                // További lépés parancsok itt implemetálva: föl, le stb. ...
            }
        } catch(java.io.IOException e) {
            System.out.println(e);
        }
        orb.shutdown(false);
        System.exit(0);
    }
    /** Az elosztott labirintus klienseinek indítása.
     *
     * @param args első tagja "hős" - Hos objektum, "kincs" -
     * Kincs objektum, "szörny" - Szorny objektum lesz a kliens,
     * alapértelmezés a "kincs".
     */
    public static void main(String[] args) {
        
        new ElosztottKliens(args);
        
    }
}					
					]]>					
				</programlisting>
				
             </sect4>

             
        </sect3>
            
        <sect3>
            <title>Az Elosztott labirintus fordítása és futtatása</title>
        
		   <para>
			A <computeroutput>172.21.0.152</computeroutput> gépen egy parancsablakban
			futtatjuk az <application>idlj</application> fordítót, hogy megkapjuk az
			alkalmazásunkhoz tartozó
			CORBA specifikus 
			Java forrásokat. Ezek az <filename>elosztott.idl</filename>
			interfész definíciós állomány modul szerkezetének megfelelően a 
			<filename class="directory">javattanitok\elosztott\objektumok</filename> könyvtárba íródnak ki.
			Ezután az egész projektünket lefordítjuk.
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> idlj -fall -falltie elosztott.idl
C:\...\Munkakönyvtár> javac javattanitok\*.java javattanitok\labirintus\*.java javattanitok\elosztott\*.java
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
                ]]>
            </screen>     
		   </para>

		   <para>
		   A <computeroutput>172.21.0.152</computeroutput> gépen, mondjuk egy
		   másik parancsablakban elindítjuk
		   az <application>orbd</application> ORB démont. A démonnal együtt a 
		   névszolgáltatás is elindul. Az <classname>ElosztottLabirintus</classname>
		   szerver objektum 
		   a kiszolgáló <classname>LabirintusKiszolgáló</classname> CORBA objektumot majd
		   <literal>ElosztottLabirintus</literal> néven jegyzi be ide. Annak a CORBA kliens
		   alkalmazásnak, aki el akarja érni ezt a bejegyzett 
		   <classname>LabirintusKiszolgáló</classname> CORBA 
		   objektumot, nem kell mást tennie, mint megszerezni a 
		   <computeroutput>172.21.0.152</computeroutput> hoszt <literal>2006</literal>-os
		   kapujánál figyelő ORB névszolgáltatást végző objektumának referenciáját és 
		   ettől az objektumtól elkérni a nála bejegyzett
		   <literal>ElosztottLabirintus</literal> névhez tartozó CORBA objektum eferenciát, de
		   ne szaladjunk ennyire messzire, egyelőre indítsuk tehát az ORB démont!
		   		   
           <screen>
                <![CDATA[
C:\Documents and Settings\norbi> start orbd -ORBInitialPort 2006 -ORBInitialHost 172.21.0.152
                ]]>
            </screen>     
            
<tip> 
<title>Az elosztott labirintus egy gépen</title>           
		   <para>
		   Ha a kedves Olvasó egyetlen gépen szeretné tesztelni a példát, akkor
		   a parancssorban és a <filename>ElosztottKliens.java</filename>
		    forrásban a <computeroutput>172.21.0.152</computeroutput>
		   helyett használja a <computeroutput>localhost</computeroutput>-ot!
		   </para>
</tip>            
            
		   </para>

		   <para>
		   Ugyancsak a <computeroutput>172.21.0.152</computeroutput> gépen, mondjuk abban
		   a parancsablakban, melyben a fordítást végeztük, indítsuk el a 
		   labirintus CORBA objektumot, pontosabban az objektumot elkészítő és a 
		   névszolgáltatóban bejegyző szervert, az <classname>ElosztottLabirintus</classname>
		   osztályt!
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.ElosztottLabirintus
 Idő:1 hős:0 kincs:0 szörny:0
 Idő:2 hős:0 kincs:0 szörny:0
 Idő:3 hős:0 kincs:0 szörny:0
 ...
                ]]>
            </screen>     
            A labirintusunk időfejlődésének minden pillanatában kiírja fő
            jellemzőit, hogy éppen hány hős, kincs és szörny van benne.
		   </para>

		   <para>
		   Még mindig ugyanazon a <computeroutput>172.21.0.152</computeroutput> gépen, de egy
		   másik parancsablakban futtassunk egy kincset!
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.ElosztottKliens
SZEREPLŐ> Beállították a pozíciómat.
 Idő:12 hős:0 kincs:1 szörny:0
                ]]>
            </screen>     
            A parancssor paraméter nélkül induló <classname>ElosztottKliens</classname>
            CORBA kliens <classname>KincsKiszolgáló</classname> objektumot készít, a
            névszolgáltatón keresztül megszerzi a labirintus referenciáját, majd átadja 
            a kliensként - a most éppen kincsként - elkészített CORBA objektum referenciáját
            a labirintusnak. Aki immár majd ezt a referenciát felhasználva anélkül tudja
            visszahívni a kincs klienst, hogy a kincs bármely névszolgáltatóba be lenne
            jegyezve.            
           </para>

		   <para> Közben a 
		   <computeroutput>Parancssor - java javattanitok.ElosztottLabirintus</computeroutput>
		   ablakban a labirintus logolja a bejelentkező klienst.		   
           <screen>
                <![CDATA[
...
 Idő:10 hős:0 kincs:0 szörny:0
 Idő:11 hős:0 kincs:0 szörny:0
LABIRINTUS> Belépett egy kincs.
 Idő:12 hős:0 kincs:1 szörny:0
 Idő:13 hős:0 kincs:1 szörny:0
 ...
                ]]>
            </screen>     
		   </para>

		   <para>
		   Továbbra is ugyanazon a <computeroutput>172.21.0.152</computeroutput> gépen, de 
		   megint egy
		   újabb parancsablakban futtassunk most egy szörnyet!
		   
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.ElosztottKliens szörny
SZEREPLŐ> Beállították a pozíciómat.
 Idő:42 hős:0 kincs:1 szörny:1
...
                ]]>
            </screen>     
		   </para>

		   <para> Közben megint csak a 
		   <computeroutput>Parancssor - java javattanitok.ElosztottLabirintus</computeroutput>
		   ablakban a labirintus logolja az éppen bejelentkett szörny klienst.		   
           <screen>
                <![CDATA[
...
 Idő:40 hős:0 kincs:1 szörny:0
 Idő:41 hős:0 kincs:1 szörny:0
LABIRINTUS> Belépett egy szörny.
 Idő:42 hős:0 kincs:1 szörny:1
 Idő:43 hős:0 kincs:1 szörny:1
 ...
                ]]>
            </screen>     
		   </para>


		   <para>
		   Még továbbra is ugyanazon a <computeroutput>172.21.0.152</computeroutput> gépen, de 
		   megint csak egy
		   újabb parancsablakban futtassunk most egy hőst!
		   
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.ElosztottKliens hős
HŐS> ELkészültem: IOR:000000000000002e49444c3a6a6176617474616e69746f6b2f656c6f73
7a746f74742f6f626a656b74756d6f6b2f486f733a312e3000000000000001000000000000008600
0102000000000e3137322e31372e3133352e3631000d7800000031afabcb0000000020ffe655a100
000001000000000000000100000008526f6f74504f41000000000800000001000000001400000000
00000200000001000000200000000000010001000000020501000100010020000101090000000100
01010000000026000000020002
SZEREPLŐ> Beállították a pozíciómat.
 Idő:68 hős:1 kincs:1 szörny:1
SZEREPLŐ> Lekérdezték a pozíciómat.
SZEREPLŐ> Lekérdezték a pozíciómat.
                ]]>
            </screen>     
		   </para>

            <tip>
            <title>Interoperable Object Reference</title>
                <para>
                    Csupán az érdekesség kedvéért kiírattuk a (kliens) hős objektum
                    referenciáját (címét).
                </para>            
            </tip>

		   <para> Közben a 
		   <computeroutput>Parancssor - java javattanitok.ElosztottLabirintus</computeroutput>
		   ablakban a labirintus logolja a bejelentkező hőst.		   
           <screen>
                <![CDATA[
...
 Idő:66 hős:0 kincs:1 szörny:1
 Idő:67 hős:0 kincs:1 szörny:1
LABIRINTUS> Belépett egy hős: IOR:000000000000002e49444c3a6a6176617474616e69746
f6b2f656c6f737a746f74742f6f626a656b74756d6f6b2f486f733a312e300000000000000100000
00000000086000102000000000e3137322e31372e3133352e3631000d7800000031afabcb0000000
020ffe655a100000001000000000000000100000008526f6f74504f4100000000080000000100000
00014000000000000020000000100000020000000000001000100000002050100010001002000010
109000000010001010000000026000000020002
 Idő:68 hős:1 kincs:1 szörny:1
 Idő:69 hős:1 kincs:1 szörny:1
 ...
                ]]>
            </screen>     
		   </para>

            <note>
            <title>Interoperable Object Reference</title>
                <para>
                    Nem meglepő módon ezt az IOR referenciát ismeri a szerver oldal is. 
                </para>            
            </note>
            
		   <para> A hős belépését követően - programozásunknak megfelelően - felélednek 
		   az eddig szunnyadó kliens ablakok. A
		   <computeroutput>Parancssor - java javattanitok.ElosztottKliens</computeroutput>
		   ablakban a kincs logolását látjuk. 
           <screen>
                <![CDATA[
...
KINCS> Nem talált rám.
KINCS> Nem talált rám.
KINCS> Nem talált rám.
 ...
                ]]>
            </screen>     
		   </para>


		   <para>A
		   <computeroutput>Parancssor - java javattanitok.ElosztottKliens szörny</computeroutput>
		   ablakban a szörny objektum logolását látjuk. 
           <screen>
                <![CDATA[
...
SZÖRNY> Lépek egy hős felé.
SZÖRNY> Lépek egy hős felé.
SZÖRNY> Lépek egy hős felé.
 ...
                ]]>
            </screen>     
		   </para>


		   <para>Most beléptetünk néhány további szereplőt egy másik, a
		   <computeroutput>172.21.0.17</computeroutput> gépről. Hasonlóan itt is
		   futtatjuk az <application>idlj</application> fordítót és lefordítjuk a 
		   projektet.
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> idlj -fall -falltie elosztott.idl
C:\...\Munkakönyvtár> javac javattanitok\*.java java ttanitok\labirintus\*.java javattanitok\elosztott\*.java
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
                ]]>
            </screen>     
            Majd most ebből az ablakból is indítunk egy kincset.
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.ElosztottKliens
SZEREPLŐ> Beállították a pozíciómat.
KINCS> Nem talált rám.
 Idő:293 hős:1 kincs:2 szörny:1
KINCS> Nem talált rám.
KINCS> Nem talált rám.
KINCS> Nem talált rám.
                ]]>
            </screen>                 
		   </para>

		   <para> Közben a másik, a <computeroutput>172.21.0.152</computeroutput> gép
		   <computeroutput>Parancssor - java javattanitok.ElosztottLabirintus</computeroutput>
		   ablakban a labirintus logolja a most bejelentkező kincs klienst.		   
           <screen>
                <![CDATA[
...
 Idő:291 hős:1 kincs:1 szörny:1
 Idő:292 hős:1 kincs:1 szörny:1
LABIRINTUS> Belépett egy kincs.
 Idő:293 hős:1 kincs:2 szörny:1
 Idő:294 hős:1 kincs:2 szörny:1
 ...
                ]]>
            </screen>     
		   </para>

		   <para>
		   Továbbra is a <computeroutput>172.21.0.17</computeroutput> gépen, de 
		   megint egy
		   újabb parancsablakban futtassunk most egy szörnyet!
		   
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.ElosztottKliens szörny
SZEREPLŐ> Beállították a pozíciómat.
SZÖRNY> Lépek egy hős felé.
 Idő:327 hős:1 kincs:2 szörny:2
SZÖRNY> Lépek egy hős felé.
SZÖRNY> Lépek egy hős felé.
...
                ]]>
            </screen>     
		   </para>

		   <para> Közben megint csak a <computeroutput>172.21.0.152</computeroutput> gép,
		   <computeroutput>Parancssor - java javattanitok.ElosztottLabirintus</computeroutput>
		   ablakban a labirintus logolja ezt az éppen bejelentkezett szörny klienst.		   
           <screen>
                <![CDATA[
...
 Idő:325 hős:1 kincs:2 szörny:1
 Idő:326 hős:1 kincs:2 szörny:1
LABIRINTUS> Belépett egy szörny.
 Idő:327 hős:1 kincs:2 szörny:2
 Idő:328 hős:1 kincs:2 szörny:2
 ...
                ]]>
            </screen>     
		   </para>


		   <para>
		   Még továbbra is a <computeroutput>172.21.0.17</computeroutput> gépen maradva,  
		   egy
		   újabb parancsablakból léptessünk be most egy hőst!
		   
           <screen>
                <![CDATA[
C:\...\Munkakönyvtár> java javattanitok.ElosztottKliens hős
HŐS> ELkészültem: IOR:000000000000002e49444c3a6a6176617474616e69746f6b2f656c6f73
7a746f74742f6f626a656b74756d6f6b2f486f733a312e3000000000000001000000000000008600
0102000000000e3137322e31372e3133352e353300055d00000031afabcb0000000020ffebeff400
000001000000000000000100000008526f6f74504f41000000000800000001000000001400000000
00000200000001000000200000000000010001000000020501000100010020000101090000000100
01010000000026000000020002
SZEREPLŐ> Beállították a pozíciómat.
 Idő:359 hős:2 kincs:2 szörny:2
SZEREPLŐ> Lekérdezték a pozíciómat.
...
                ]]>
            </screen>     
		   </para>
		   
            <note>
            <title>Interoperable Object Reference</title>
                <para>
                    A referenciát gondosan összehasonlítva az előzővel, a harmadik
                    sor környékén látható a különbség.
                </para>            
            </note>

		   <para> A hős belépésének megfelelően a szerver oldal, azaz a 
		   <computeroutput>172.21.0.152</computeroutput> gép, a
		   <computeroutput>Parancssor - java javattanitok.ElosztottLabirintus</computeroutput>
		   ablakban a labirintus logolja ezt az éppen bejelentkezett hős objektumot.		   
           <screen>
                <![CDATA[
...
 Idő:357 hős:1 kincs:2 szörny:2
 Idő:358 hős:1 kincs:2 szörny:2
LABIRINTUS> Belépett egy hős: .IOR:000000000000002e49444c3a6a6176617474616e69746
f6b2f656c6f737a746f74742f6f626a656b74756d6f6b2f486f733a312e300000000000000100000
00000000086000102000000000e3137322e31372e3133352e353300055d00000031afabcb0000000
020ffebeff400000001000000000000000100000008526f6f74504f4100000000080000000100000
00014000000000000020000000100000020000000000001000100000002050100010001002000010
109000000010001010000000026000000020002
 Idő:359 hős:2 kincs:2 szörny:2
 Idő:360 hős:2 kincs:2 szörny:2
 ...
                ]]>
            </screen>     
		   </para>


		   <para>
		   Beléptethetünk további szereplőket, vagy a hősökkel ki is léphetünk a 
		   játékból. A játék programja ezt a legtöbb esetben tolerálja: 
           <screen>
                <![CDATA[
...
 Idő:369 hős:2 kincs:3 szörny:2
 Idő:370 hős:2 kincs:3 szörny:2
LABIRINTUS> Egy hőst eltávolítottam.
 Idő:371 hős:1 kincs:3 szörny:2
 Idő:372 hős:1 kincs:3 szörny:2
 ...
                ]]>
            </screen>     
				de könnyen előfordulhatnak kivételek, amikor már nem létező
				CORBA objektumoknak akarunk üzenetet küldeni.
		   </para>

            
		</sect3>            
            
        </sect2>

    </sect1>
    
    </chapter>            

    <chapter>    

    <chapterinfo>
        <keywordset>
			  <keyword>Java források</keyword>
			  <keyword>Java csomagok</keyword>
              <keyword>esettanulmányok</keyword>
              <keyword>Java esettanulmányok</keyword>                            
              <keyword>labirintus</keyword>
              <keyword>labirintus esettanulmányok</keyword>                            
              <keyword>Applet</keyword>                                          
              <keyword>MIDlet</keyword>
              <keyword>Servlet</keyword>
              <keyword>Java RMI</keyword>
              <keyword>TCP/IP</keyword>              
              <keyword>CORBA</keyword>
              <keyword>elosztott programozás</keyword>
        </keywordset>
    </chapterinfo>
    
        <title>Példaprogramok</title>

    <sect1 id="pelda_csomagok">
        <title>A csomagok szervezése</title>

        <para>Jelen fejezetben összefoglaljuk az esettanulmányok osztályait. 
        Az előző fejezetben bemutattuk ezeknek az osztályoknak a - megjegyzésekkel gazdagon ellátott - forráskódjait. 
        Az előzőt megelőző fejezetek ezekből a forrásokból tartalmaznak kiragadott 
         és sokszor leegyszerűsített forráskód részleteket. Illetve ebben a fejezetben
         találjuk a labirintus példák olyan forrásait, amit eddig még nem közöltünk, például
         a <classname>LabirintusAlkalmazás</classname> forrását.</para>
        
        <sect2 id="forras_letoltes">
            <title>A példaprogramok forrásainak letöltése</title>
            
				<para>
				A könyvhöz készített források használatára azt javasoljuk, hogy az
				Olvasó a kézikönyv böngészhető 
				változatából jelölje ki a kívánt kódot majd - követve a kód mellett szereplő,
				 erre 
				vonatkozó instrukcióinkat - illessze be a megfelelő forrásállományba! Így kerülhetők
				el legnagyobb valószínűséggel a különböző platformokon (például
				Windows vagy Linux) való felhasználás során
				esetlegesen jelentkező karakterkódolási problémák. De jelen 
				javaslatunk ellenére egy
				zip tömörített állományban is letölthetővé tettük a megfelelő csomagokba szervezett
				forrásokat. Ezt a <filename>javat_tanitok_forrasok.zip</filename> állományt 
				- a kézikönyv böngészhető 
				változatában - a következő linket követve érheti el a kedves Olvasó:
				
                 <itemizedlist>
                    <listitem>
                      <para><ulink url="forrasok/javat_tanitok_forrasok.zip">javat_tanitok_forrasok.zip</ulink>                
                      </para>
                      
                      <para>
A <filename>javat_tanitok_forrasok.zip</filename> tömör állományba 
gyűjtött források elkészítésénél úgy jártunk el, 
hogy a forrásokat magából a kézikönyvből másoltuk (és 
próbáltuk) ki, így a kedves Olvasónak nem lehet gondja a 
példák kipróbálásával, ha követi a kézikönyv utasításait.
                      </para>

                      <para>
A <filename>javattanitok</filename> könyvtárban találjuk a labirintusos
példákat. Ezek közül azokat gyűjtöttük ki ide a kézikönyvből,
amelyek kipróbálása a kézikönyv fő sodrában van leírva.
(De  például a szintén labirintusos <filename>LabirintusAlkalmazás.java</filename>
forrást nem vettük ide, az csak a kézikönyvben szerepel.
                      </para>

                      <para>
A <filename>nehany_egyeb_pelda</filename> könyvtárba pedig a kézikönyv számos egyéb
példája közül csupán néhány kiválasztottat válogattunk be. A
többi esetén azt az általános elvet kövessük, hogy a forrást
vágjuk ki a kézikönyv (pl. böngészhető) változatából és a 
kipróbálással kövessük a kézikönyv utasításait.                      
                      </para>
                      
                    </listitem>
                    </itemizedlist>

				Az esettanulmányokban használt ikonokat, egyszerű képeket a 
				<filename>javat_tanitok_kepek.zip</filename>
			archívumba gyűjtöttük össze, ezt hasonlóan a következő linket követve érheti el:
			
                 <itemizedlist>
                    <listitem>
                      <para><ulink url="forrasok/javat_tanitok_kepek.zip">javat_tanitok_kepek.zip</ulink>                
                      </para>
                    </listitem>
                    </itemizedlist>

				</para>
            
        </sect2>
                
        <sect2>
            <title>javattanitok.labirintus csomag</title>
            
            <para>Egy labirintus mikrovilágának leírására mutatnak példát ennek a csomagnak az osztályai. A csomagban megszervezett osztályhierarchia a következő:
            
            <programlisting>
                <![CDATA[
java.lang.Object
    javattanitok.labirintus.Labirintus
        javattanitok.labirintus.GenerikusLabirintus
        javattanitok.labirintus.TöbbHősösLabirintus
    javattanitok.labirintus.Szereplő
        javattanitok.labirintus.Hős
        javattanitok.labirintus.Kincs
        javattanitok.labirintus.Szörny
    java.lang.Throwable (implements java.io.Serializable)
        java.lang.Exception
            javattanitok.labirintus.RosszLabirintusKivétel
                ]]>
            </programlisting>
            </para>                        
            
            </sect2>
            
            <sect2>
                <title>javattanitok.elosztott csomag</title>
                
            <para>Egy elosztott labirintus mikrovilágának leírására mutatnak példát ennek a csomagnak az osztályai. A csomagban megszervezett osztályhierarchia a következő:
            
            <programlisting>
                <![CDATA[
java.lang.Object
    javattanitok.labirintus.Labirintus
        javattanitok.labirintus.TöbbHősösLabirintus
             javattanitok.elosztott.LabirintusKiszolgáló
             (implements java.lang.Runnable)
    javattanitok.elosztott.objektumok.SzereploPOA
        javattanitok.elosztott.SzereplőKiszolgáló
             javattanitok.elosztott.HősKiszolgáló
             javattanitok.elosztott.KincsKiszolgáló
             javattanitok.elosztott.SzörnyKiszolgáló                
                ]]>
            </programlisting>
            </para>                        
            
            <para>A CORBA objektumok hierarchiája a következő:
            
            <programlisting>
                <![CDATA[
    javattanitok.elosztott.objektumok.Szereplo
         javattanitok.elosztott.objektumok.Hos
         javattanitok.elosztott.objektumok.Kincs
         javattanitok.elosztott.objektumok.Szorny
    javattanitok.elosztott.objektumok.Labirintus                
                ]]>
            </programlisting>
            </para>                        
            
            </sect2>
            
            <sect2>
                <title>javattanitok csomag</title>
                
            <para>
                A labirintus és az elosztott labirintus mindenféle életre keltésére példát mutató osztályokat szerveztük ebbe a csomagba. A <classname>javattanitok.labirintus</classname> és a <classname>javattanitok.elosztott</classname> csomagok absztrahálta labirintusok mikrovilágainak a legfőbb életre keltései következők:
                <orderedlist numeration="arabic">
                    <listitem>
                        <para>Tiszta objektumorientált</para>
                    </listitem>
                    <listitem>
                        <para>Appletes</para>
                    </listitem>
                    <listitem>
                        <para>Teljes képernyős (Full Screen Exclusive Mode API) </para>
                    </listitem>
                    <listitem>
                        <para>MIDlet-es (mobiltelefonos)</para>
                    </listitem>
                    <listitem>
                        <para>Szervletes, </para>
                    </listitem>
                    <listitem>
                        <para>TCP/IP-s, </para>
                    </listitem>
                    <listitem>
                        <para>Java RMI-s, </para>
                    </listitem>
                    <listitem>
                        <para>CORBA-s </para>
                    </listitem>
                    <listitem>
                        <para>Elosztott</para>
                    </listitem>
                </orderedlist>
            </para>
            
            <para>A csomagban megszervezett osztályhierarchia a következő:</para>
            
            <para>
            <programlisting>
                <![CDATA[
java.lang.Object
    java.awt.Component (implements
    java.awt.image.ImageObserver, java.awt.MenuContainer,
    java.io.Serializable)
         java.awt.Container
              java.awt.Panel (implements
              javax.accessibility.Accessible)
                   java.applet.Applet
                        javattanitok.LabirintusApplet
                        (implements
                        java.awt.event.KeyListener)
              java.awt.Window (implements
              javax.accessibility.Accessible)
                   java.awt.Frame (implements
                   java.awt.MenuContainer)
                        javattanitok.LabirintusAlkalmazás
                        (implements java.awt.event.KeyListener)
                        javattanitok.LabirintusJáték 
                        (implements java.lang.Runnable)
    javattanitok.ElosztottKliens
    javattanitok.ElosztottLabirintus
    javax.microedition.lcdui.game.GameCanvas
         javattanitok.LabirintusVaszon (implements java.lang.Runnable)
    javattanitok.HálózatiLabirintus (implements java.lang.Runnable)
         javattanitok.KorbásLabirintus
         javattanitok.TávoliLabirintus (implements javattanitok.TávoliHősíthető)
    javax.servlet.http.HttpServlet
         javattanitok.LabirintusServlet
    javattanitok.KorbásKliens
    javattanitok.LabirintusKiszolgálóSzál (implements java.lang.Runnable)
    javattanitok.LabirintusVilág (implements java.lang.Runnable)
         javattanitok.GenerikusLabirintusVilág
    javax.microedition.midlet.MIDlet
         javattanitok.LabirintusMIDlet
    javattanitok.korbas.TavoliHosPOA
         javattanitok.TávoliHősKiszolgáló
    javattanitok.TávoliKliens

java.rmi.Remote
    javattanitok.TávoliHősíthető
                
                ]]>
            </programlisting>
            </para>


            <sect3>
                <title>A LabirintusAlkalmazás osztály</title>
               
                <para>
                Az alábbi <classname>LabirintusAlkalmazás</classname> osztály kódját 
                <emphasis><link linkend="musztang">A Musztáng</link></emphasis>
                című pontban tárgyaljuk részletesen.
                </para>
                
            <programlisting>
                <![CDATA[
/*
 * LabirintusAlkalmazás.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
package javattanitok;

import java.awt.event.ActionEvent;
import javattanitok.labirintus.*;
/**
 * A labirintus csomag absztrahálta labirintus mikrovilágának egy
 * alkalmazásbeli életre keltésére ad példát ez az osztály, miközben
 * bemutatja a Java 6 (Musztáng) néhány újdonságát.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 * @see javattanitok.LabirintusVilág
 * @see javattanitok.LabirintusJáték
 * @see javattanitok.LabirintusMIDlet
 * @see javattanitok.LabirintusServlet
 * @see javattanitok.HálózatiLabirintus
 * @see javattanitok.TávoliLabirintus
 * @see javattanitok.ElosztottLabirintus
 */
public class LabirintusAlkalmazás extends java.awt.Frame
        implements java.awt.event.KeyListener {
    /** A labirintus. */
    Labirintus labirintus;
    /** A hős. */
    Hős hős;
    /** A játék vége után már nem veszünk át inputot a játékostól,
     * illetve a játék világának állapota sem változik. */
    boolean játékVége = false;
    /** A játék vége után megjelenő üzenet. */
    String végeÜzenet = "Vége a játéknak!";
    // A labirintus szereplőihez rendelt képek
    java.awt.Image falKép;
    java.awt.Image járatKép;
    java.awt.Image hősKép;
    java.awt.Image szörnyKép;
    java.awt.Image kincsKép;
    /** Konstruktor.
     */
    public LabirintusAlkalmazás() {
        
        super("Labirintus alkalmazás");
        /* itt kezdenénk, de most majd lejjebb
        java.awt.SplashScreen indítóKépernyő
                = java.awt.SplashScreen.getSplashScreen();
        java.awt.Graphics2D g = indítóKépernyő.createGraphics(); ...
         */
        labirintus = new Labirintus(6, 3);
        hős = new Hős(labirintus);
        hős.sor(9);
        hős.oszlop(0);
        
        falKép = new javax.swing.ImageIcon
                ("fal.png").getImage();
        járatKép = new javax.swing.ImageIcon
                ("járat.png").getImage();
        hősKép = new javax.swing.ImageIcon
                ("hős.png").getImage();
        szörnyKép = new javax.swing.ImageIcon
                ("szörny.png").getImage();
        kincsKép = new javax.swing.ImageIcon
                ("kincs.png").getImage();
        
        // Ha a rendszerben támogatott az értesítési terület
        if (java.awt.SystemTray.isSupported()) {
            // akkor egy kis 16x16 pixel méretű
            java.awt.Image ikonKép = new javax.swing.ImageIcon
                    ("ikon.png").getImage();
            // értesítő ikont
            java.awt.TrayIcon értesítőIkon =
                    new java.awt.TrayIcon(ikonKép,
                    "Javat tanítok labirintus");
            // most mi is kiteszünk
            try {
                java.awt.SystemTray.getSystemTray().
                        add(értesítőIkon);
            } catch (java.awt.AWTException e) {
                System.out.println("Értesítő ikon kitétele: "
                        + e);
            }
            // amire ha duplán kattintunk, akkor
            értesítőIkon.addActionListener(
                    new java.awt.event.ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    // például szorult helyzetéből kimenekítve a
                    // hőst, visszadobjuk a kiindulási pozíciójába
                    hős.sor(9);
                    hős.oszlop(0);
                    repaint();
                }
            });
        }
        
        // amit be is lehet csukni
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
        
        addKeyListener(this);
        setSize(1024, 768);
        
        // Hozzáférünk az indító képernyőhöz
        java.awt.SplashScreen indítóKépernyő
                = java.awt.SplashScreen.getSplashScreen();
        // Ha sikerül, azaz, ha java -splash:kép állomány neve
        // formában indítottuk és még látszik a kép
        if(indítóKépernyő != null) {
            // akkor rajzolni fogunk rá
            java.awt.Graphics2D g = indítóKépernyő.createGraphics();
            // némi szöveget, amit akár a rajzolóprogrammal is
            // ráírhattunk volna
            java.awt.Font font1 = new java.awt.Font("Sans",
                    java.awt.Font.BOLD, 20);
            java.awt.Font font2 = new java.awt.Font("Monospaced",
                    java.awt.Font.BOLD, 12);
            g.setFont(font1);
            // világosabb sárgával
            g.setColor(new java.awt.Color(250, 255, 138));
            g.drawString("Javat tanítok labirintus", 8, 240);
            g.setFont(font2);
            g.drawString("Bátfai Norbert", 10, 265);
            g.drawString("nbatfai@inf.unideb.hu", 10, 280);
            // és rajzolunk egy a konkrét kép méretéhez igazított
            // progress bar szerűséget (kommentben az indító
            // képernyő méretéhez relatív adatok)
            int sz = 382; // indítóKépernyő.getSize().width-10;
            int barSzélesség = sz/10;
            int m = 10; // indítóKépernyő.getSize().height;
            int barMagasság = 6;
            // itt szimuláljuk a játék időigényes dolgainak
            // betöltését, 10 x fél másodperig altatjuk majd
            // a szálunkat
            for(int i = 0; i<10; ++i) {
                // és ennek megfelelően frissítjük mit
                // mutasson a progress bar-unk
                g.setColor(java.awt.Color.WHITE);
                g.drawRect(8, 285, //5, m-20,
                        10*barSzélesség, barMagasság);
                g.fillRect(8, 285, //5, m-20,
                        10*barSzélesség, barMagasság);
                g.setColor(java.awt.Color.YELLOW);
                g.drawRect(8, 285, //5, m-20,
                        10*barSzélesség, barMagasság);
                g.fillRect(8, 285, //5, m-20,
                        (i+1)*barSzélesség, barMagasság);
                indítóKépernyő.update();
                try {
                    // a fél másodperces altatás
                    // ez szimulálja pl., hogy töltjük be
                    // a már hatalmas labirintus játékunk
                    // képerőforrásait, készítjük a megfelelő
                    // adatszerkezeteket stb.
                    Thread.sleep(500);
                } catch(Exception e) {}
            }
        }
        
        setVisible(true);
    }
    /**
     * A játékostól (aki a játék világában a hős) jövő input feldolgozása:
     * a hős mozgatása a KURZOR billenytűkkel, illetve a játék világának
     * állapot változásait is innen irányítjuk.
     */
    public void keyPressed(java.awt.event.KeyEvent billentyűEsemény) {
        // Mit nyomott le?
        int billentyű = billentyűEsemény.getKeyCode();
        
        if(!játékVége) {
            // Merre lép a hős?
            switch(billentyű) {
                // A KURZOR billentyűkkel foglalkozunk, a megfelelő irányba
                // lépünk
                case java.awt.event.KeyEvent.VK_UP:
                    hős.lépFöl();
                    break;
                case java.awt.event.KeyEvent.VK_DOWN:
                    hős.lépLe();
                    break;
                case java.awt.event.KeyEvent.VK_RIGHT:
                    hős.lépJobbra();
                    break;
                case java.awt.event.KeyEvent.VK_LEFT:
                    hős.lépBalra();
                    break;
                    
            }
            // A játék világának állapot változása: azaz a játék többi
            // szereplője is lép. Ha ezzel a lépéssel a játék világában
            // történt valami lényeges: pl. vége a játéknak vagy egy szörny
            // elkapta a hőst, akkor reagálunk:
            switch(labirintus.bolyong(hős)) {
                
                case Labirintus.JÁTÉK_MEGY_HŐS_RENDBEN:
                    break;
                case Labirintus.JÁTÉK_MEGY_MEGHALT_HŐS:
                    // Még van élete, visszatesszük a kezdő pozícióra
                    hős.sor(9);
                    hős.oszlop(0);
                    break;
                case Labirintus.JÁTÉK_VÉGE_MINDEN_KINCS_MEGVAN:
                    végeÜzenet = "Győztél, vége a játéknak!";
                    játékVége = true;
                    break;
                case Labirintus.JÁTÉK_VÉGE_MEGHALT_HŐS:
                    végeÜzenet = "Vesztettél, vége a játéknak!";
                    játékVége = true;
                    break;
                    
            }
            // Amíg nincs vége a játéknak, újra rajzoljuk a
            // játék felületét, hogy látszódjanak a játék állapotában
            // bekövetkezett változások
            repaint();
        }
    }
    /**
     * A KeyListener számunkra most érdektelen további metódusait üres
     * testtel definiáljuk felül.
     */
    public void keyTyped(java.awt.event.KeyEvent billentyűEsemény) {}
    public void keyReleased(java.awt.event.KeyEvent billentyűEsemény) {}
    /**
     * Kirajzolja a játék felületét, azaz a labirintust és a benne szereplőket:
     * a hőst, a kincseket és a szörnyeket.
     */
    public void paint(java.awt.Graphics g) {
        
        // A labirintus kirajzolása
        for(int i=0; i<labirintus.szélesség(); ++i) {
            for(int j=0; j<labirintus.magasság(); ++j) {
                
                if(labirintus.szerkezet()[j][i])
                    g.drawImage(falKép, i*falKép.getWidth(this),
                            j*falKép.getHeight(this), null);
                else
                    g.drawImage(járatKép, i*járatKép.getWidth(this),
                            j*járatKép.getHeight(this), null);
                
            }
        }
        // A kincsek kirajzolása
        Kincs[] kincsek = labirintus.kincsek();
        for(int i=0; i<kincsek.length; ++i) {
            g.drawImage(kincsKép,
                    kincsek[i].oszlop()*kincsKép.getWidth(this),
                    kincsek[i].sor()*kincsKép.getHeight(this), null);
            
            // Ha már megvan a kics, akkor áthúzzuk
            if(kincsek[i].megtalálva()) {
                g.setColor(java.awt.Color.red);
                g.drawLine(kincsek[i].oszlop()*kincsKép.getWidth(this),
                        kincsek[i].sor()*kincsKép.getHeight(this),
                        kincsek[i].oszlop()*kincsKép.getWidth(this)
                        + kincsKép.getWidth(this),
                        kincsek[i].sor()*kincsKép.getHeight(this)
                        + kincsKép.getHeight(this));
                g.drawLine(kincsek[i].oszlop()*kincsKép.getWidth(this)
                        + kincsKép.getWidth(this),
                        kincsek[i].sor()*kincsKép.getHeight(this),
                        kincsek[i].oszlop()*kincsKép.getWidth(this),
                        kincsek[i].sor()*kincsKép.getHeight(this)
                        + kincsKép.getHeight(this));
            } else {
                // ellenkező esetben kiírjuk az értékét
                g.setColor(java.awt.Color.yellow);
                g.drawString(""+kincsek[i].érték(),
                        kincsek[i].oszlop()*kincsKép.getWidth(this)
                        + kincsKép.getWidth(this)/2,
                        kincsek[i].sor()*kincsKép.getHeight(this)
                        + kincsKép.getHeight(this)/2);
            }
            
        }
        // A szörnyek kirajzolása
        Szörny[] szörnyek = labirintus.szörnyek();
        for(int i=0; i<szörnyek.length; ++i)
            g.drawImage(szörnyKép,
                    szörnyek[i].oszlop()*szörnyKép.getWidth(this),
                    szörnyek[i].sor()*szörnyKép.getHeight(this), null);
        // A hős kirajzolása
        g.drawImage(hősKép,
                hős.oszlop()*hősKép.getWidth(this),
                hős.sor()*hősKép.getHeight(this), null);
        
        // A játék aktuális adataiból néhány kiíratása
        g.setColor(java.awt.Color.black);
        
        g.drawString("Életek száma: "+hős.életek(), 10, 40);
        g.drawString("Gyűjtött érték: "+hős.pontszám(), 10, 60);
        
        if(játékVége) {
            g.setColor(java.awt.Color.black);
            g.drawString(végeÜzenet, 420, 350);
        }
    }
    /**
     * A játék felületének kirajzolásakor ne legyen villogás, ezért
     * az eredeti, a felület törlését elvégző update metódust felüldefiniáljuk.
     */
    public void update(java.awt.Graphics g) {
        paint(g);
    }
    /**
     * A program alkalmazásként való indíthatóságát szolgálja.
     */
    public static void main(String[] args) {
        // Ha itt van a vezérlés, akkor nem igaz az, hogy appletként indítottuk
        new LabirintusAlkalmazás();
    }
}                
                ]]>
            </programlisting>

				<sect4>
					<title>A LabirintusAlkalmazás kipróbálása</title>
				   
					<para>
					A <computeroutput>Munkakönyvtár</computeroutput> nevű munkakönyvtárunkba
					másoljuk be a 16x16 vagy 32x32 pixeles <filename>ikon.png</filename> ikont és 
					<emphasis><link linkend="musztang">A Musztáng</link></emphasis>, a 
					Java 6 újdonságait bemutató pontban
					részletesen tárgyalt <filename>inditokep.png</filename> indítóképet.
					Majd - feltéve, hogy a labirintus API-t a korábbi pontokban már
					felélesztettük - fordíthatjuk és futtathatjuk az alábbiak szerint:
					
                            <screen>
                            <![CDATA[
$ javac javattanitok/LabirintusAlkalmazás.java
$ java -splash:inditokep.png javattanitok.LabirintusAlkalmazás
                            ]]>
                            </screen>
					A futásról pillanatfelvételeket ugyancsak  
					<emphasis><link linkend="musztang">A Musztáng</link></emphasis>
					című pontban talál a kedves Olvasó.
					</para>
					
					<tip>					
					<title>A hős szorult helyzetben</title>
					<para>
					A <classname>LabirintusAlkalmazás</classname> osztály az 
					értesítési területen elhelyezett ikonon való kattintási
					eseményeket is feldolgozza: példaként a szorult helyzetbe
					került hőst teleportálja a kezdeti pozícióba:
					</para>
            <programlisting>
                <![CDATA[
            // amire ha duplán kattintunk, akkor
            értesítőIkon.addActionListener(
                    new java.awt.event.ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    // például szorult helyzetéből kimenekítve a
                    // hőst, visszadobjuk a kiindulási pozíciójába
                    hős.sor(9);
                    hős.oszlop(0);
                    repaint();
                }
            });                
                ]]>
            </programlisting>
					<para>Az API doksit figyelmesen tanulmányozó Olvasó 
					a 
					<classname>java.awt.TrayIcon</classname> 
					osztály leírásánál 
					láthatja, hogy a jelen példán túl, 
					az értesítési ikonhoz egy előugró menü is rendelhető. 
					</para>
					
					</tip>
					
                </sect4>
                
			</sect3>
                        
            </sect2>
        </sect1>
    
    </chapter>            
    
    <chapter>
    
    <chapterinfo>
        <keywordset>
			  <keyword>letöltés</keyword>
			  <keyword>telepítés</keyword>
			  <keyword>Java letöltése</keyword>
			  <keyword>Java telepítése</keyword>
              <keyword>API</keyword>                            
              <keyword>Java API</keyword>                            
              <keyword>Java</keyword>                            
              <keyword>Java ME</keyword>                            
              <keyword>Java SE</keyword>                            
              <keyword>NetBeans</keyword>                            
              <keyword>JDK</keyword>                            
              <keyword>JRE</keyword>                            
              <keyword>IDE</keyword>                            
              <keyword>NetBeans IDE</keyword>                                          
        </keywordset>
    </chapterinfo>

        <title>A példák kipróbálása</title>

    <sect1 id="telepites">
        <title>A Java telepítése gépünkre</title>
                
        <sect2>
            <title>A Java SE, Java ME fejlesztői csomag letöltése és beállítása</title>

            <para>
            Mindig a legfrissebb verziójú Java SE, ME fejlesztői csomagokat 
            használjuk.            
            A Java telepítését az aktuális Musztáng verzióval mutatjuk be. 
            A Musztáng verzió teljes és hivatalos neve: 
            Java Platform, Standard Edition 6, röviden Java SE 6. 
            Az ennek a platformnak megfelelő Java fejlesztői csomag a Java SE 
            Development Kit 6, röviden a JDK 6. Ezt kell letöltenünk, ha 
            fejleszteni akarunk, márpedig mi fejleszteni akarunk. A Java
            programok futtatásához a Java SE Runtime Environment 6 - Java Futtató
            Környezet, JRE 6 is 
            elegendő, de ez nem ad eszközöket, azaz lehetőséget a 
            Java programozásra. Természetesen a JDK 6 használata esetén nincs
            szükségünk a JRE-re.
            </para>
            
            <para>
            Alapvetően két lehetőségünk van: vagy parancssorban dolgozunk, vagy
            egy integrált fejlesztői környezetet használunk Java programjaink 
            írásához. Az előbbi lehetőség bemutatásával kezdjük, de mindenkinek a
            másodikat, a fejlesztői környezet használatát ajánljuk. Nemcsak
            a programozás kényelmi, hanem praktikus szempontjai miatt is. Ezekre
            a <application>NetBeans</application> fejlesztői környezet telepítésének leírásakor majd rámutatunk.
            Megjegyezhetjük, hogy a <application>NetBeans</application> letöltése kapcsán
            van olyan opciónk is, hogy egy olyan <application>NetBeans</application> IDE-t töltünk
            le, ami mellé be van téve egy komplett JDK is, erről a kombinált lehetőségről írunk majd a 
            <emphasis><link linkend="netbeans55">NetBeans IDE 5.5</link></emphasis> című pontban.
            </para>

            <sect3>
                <title>Java SE Linux környezetben</title>
            
                <para>
                    Keressük fel a SUN Java fejlesztőknek szánt webhelyét:
                    <ulink url="http://java.sun.com">http://java.sun.com</ulink>, itt
                    néhány kattintás után a <quote>Downloads</quote> alatt megtaláljuk a JDK 6-ot,
                    vagy akár eggyel is
                    a lap bal oldalának <quote>Popular Downloads</quote> ablakában, a 
                    <quote>Java SE 6 Beta 2</quote> link választásával a 
                    <ulink url="http://java.sun.com/javase/downloads/ea.jsp">http://java.sun.com/javase/downloads/ea.jsp</ulink>            
                    korai hozzáférés (mert a Musztáng még éppen béta) lapra jutunk, ahol a 
                    <quote>JDK 6 Beta 2</quote>
                    letöltését választjuk.    
                </para>

                <para>
                    A letöltési feltételek elfogadásának bekattintása után letölthetjük
                    a mi gépünkre szánt Javat.
                    Mivel mi most éppen egy 64 bites Linuxon (egy 
                    <application>Fedora Core 5 Linux</application>
                    operációs rendszerrel futó <hardware>Sun W1100z Workstation</hardware> 
                    gépen akarunk dolgozni, ami már egy 64 bites rendszer) így a 
                    <quote>Linux x64 Platform - Java(TM) SE Development Kit 6 Beta 2</quote>
                    alól 
                    Linux környezetre a
                    <quote>Linux x64 in self-extracting file</quote>,
                    <filename>jdk-6-beta2-linux-amd64.bin</filename>
                    letöltését választjuk.
                </para>

                <para>
                    Tegyük fel, hogy a <filename>jdk-6-beta2-linux-amd64.bin</filename>
                    állományt a <filename class="directory">/home/norbi/Java</filename>
                    könyvtárba mentettük, ekkor futási jogot adunk a letöltött állományra,
                    majd lefuttatjuk.
                <screen>
                    <![CDATA[
[norbi@niobe Java]$ ls -l
total 48740
-rw-r--r-- 1 norbi norbi 49854400 Sep  9 11:32 jdk-6-beta2-linux-amd64.bin
[norbi@niobe Java]$ chmod +x jdk-6-beta2-linux-amd64.bin
[norbi@niobe Java]$ ./jdk-6-beta2-linux-amd64.bin                    
                    ]]>
                </screen>     
                
                    Lelkes <keycap>SPACE</keycap> billentyű nyomkodás, 
                    majd a <userinput>yes</userinput> begépelése után majdnem 
                    készen is vagyunk. Még azt kell közölnünk a rendszerrel,
                    hogy hol van az éppen most kicsomagolt Java: mindig 
                    a kicsomagolt
                    <filename class="directory">/home/norbi/Java/jdk1.6.0</filename>
                    könyvtár <filename class="directory">bin</filename> könyvtárával kell
                    bővíteni az elérési utat
                    
                <screen>
                    <![CDATA[
[norbi@niobe Java]$ export PATH=/home/norbi/Java/jdk1.6.0/bin:$PATH
[norbi@niobe Java]$ java -version
java version "1.6.0-beta2"
Java(TM) SE Runtime Environment (build 1.6.0-beta2-b86)
Java HotSpot(TM) 64-Bit Server VM (build 1.6.0-beta2-b86, mixed mode)
                    ]]>
                </screen>     

                    igen, ez már a mi frissen feltett 6-os Javank.
                    
                </para>

                <tip>
                <title>Java kényelmesen</title>
                    <para>
                        Ha nem akarjuk a fenti <envar>PATH</envar> beállítást minden olyan ablakban
                        külön kiadni, ahol Javazni szeretnénk, akkor ezt a parancsot
                        érdemes bevenni egyszerű felhasználóként a 
                        <filename>.bash_profile</filename> állományunkba,
                        vagy esetleg rendszergazdaként a <filename>/etc/profile</filename>
                        állományba. Például ezt írjuk az említett állományok valamelyikének végére:
                <screen>
                    <![CDATA[
export PATH=/home/norbi/Java/jdk1.6.0/bin:$PATH
                    ]]>
                </screen>                              
                ezután, az újbóli bejelentkezésekkor már bármely kinyitott parancsablakból látszanak majd
                a Javas parancsok, például a <command>javac</command>, a fordítót indító,
                 vagy a <command>java</command>, a Java Virtuális Gépet indító parancs, az <command>idlj</command>, az IDL fordítót, vagy az <command>orbd</command>, az ORB szoftvert indító parancsok.                
                    </para>
                </tip>
                                    
            </sect3>

            <sect3>
                <title>Java SE Windows környezetben</title>

                <para>
                    Keressük fel a SUN Java fejlesztőknek szánt webhelyét:
                    <ulink url="http://java.sun.com">http://java.sun.com</ulink>, itt
                    néhány kattintás után a <quote>Downloads</quote> alatt megtaláljuk a JDK 6-ot,
                    vagy akár eggyel is
                    a lap bal oldalának <quote>Popular Downloads</quote> ablakában, a 
                    <quote>Java SE 6 Beta 2</quote> link választásával a 
                    <ulink url="http://java.sun.com/javase/downloads/ea.jsp">http://java.sun.com/javase/downloads/ea.jsp</ulink>            
                    korai hozzáférés (mert a Musztáng még éppen béta) lapra jutunk, ahol a 
                    <quote>JDK 6 Beta 2</quote>
                    letöltését választjuk.    
                </para>

                <para>
                    A letöltési feltételek elfogadásának bekattintása után letölthetjük
                    a mi gépünkre szánt Javat.
                    Most éppen egy Windowsra, így a 
                    <quote>Windows Platform - Java(TM) SE Development Kit 6 Beta 2</quote>
                    Windows környezetre a
                    <quote>Windows Offline Installation, Multi-language</quote>,
                    <filename>jdk-6-beta2-windows-i586.exe</filename>
                    letöltését választjuk.
                </para>

                <para>
                    A letöltés után a letöltött exe állományt lefuttatjuk.
                    Tegyük fel, hogy e futtatáskor a
                    <filename class="directory">c:\Program Files\Java\jdk1.6.0</filename>
                    könyvtárba telepítettük a Javat.
                    Ha (Start/Kellékek/)Parancssor-ból akarjuk használni a Javat, akkor
                    még azt kell közölnünk a rendszerrel,
                    hogy hol van az éppen most telepített Java: mindig 
                    a kicsomagolt
                    <filename class="directory">c:\Program Files\Java\jdk1.6.0</filename>
                    könyvtár <filename class="directory">bin</filename> könyvtárával kell
                    bővíteni az elérési utat
                    
                <screen>
                    <![CDATA[
C:\...> set PATH="c:\Program Files\Java\jdk1.6.0\bin";%PATH%
C:\Documents and Settings\norbi> java -version
java version "1.6.0-beta2"
Java(TM) SE Runtime Environment (build 1.6.0-beta2-b86)
Java HotSpot(TM) Client VM (build 1.6.0-beta2-b86, mixed mode, sharing)
                    ]]>
                </screen>     

                    igen, ez már a mi frissen feltett 6-os Javank.
                    
                </para>

                <para>
                    Ha nem akarjuk a fenti <envar>PATH</envar> beállítást minden olyan ablakban
                    külön kiadni, ahol Javazni szeretnénk, akkor a <envar>PATH</envar> bővítését
                    érdemes bevenni a Start/Vezérlőpult/Teljesítmény és karbantartás/
                    Rendszer/Speciális fül/Környezeti változók gomb kattintása után
                    a felhasználói vagy a rendszerváltozók közé.
                </para>
                                    
                <tip>
                <title>Java 6</title>
                    <para>
                    A kézikönyv írása végén vált elérhetővé a - béta2 és az RC után a - stabil
                    Java 6. 
                    </para>
                <para>
                    Keressük fel a SUN Javas webhelyét:
                    <ulink url="http://java.sun.com">http://java.sun.com</ulink>, itt
                    néhány kattintás után (a <quote>Downloads</quote> menüpont alatt 
                    a <quote>Java SE</quote> link választásával) a                      
                    <ulink url="http://java.sun.com/javase/downloads/index.jsp">http://java.sun.com/javase/downloads/index.jsp</ulink>, a 
                    <quote>Java SE Downloads</quote> című lapra jutunk, ahonnan
                    letölthetjük a parancssoros <quote>JDK 6</quote>-ot vagy 
                    a NetBeans fejlesztői környezettel együtt elérhető
                    <quote>JDK 6 with NetBeans 5.5</quote> név alatt belinkelt JDK-t.
                    A feltételek elfogadásának beixelése után letölthetjük a kívánt 
                    platformhoz (operációs
                    rendszerhez) tartozó Javat.
                </para>
                    
                </tip>
                
            </sect3>


            <sect3 id="api_doksi">
                <title>A Java dokumentáció, azaz az API doksi letöltése</title>
                
                <para>
                    A fejlesztői csomag letöltésénél arra figyeltünk, hogy
                    mindig a legfrissebb verziójú Java SE, ME fejlesztői csomagokat
                    használjuk. A dokumentációnál pedig arra kell tekintettel lennünk, hogy
                    megfeleljen a használt csomag verziójának. Ez nem nehéz, mert
                    azon a lapon, ahonnan a fejlesztői csomagot letöltjük, megtaláljuk a
                    dokumentációt is.
                </para>
                
                <para>
                    Keressük fel a SUN webhelyét:
                    <ulink url="http://java.sun.com">http://java.sun.com</ulink>, itt
                    néhány kattintás után a <quote>Downloads</quote> alatt megtaláljuk a JDK 6-ot,
                    vagy akár eggyel is
                    a lap bal oldalának <quote>Popular Downloads</quote> ablakában, a 
                    <quote>Java SE 6 Beta 2</quote> link választásával a 
                    <ulink url="http://java.sun.com/javase/downloads/ea.jsp">http://java.sun.com/javase/downloads/ea.jsp</ulink>            
                    korai hozzáférés (mert a Musztáng még éppen béta) lapra jutunk, ahol a 
                    <quote>Java SE 6 Beta 2 Documentation</quote>
                    letöltését választjuk.    
                </para>

                <para>
                    A letöltési feltételek elfogadásának bekattintása után letölthetjük
                    a természetesen platformfüggetlen dokumentációt.
                    <quote>Platform - Java(TM) SE Development Kit Documentation 6 Beta 2</quote>
                    Linux környezetre a
                    <quote>Java SE Development Kit Documentation 6 Beta 2</quote>,
                    <filename>jdk-6-beta2-doc.zip</filename>
                    letöltését választjuk.
                </para>
                
                <para>
                    Ezt a letöltött állományt kicsomagolva megtaláljuk benne a HTML
                    dokumentációt, azaz egy böngészővel tudjuk nézegetni.
                    Ha az <filename class="directory">api</filename> 
                    könyvtárának <filename>index.html</filename> állományát kinyitjuk,
                    akkor máris látjuk a szokásos három frame-be szervezett 
                    Java SE API dokumentációt.
                </para>
                
                <para>
                    A SUN Javas <ulink url="http://java.sun.com">http://java.sun.com</ulink> webhelyén
                    természetesen böngészhetjük on-line is a Java ME, SE vagy EE dokumentációt.
                    Illetve arra hívjuk még fel a figyelmet, hogy a 
                    <application>NetBeans Mobility</application> telepítése után a 
                    Java ME API dokumentációt a 
                    <filename>netbeans-5.5\mobility7.3\emulators-inst\wtk22_win.zip</filename> és
                    ezen a zip állományon belül belül az                     
                    <filename>emulator\wtk22\docs\api\midp</filename> könyvtárban is
                    megtaláljuk.                                        
                </para>
                
                
            </sect3>            
            
            <sect3>
                <title>Java ME</title>

                <para>
                    A Java ME beállításának egyik módja a <application>Sun Java Wireless Toolkit</application>
                    letöltése, de mi inkább a <application>NetBeans</application> környezeten belüli
                    <application>Netbeans Mobility</application> használatát javasoljuk a mobilos 
                    fejlesztésekhez. Számos okból,
                    amiket majd a 
                    következő, a <application>NetBeans</application> beállításáról szóló 
                    részben bontunk ki,
                    miközben 
                    kitérünk a <application>Netbeans Mobility</application> letöltésére.                    
                </para>

                <para>
                    A <application>Sun Java Wireless Toolkit</application> letöltése kapcsán keressük fel 
                    a SUN webhelyét:
                    <ulink url="http://java.sun.com">http://java.sun.com</ulink>, itt
                     a <quote>Downloads</quote> alatt a 
                    <quote>Java ME</quote> linket követve a 
                    <ulink url="http://java.sun.com/javame/downloads/index.jsp">http://java.sun.com/javame/downloads/index.jsp</ulink> lapra jutunk, 
                    ahonnan mindig a legfrissebb, most éppen a 
                    <quote>Sun Java Wireless Toolkit 2.5 for CLDC, Beta</quote>            
                    csomagot töltsük le.                            
                </para>

                <para>
                    Külön állományt kell letöltenünk attól függően, hogy Linux vagy
                    Windows környezetben akarunk-e dolgozni. Mindkét esetben a 
                    Java SE telepítéséhez hasonlóan kell eljárnunk, azaz futtatni
                    kell a letöltött állományt. De itt nincs szükség az elérési út (azaz a <envar>PATH</envar> környezeti változó)
                    állítására. 
                    </para>
                
                
            </sect3>            
            
            <sect3 id="netbeans">
            
                <title>A NetBeans integrált fejlesztői környezet letöltése és használata</title>
                        <blockquote>
					<attribution>
						James Gosling
						<citetitle>
							<citation>GOSLING INTERJÚ</citation>
						</citetitle>
					</attribution>
					<para>
						„Egy jó ideje már, hogy áttértem a NetBeans IDE használatára.”
					</para>
				</blockquote>
                
                <para>
                A <application>NetBeans</application> integrált fejlesztői környezetet 
                (<application>NetBeans IDE</application>) a 
                <ulink url="http://www.netbeans.org/">http://www.netbeans.org/</ulink>
                webhelyről tölthetjük le. De a <application>NetBeans IDE</application> letöltés be szokott 
                lenni linkelve a SUN Javas 
                <ulink url="http://java.sun.com">http://java.sun.com</ulink>
                webhelyére is, a lap bal oldalának 
                <quote>Popular Downloads</quote> ablakába. Itt a 
                <quote>NetBeans IDE</quote> linket választva a 
                <ulink url="http://www.netbeans.org/downloads/index.html">http://www.netbeans.org/downloads/index.html</ulink>
                lapra kerülünk. Ha itt a
                <quote>NetBeans IDE, Mobility Pack and Profiler 5.0 downloads</quote>
                5.0 verziójú NetBeans IDE-t választjuk, akkor a 
                <ulink url="http://www.netbeans.info/downloads/download.php?type=5.0">
                    http://www.netbeans.info/downloads/download.php?type=5.0
                </ulink>
                lapra kerülve a kívánt operációs rendszer kiválasztása után a 
                <quote>NetBeans IDE 5.5 Beta 2 Installer</quote>-t és a 
                <quote>NetBeans Mobility Pack 5.0 Installer</quote>-t töltsük le.
                Mindkettő futtatható, nincs más dolgunk, mint (a fenti sorendben) 
                lefuttatni őket. De inkább a már elérhető 5.5 változatot töltsük le!
                A
                <ulink url="http://www.netbeans.org/downloads/index.html">http://www.netbeans.org/downloads/index.html</ulink>
                lapon a 
                <quote>NetBeans IDE 5.5 Beta 2</quote>
                választásával, a
                <ulink url="http://www.netbeans.info/downloads/download.php?type=5.5b2">
                    http://www.netbeans.info/downloads/download.php?type=5.5b2
                </ulink>
                lapra kerülve a kívánt operációs rendszer kiválasztása után a 
                <quote>NetBeans IDE 5.5 Beta 2 Installer</quote>-t és a 
                <quote>NetBeans Mobility 5.5 Beta 2 Installer</quote>-t töltsük le.
                
                </para>

                <para>
			 A <application>NetBeans</application> letöltése kapcsán
            van olyan opciónk is, hogy egy olyan <application>NetBeans</application> IDE-t töltünk
            le, ami mellé be van téve egy komplett JDK is, erről a kombinált lehetőségről írunk majd a következő
            <emphasis><link linkend="netbeans55">NetBeans IDE 5.5</link></emphasis> című pontban.
                </para>

                <para>
                    Miért válasszuk a fejlesztéshez a <application>NetBeans IDE</application>-t a parancssoros
                    fejlesztéssel szemben? Számos okból. Ismertessünk ezek közül néhányat:
                    
                 <itemizedlist>
                    <listitem>
                      <para>a fordítási hibák figyelése és jelzése a szövegszerkesztőben folyamatos
                      </para>
                    </listitem>
                    <listitem>
                      <para>a szövegszerkesztő adja a szokásos kényelmi szolgáltatásokat, mint például a csomag és osztálynevek, példány és metódusnevek automatikus beírása
                      </para>
                    </listitem>
                    <listitem>
                      <para>szervletek írásánál könnyű tesztelési (menüből kattintható) lehetőséget biztosít
                      </para>
                    </listitem>                    
                    <listitem>
                      <para>mobil fejlesztéseknél különösen fontos, hogy az IDE tartalmazzon
                      egy megfelelő verziójú obfuszkátort, amit így nem kell külön letölteni és
                      beállítani.
                      </para>
                    </listitem>                    
                    </itemizedlist>
                </para>
                    
            </sect3>            
            
            <sect3 id="netbeans55">
                <title>A NetBeans IDE 5.5</title>
                
                <para>
                    A kézikönyv írása közben vált elérhetővé a <application>NetBeans IDE 5.5</application> immár nem
                    béta verziója. Ezt a                    
                    <ulink url="http://java.sun.com/javase/downloads/index.jsp&#xD;&#xA;">http://java.sun.com/javase/downloads/index.jsp</ulink>
                    lapon a <quote>JDK 5.0 Update 9 with NetBeans 5.5</quote> linket követve, vagy közvetlenül a                     
                    <ulink url="http://java.sun.com/j2se/1.5.0/download-netbeans.html&#xD;&#xA;">http://java.sun.com/j2se/1.5.0/download-netbeans.html</ulink>, 
a  
<quote>Download J2SE Development Kit 5.0 Update 9 with NetBeans IDE 5.5 Bundle</quote>
lapról tölthetjük le. Ennek az érdekessége, mint ahogyan az a link nevéből is kiderül, hogy
nemcsak a <application>NetBeans</application> környezetet, hanem egyben a megfelelő JDK 5 csomagot is letölthetjük.
A linket követve Linux alá a <quote>J2SE(TM) and NetBeans(TM) IDE Cobundle (J2SE 1.5.0 U9 / NB 5.5) Linux</quote>,
a <filename>jdk-1_5_0_09-nb-5_5-linux.bin</filename> 114.40 megás állományt töltsük le. Windows alá pedig a
<quote>J2SE(TM) and NetBeans(TM) IDE Cobundle (J2SE 1.5.0 U9 / NB 5.5) Windows</quote>,
a <filename>jdk-1_5_0_09-nb-5_5-win.exe</filename> 114.27 megás állományt.
                </para>

                <para>
                Az 5.5 IDE környezetnek megfelelő <application>NetBeans Mobility</application> csomagot a 
                <ulink url="http://www.netbeans.info/downloads/index.php">http://www.netbeans.info/downloads/index.php</ulink>
                lap <quote>NetBeans Mobility Pack 5.5 Download</quote> linkjét követve érhetjük el.
                </para>

			</sect3>
            
        </sect2>
    </sect1>

    <sect1 id="pelda_futtatas">
        <title>A példaprogramok futtatásáról általában</title>

        <para>A példák teljes kódját közöljük a kézikönyvben. Tipikusan a közlés helyén példát mutatunk a programok
        felélesztésére és futtatására is. Általában annyit mondhatunk, hogy - tapasztalataink szerint - az Olvasónak a példák
        kipróbálásával kapcsolatban az a jellemző problémája, hogy a közölt forráskódrészleteket nem kellő
        gondossággal jelöli ki és illeszti be kedvenc szövegszerkesztőjébe, amiből fordítási hibák következnek. 
        Tipikusan ilyen, hogy a több oldalas programból csak részeket jelöl ki Olvasó, vagy lehagyja néhány sor
        végét a kijelölésből. Illetve, ha a kijelölés a pdf olvasóban történik, akkor az olvasótól és a beállításaitól
        függően akár oldalszámok is lehetnek a
        kijelölésben, amik a program szövegében idegen elemek, így természetesen fordítási hibát okoznak. 
        Ezért javasoljuk, hogy a kézikönyv böngészhető változatából másolja ki az Olvasó a forráskódokat.</para>

<tip>
<title>Fordítás Linux alatt</title>

<para>
                    Kérdés: Linux (Fedora Core 5) alatt nem tudom lefordítani az 
                    ékezetes betűket tartalmazó 
                    osztályokat.
                </para>
                    <para>
                        Válasz: Rendszergazdaként a 
                        <filename>/etc/sysconfig/i18n</filename> állományban állítsuk magyarra
                        a lokális környezetet! Tehát a <filename>/etc/sysconfig/i18n</filename>
                        állomány a következőket tartalmazza:
                            <screen>
                            <![CDATA[
LANG="hu_HU.ISO-8859-2"
LC_ALL="hu_HU.ISO-8859-2"                            
                            ]]>
                            </screen>                             
                    </para>    
                <para>
                    Kérdés: Linux (Fedora Core 6) alatt nem tudom lefordítani az 
                    ékezetes betűket tartalmazó 
                    osztályokat.
                </para>
                    <para>
                        Válasz: Ha maguk az állomány nevek rendben vannak, mert mondjuk eleve
                        Linux alatt készítettük el őket, akkor elegendő a fordításnál az
						<parameter class="command">encoding</parameter> kapcsoló
						használata, például:
                            <screen>
                            <![CDATA[
$ javac -encoding ISO-8859-2 javattanitok/LabirintusAlkalmazás.java                            
                            ]]>
                            </screen>                             
                    </para>    

</tip>
        
    </sect1>

    </chapter>

    <appendix>

    <appendixinfo>
        <keywordset>
			  <keyword>Java verziók</keyword>
              <keyword>JDK</keyword>                            
              <keyword>JDK 5</keyword>                            
              <keyword>JDK 6</keyword>                            
              <keyword>JDK 7</keyword>                            
              <keyword>Java</keyword>                            
              <keyword>Java 5</keyword>                            
              <keyword>Java 6</keyword>                            
              <keyword>Java 7</keyword>                            
              <keyword>Java ME</keyword>                            
              <keyword>Java SE</keyword>                            
              <keyword>Tigris</keyword>                            
              <keyword>Delfin</keyword>                            
              <keyword>Musztáng</keyword>                            
              <keyword>Tiger</keyword>                            
              <keyword>Dolphin</keyword>                            
              <keyword>Mustang</keyword>                            
        </keywordset>
    </appendixinfo>
    
        <title>Java mellékletek</title>
        
    <sect1 id="tigris_delfin">
        <title>A Java verziók újdonságai a tigristől a delfinig</title>
        
                    <para>Most részletesebben kibontjuk
                    a <emphasis><link linkend="tortenet">Java történelemről</link></emphasis> szóló 
                    korábbi részt abban az esetben, amikor
                    időtengelyen előre haladunk: a közeli múlt (2004 vége, 2005 eleje) a 
                    Java 5, a Tiger. A jelen (2006 nyara - 2007 tavasza) a Java 6, a Mustang. 
                    A közeli jövő (2008 második fele) a Java 7, a Dolphin. 
                    A következő három pontban mindhárom verzió esetén megnézünk 
                    néhány szívdobogtató finomságot.</para>

                    <sect2 id="tortenet_elore">
                        <title>A tigris</title>
                        
                        <para>A Java platformnak ez a verziója már a közeli múlt, így részletesebben nem is foglalkozunk vele, hanem csak az általa bevezetett újdonságokat említjük röviden. Ezt viszont meg kell tennünk, mert nagy dolgok történtek ennek a verziónak a bevezetésével.</para>
                        <para>A Java Tigris verziója nemcsak az API világában hozott újdonságokat, maga a nyelv is új elemekkel bővült: </para>
                        <orderedlist numeration="lowerroman">
                            <listitem>
                                <para>megjelent a generikus, </para>
                            </listitem>
                            <listitem>
                                <para>egy újfajta for ciklus: az iteráló ciklus, </para>
                            </listitem>
                            <listitem>
                                <para>immár a primitív Java típusok automatikusan csomagolódnak be és vissza csomagoló osztályaikba,</para>
                            </listitem>
                            <listitem>
                                <para>megjelent a felsorolásos típus,</para>
                            </listitem>
                            <listitem>
                                <para>lehetőség nyílt változó paraméterszámú függvények írására,</para>
                            </listitem>
                            <listitem>
                                <para>és statikus tagok olyan importjára, ami elhagyhatóvá teszi a tagra vonatkozó osztálynév minősítést.</para>
                            </listitem>
                        </orderedlist>
                        <para>A generikus használatával olyan új típusokat (osztályokat) hozhatunk létre, melyek még maguknál a típusoknál (osztályoknál) is általánosabb szintet hoznak programunk világába. Mert a generikus típus egy olyan általános típus, amit egy típussal lehet paraméterezni, azaz konkréttá tenni. Például ha van egy generikus (általános) lista típusom, akkor annak típus paramétere az lehet, hogy ennek a listának az elemei milyen típusúak, tehát az általános lista típusból konkretizált listám milyen típusokkal működjön majd... Vagy készíthetek olyan saját generikus (általános) számológép típust, ami ugyanúgy teszi a dolgát: összead, szoroz, de egyszer egészekkel, máskor törtekkel, attól függően, hogy az <classname>Integer</classname> vagy a <classname>Double</classname> típussal paraméterezve, konkretizálva készítettem-e el. 
                        (A generikusról általános olvasmányként lásd a <citation>PICI PROGRAMOZÁS I JEGYZET</citation> jegyzetet.)</para>
                        <para>A Tigris előtti Javaban a 
                        (<classname>java.util.</classname>)<classname>List</classname> objektumba bármilyen más objektumot betehettem, akár különbözőeket is, de amikor ki akartam venni az elemeket, akkor tudnom kellett, hogy milyen típusúak. Ha ennek kapcsán valami hiba történt, például mégsem az volt betéve a listába, amit gondolt a programozó... hát, akkor az csak a program futása közben derült ki. A Tigristől ez a <classname>List</classname> egy generikus interfész, tehát immár egy típussal paraméterezhető, konkretizálható lista. Ez azért jó, mert már a fordítási időben kiderül, ha nem megfelelő típusú elemeket akarunk betenni a listába vagy kivenni abból.</para>
                        <para>Játsszunk egy kicsit a generikussal, terjesszük ki a 
                        <classname>javattanitok.labirintus.Labirintus</classname> osztályt úgy, hogy a labirintusunk szereplői ne tömbök, hanem listák legyenek. Mi ezt a kiterjesztést 
                        a <classname>javattanitok.labirintus.GenerikusLabirintus</classname> osztályban tettük meg. A példánytagokat bemutató részben a <classname>Labirintus</classname> osztály 

                            <programlisting>
                            <![CDATA[
protected Kincs [] kincsek;
protected Szörny [] szörnyek;
                            ]]>
                            </programlisting>
                                    
                        kincseit és szörnyeit így módosítottuk a 
                        <classname>GenerikusLabirintus</classname> osztályban:
                        
                            <programlisting>
                            <![CDATA[
protected java.util.List<Kincs> kincsek;
protected java.util.List<Szörny> szörnyek;
                            ]]>
                            </programlisting>
                            
                        Például a kincsek referenciát egy kincs objektumokat tartalmazó listaként deklaráljuk, az által, hogy a generikus lista típus paramétere itt a <classname>Kincs</classname> típus, ezt jelöli a &lt;Kincs&gt;. Tehát a generikus listát a <classname>Kincs</classname> típussal konkretizáltuk. 
                        </para>

                        <para>Az elkészített <classname>GenerikusLabirintus</classname> osztályt a 
                        <classname>javattanitok.GenerikusLabirintusVilág</classname>
                         osztályban keltettük életre. A <classname>GenerikusLabirintus</classname> osztályba bevettünk néhány olyan metódust is, aminek a labirintus tekintetében nincs gyakorlati funkciója, de játszik kicsit a bevezetett generikus listáinkkal:</para>

                            <programlisting>
                            <![CDATA[
public void nyomtat1(java.util.List<?> lista) {
    for(Object objektum: lista)
        System.out.println(objektum);
}
public void nyomtat2(java.util.List<? extends Szereplő> lista) {
    for(Szereplő szereplő: lista)
        System.out.println(szereplő);
}
public <E> void nyomtat3(java.util.List<E> lista) {
    for(E e: lista)
        System.out.println(e);
}
                            ]]>
                            </programlisting>
                            
                        <para>az osztályt elláttuk indító main függvénnyel is, arra az esetre, ha nem a labirintusban akarjuk kipróbálni a fenti három módszert. Mit csinálnak?</para>
                        <para>Az előző pontban a <classname>GenerikusLabirintus</classname> osztály írásakor már ezt a ciklust használtuk, külön kiemelhető az ilyen egymásba ágyazás esetén a jó olvashatóság:

                            <programlisting>
                            <![CDATA[
for(Szörny szörny: szörnyek)
    for(Kincs kincs: kincsek)
        if(kincs.megtalált(szörny))
            szörny.megtaláltam(kincs);
                            ]]>
                            </programlisting>
                            
                        Az iteráló ciklus egyébként tömbökre is alkalmazható, erre is példát 
                        mutat a <classname>GenerikusLabirintus</classname> azzal, ahogyan a <classname>Labirintus</classname>
                        </para>

                            <programlisting>
                            <![CDATA[
boolean vanKincs(int sor, int oszlop) {

    boolean van = false;

    for(int i=0; i<kincsek.length; ++i)
        if(sor == kincsek[i].sor()
        && oszlop == kincsek[i].oszlop()
        && !kincsek[i].megtalálva()) {
        van = true;
        break;
        }

    return van;
}
                            ]]>
                            </programlisting>
                            
                        <para>módszerét felüldefiniálja: </para>
                        
                            <programlisting>
                            <![CDATA[
boolean vanKincs(int sor, int oszlop) {

    boolean van = false;

    for(Kincs kincs: kincsek)
        if(sor == kincs.sor()
        && oszlop == kincs.oszlop()
        && !kincs.megtalálva()) {
        van = true;
        break;
        }

    return van;
}
                            ]]>
                            </programlisting>
                            

                        <para>ami felüldefiniálást egyébként kénytelen is megtenni, hiszen a <classname>GenerikusLabirintus</classname> osztálynak már az új szörny és kincs listákkal kell dolgoznia!</para>
                        </sect2>
                        
                        <sect2 id="musztang">
                            <title>A Musztáng</title>
                         
                        <para>Azaz a teljes és hivatalos nevén: Java Platform, Standard Edition 6, röviden Java SE 6. Az ennek a platformnak megfelelő Java fejlesztői csomag a Java SE Development Kit 6, röviden a JDK 6. Ezt kell letöltenünk, ha fejleszteni akarunk, a letöltés tekintetében lásd 
                        <emphasis><link linkend="telepites">A Java telepítése gépünkre</link></emphasis> című pontot.</para>
                        <para>A Musztángban  -  szemben az előzővel, a Tigrissel  -  nem történtek változások magát a Java nyelvet illetően, ellenben például a Musztáng Java OO világ gyarapodott. Ezt a gyarapodást mi a GUI kapcsán tekintjük át, ahol több látványos újításról tudunk örömhírt adni. Részletesebben az értesítési területhez való hozzáféréssel és az indítóképernyő használatával foglalkozunk a következő pontokban.</para>
                        <para>A Musztángtól lehetőségünk van a programunkhoz a szokásos menüvel ellátható gyorsindító ikont (<classname>java.awt.TrayIcon</classname>) elhelyezni az értesítési területen (<classname>java.awt.SystemTray</classname>). Arra az egyszerű esetre mutatunk példát, amikor a programunk futásakor elhelyezi ide a megfelelő ikonját és feldolgozza az ikonról érkező legegyszerűbb eseményt: példaként tehát, ha duplán kattintunk, akkor kimenti hősünket esetleges szorult helyzetéből és visszadobja a labirintus kezdő pontjába.

                            <programlisting>
                            <![CDATA[
// Ha a rendszerben támogatott az értesítési terület
if (java.awt.SystemTray.isSupported()) {
    // akkor egy kis 16x16 pixel méretű
    java.awt.Image ikonKép = new javax.swing.ImageIcon
            ("ikon.png").getImage();
    // értesítő ikont
    java.awt.TrayIcon értesítőIkon =
            new java.awt.TrayIcon(ikonKép,
            "Javat tanítok labirintus");
    // most mi is kiteszünk
    try {
        java.awt.SystemTray.getSystemTray().
                add(értesítőIkon);
    } catch (java.awt.AWTException e) {
        System.out.println("Értesítő ikon kitétele: "
                + e);
    }
    // amire ha duplán kattintunk, akkor
    értesítőIkon.addActionListener(
            new java.awt.event.ActionListener() {
        public void actionPerformed(ActionEvent e) {
            // például szorult helyzetéből kimenekítve a
            // hőst, visszadobjuk a kiindulási pozíciójába
            hős.sor(9);
            hős.oszlop(0);
            repaint();                    
        }
    });            
}
                            ]]>
                            </programlisting>
                        </para>
                        
                        <para>Ha programunk indulása a szokásostól több időt vesz igénybe, mert sok erőforrást, például képeket kell betöltenie, bonyolult adatszerkezeteket, inicializálásokat elvégeznie, akkor elegáns ennek az időnek a múlását demonstráló képernyővel informálni, szórakoztatni a felhasználót. A Mustang erre lehetőséget ad. A legegyszerűbb módja ennek, hogy amikor a programunkat átadjuk a Java Virtuális Gépnek, akkor a <parameter class="command">-splash</parameter> kapcsolót használva az indító képernyőnek (<classname>java.awt.SplashScreen</classname>) szánt képet is átadjuk. A következőkben példaként a 
                        <classname>LabirintusAlkalmazás</classname> programunkat ruházzuk fel ezzel a lehetőséggel. </para>
                        <para>Ezt az indító képet készítettük, alul a folyamatjelzőt (progress bar) pusztán a rajzolóprogrammal tettük rá, hogy le tudjuk olvasni a kívánt koordinátákat.

                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/kep/inditokep_terv.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A labirintus játékot indító kép terve.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        </para>                                                                        
                        
                        <para>Minél közelebb járunk ahhoz, hogy programunk befejezze az indulás kapcsán elvégzett időigényes dolgait, annál nagyobb sárga, hosszú, lapos téglalapot rajzolunk majd. Szükségünk lesz a téglalap bal felső sarkának a koordinátáira és a téglalap szélességére, magasságára. Ezeket a következő ábra szerint olvassuk le.
                        
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/prog/inditokep_koord.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Koordináták az indítóképen.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        </para>                                                                        
                        
                        <para>A 8. oszlop 285. sora lesz a téglalap bal felső sarka, a szélessége 382 , a magassága pedig 10 pixel.</para>

                        <para>
                            <programlisting>
                            <![CDATA[
// Hozzáférünk az indító képernyőhöz
java.awt.SplashScreen indítóKépernyő
        = java.awt.SplashScreen.getSplashScreen();
// Ha sikerül, azaz, ha java -splash:kép állomány neve
// formában indítottuk és még látszik a kép
if(indítóKépernyő != null) {
    // akkor rajzolni fogunk rá
    java.awt.Graphics2D g = indítóKépernyő.createGraphics();
    // némi szöveget, amit akár a rajzolóprogrammal is
    // ráírhattunk volna            
    java.awt.Font font1 = new java.awt.Font("Sans",
            java.awt.Font.BOLD, 20);
    java.awt.Font font2 = new java.awt.Font("Monospaced",
            java.awt.Font.BOLD, 12);
    g.setFont(font1);
    // világosabb sárgával
    g.setColor(new java.awt.Color(250, 255, 138));
    g.drawString("Javat tanítok labirintus", 8, 240);
    g.setFont(font2);
    g.drawString("Bátfai Norbert", 10, 265);
    g.drawString("nbatfai@inf.unideb.hu", 10, 280);            
    // és rajzolunk egy a konkrét kép méretéhez igazított
    // progress bar szerűséget (kommentben az indító
    // képernyő méretéhez relatív adatok)
    int sz = 382; // indítóKépernyő.getSize().width-10;
    int barSzélesség = sz/10;
    int m = 10; // indítóKépernyő.getSize().height;
    int barMagasság = 6;
    // itt szimuláljuk a játék időigényes dolgainak
    // betöltését, 10 x fél másodperig altatjuk majd
    // a szálunkat
    for(int i = 0; i<10; ++i) {
        // és ennek megfelelően frissítjük mit
        // mutasson a progress bar-unk
        g.setColor(java.awt.Color.WHITE);
        g.drawRect(8, 285, //5, m-20,
                10*barSzélesség, barMagasság);
        g.fillRect(8, 285, //5, m-20,
                10*barSzélesség, barMagasság);
        g.setColor(java.awt.Color.YELLOW);
        g.drawRect(8, 285, //5, m-20,
                10*barSzélesség, barMagasság);
        g.fillRect(8, 285, //5, m-20,
                (i+1)*barSzélesség, barMagasság);
        indítóKépernyő.update();
        try {
            // a fél másodperces altatás
            // ez szimulálja pl., hogy töltjük be
            // a már hatalmas labirintus játékunk
            // képerőforrásait, készítjük a megfelelő
            // adatszerkezeteket stb.
            Thread.sleep(500);
        } catch(Exception e) {}
    }
}
                            ]]>
                            </programlisting>
                        </para>
                        
                        <para>Végül lássuk munkánk eredményét! Például Linuxon az XFCE 
                        felület alatt nézzük meg az indítóképernyőt az alábbi képeken.</para>

                        <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/kep/inditokepes_kepernyo.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A labirintus indítóképpel indítva.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        </para>              

                        <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/kep/inditokepes_kepernyo2.png" />
                            </imageobject>
                            <textobject>
                                <phrase>A labirintus indítóképe.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        </para>              

                        <para>Illetve ugyancsak Linuxon a GNOME felületet használva az indítóikont.</para>

                        <para>
                        <inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="images/kep/inditokepes_kepernyo3.png" />
                            </imageobject>
                            <textobject>
                                <phrase>Az 32x32 pixeles indítóikon megjelenése.</phrase>
                            </textobject>	
                        </inlinemediaobject>
                        </para>              
                        
                    </sect2>
                    
                    <sect2>
                        <title>A delfin</title>
                        
                        <para>A Delfint 2008 második félévére várjuk, 
                            de a <ulink url="http://java.sun.com/">http://java.sun.com</ulink> 
                        lapjain előzetesen olvashatunk az újdonságokról. A nyelv változása tekintetében a metódus referenciák bevezetését nagyon izgalmasnak tartjuk. (Ezeket a bevezetendő metódus referenciákat például a C nyelvbeli függvény mutatókkal érezzük rokonnak.) A programok szervezése területén a csomagszerkezet és a jar állományok újítása várható... és még sorolhatnánk a finomságokat: a <ulink url="http://mustang.dev.java.net/">http://mustang.dev.java.net</ulink> lapot figyelve lehetünk naprakészek. </para>
                        
                    </sect2>

    </sect1>                
                    
    <sect1 id="elso_java">
        <title>Az első Java tapasztalatok</title>
        
            <para>
                Ebben a mellékletben ismertetjük az egyetemünkön a levelező informatika
                tanárképzésbeli WWW alkalmazások fejlesztése című tárgy első óráját.
                Ennek a tárgynak a példái jelen pillanatban a Java nyelv használatára 
                épülnek. De napjainkban, egy átmeneti állapotban, amikor a hallgatók 
                (akik tipikusan továbbképzésként résztvevő gyakorló pedagógusok) a 
                képzés
                során már nem Pascalban programoznak, de még nem is Javaban, szükséges
                némi gyakorlati Java programozás alapozás is. Ezt az alapozást ismertetjük
                ebben a mellékletben, mint a programozásban egyébként járatos 
                informatikusoknak
                szánt Java bevezetőt.
            </para>    

            <para>A következő <classname>Szerver</classname> osztály kódját
            másoljuk a <filename>Szerver.java</filename> állományba!
                            <programlisting>
                            <![CDATA[
public class Szerver {
    public static void main(String [] args) {
        try {
            java.net.ServerSocket serverSocket =
                    new java.net.ServerSocket(2006);
            while(true) {
                java.net.Socket socket = serverSocket.accept();
                
                java.io.PrintWriter kimenőCsatorna =
                        new java.io.PrintWriter(socket.getOutputStream());
                
                kimenőCsatorna.println("Helló, Világ!\n");
                kimenőCsatorna.flush();
                
                socket.close();
            }
        } catch(java.io.IOException ioE) {
            ioE.printStackTrace();
        }
    }
}                            
                            ]]>
                            </programlisting>
            </para>    


            <para>A következő <classname>Kliens</classname> osztály kódját
            pedig másoljuk a <filename>Kliens.java</filename> állományba!
                            <programlisting>
                            <![CDATA[
public class Kliens {
    public static void main(String[] args) {
        try {
            java.net.Socket socket
                    = new java.net.Socket("localhost", 2006);
            
            java.io.BufferedReader bejövőCsatorna =
                    new java.io.BufferedReader(
                    new java.io.InputStreamReader(socket.getInputStream()));
            
            System.out.println(bejövőCsatorna.readLine());
            
            socket.close();
            
        } catch(java.io.IOException ioE) {
            ioE.printStackTrace();
        }
    }
}                            
                            ]]>
                            </programlisting>
            </para>    


            <para>Most két külön ablakban lépjünk be abba a könyvtárba, ahová a
            fenti két forrásállományt másoltuk, legyen ez most mondjuk a
            <filename>Munkakönyvtár</filename> nevű munkakönyvtár, majd az egyik
            ablakban a szervert, a másikban a klienst fordítsuk és futtassuk!  
            
                            <screen>
                            <![CDATA[
[norbi@omega Munkakönyvtár]$ javac Szerver.java 
[norbi@omega Munkakönyvtár]$ java Szerver
                            ]]>
                            </screen>
                            
                            <screen>
                            <![CDATA[
[norbi@omega Munkakönyvtár]$ javac Kliens.java 
[norbi@omega Munkakönyvtár]$ java Kliens
Helló, Világ!
[norbi@omega Munkakönyvtár]$ java Kliens
Helló, Világ!
[norbi@omega Munkakönyvtár]$ java Kliens
Helló, Világ!
                            ]]>
                            </screen>
                            
            </para>    
            
            <para> Most pedig röviden beszéljük át a forrásokat! Tartsuk közben 
            szem előtt <emphasis><link linkend="api_olvasasa">A források olvasásáról</link></emphasis>
            című pont felhívását. Az API dokumentáció telepítésének leírását 
            <emphasis><link linkend="api_doksi">A Java dokumentáció, azaz az API doksi letöltése</link></emphasis> című pontban találjuk meg.
            </para>    
            
            <para>             
            Az internet születésének hajnalán, valamikor az ARPANET korszakban vált 
            de facto szabvánnyá a TCP/IP, amihez a Berkeley egyetemen kifejlesztettek
            egy programozói interfészt, ez a socket interfész. A Java is lehetőséget ad
            ezen az absztrakciós szinten dolgozni, az ezt lehetővé tevő osztályok a 
            <classname>java.net</classname> csomagban kaptak helyet. Az API dokumentációval 
            párhuzamosan olvassuk a program szövegét!
            </para>    
            
            <para>                                     
                           A <classname>Szerver</classname> osztály indító <function>main()</function>
                           függvényében megpróbáljuk lefoglalni a 
                           2006 számú szerver socketet, 
                           megpróbálunk létrehozni egy 
                           <classname>ServerSocket</classname>, vagyis egy szerver
                           socketet absztraháló Java objektumot a 2006 sorszámú
                           
                        <programlisting>
                            <![CDATA[
        try {
            java.net.ServerSocket serverSocket =
                    new java.net.ServerSocket(2006);
                            ]]>
                        </programlisting>                           
                           
                           TCP kapu felett. Ha nem sikerül, akkor egy kivétel                            
                           keletkezik,
                           s a program végrehajtása egy megfelelő, most a 
                           catch ággal bevezetett 
                           kivételkezelő blokkban folytatódik, amivel most nem 
                           foglalkozunk.
                           </para>
                        
                            <para>
                           Tehát ha sikerrel ráültetjük a 2006-os TCP kapura
                           a <classname>ServerSocket</classname> objektumunkat, akkor programunk
                           egy végtelen ciklusba kezd, melyben nem tesz mást,
                           mint a szerver socket felett blokkolódva 
                           várakozik a kliensek
                           kapcsolatfelvételi kérelmeinek beérkezésére:
                           
                        <programlisting>
                            <![CDATA[
            while(true) {
                
                java.net.Socket socket = serverSocket.accept();
                            ]]>
                        </programlisting>
                           
                           Ha egy kliens kapcsolatfelvételi kérelme
                           érkezik a 2006 sorszámú kapuhoz, akkor az eddig
                           blokkolódott <function>accept()</function>
                           metódus visszaadja a kliens socketet.
                           </para>

            
                           <para>
						Amelytől megpróbálunk
                        elkérni egy kimenő csatorna objektumot, amelyre írni
                        akarjuk a kliensnek küldeni kívánt adatokat, most a 
                        <literal>Helló, Világ!\n</literal> karaktersorozatot.
                        
                        <programlisting>
                            <![CDATA[
            java.io.PrintWriter kimenőCsatorna =
                    new java.io.PrintWriter(socket.getOutputStream());
                    
                kimenőCsatorna.println("Helló, Világ!\n");                    
                            ]]>
                        </programlisting>

						Majd lezárjuk a kliensre mutató kaput:
                        
                        <programlisting>
                            <![CDATA[
            socket.close();
                            ]]>
                        </programlisting>
            
            </para>
            
            <para>
            A kliens működése egyszerűbb: megpróbál csatlakozni a szerverhez, majd a 
            kapcsolattól egy bejövő csatornát kérni és egy sort beolvasni.
            </para>
            
            
    
    </sect1>        

    <sect1>
        <title>Egyszerű összehasonlítások</title>
    
    <sect2 id="sebesseg">
        <title>Egyszerű összehasonlítások a sebesség kérdésében</title>
        
            <para>
                A sebességek egyszerű összevetésére a 
                <classname>PiBBP</classname> osztályunkból egyszerűsített
                <classname>PiBBPBench</classname> osztályt és annak
                C illetve C Sharp nyelvi átíratait használjuk, illetve
                a Java osztályból a bináris futtathatóval is számolunk. 
                A következő két táblázatban tehát a 
                a Pi hexadecimális kifejtésének 
                (0. pozíciótól számított) 
                10<superscript>6</superscript>.,
                10<superscript>7</superscript>.,
                10<superscript>8</superscript>.
                hexa jegyét határozzuk meg és közben megmérjük az 
                ehhez szükséges időt.
            </para>
            <para>                
                Az első táblázat számításait egy 
                <productname>Fedora Linux Core 5</productname> operációs rendszerrel
                felszerelt, <computeroutput>2.6.17.7</computeroutput>
                verziójú kernellel ellátott
                <hardware>Sun W1100Z Workstation</hardware>                
                (<hardware>AMD Opteron Mhz processzor</hardware>, 
                <hardware>1G memória</hardware>)
                gépen
                <computeroutput>gcc (GCC) 4.1.0 20060304 (Red Hat 4.1.0-3)</computeroutput>
                verziójú 
                <application>gcc</application> 
                (<computeroutput>gij (GNU libgcj) version 4.1.0 20060304 (Red Hat 4.1.0-3)</computeroutput>) 
                és 
                <computeroutput>java version "1.6.0-beta2"</computeroutput>
                verziójú Sun-os Java, a
                <productname>Java Platform, Standard Edition 6 Development Kit</productname>
                mellett végeztük el.                
            </para>
            
            <para>                
                A második táblázat számításait egy 
                <productname>Windows XP</productname> operációs rendszerrel
                ellátott
                <hardware>Intel Celeron 1.7Ghz processzoros</hardware>,  
                <hardware>768 M memóriával</hardware>  
                felszerelt
                gépen
                C Sharp tekintetében a 
                <productname>Microsoft .NET Framework Software Development Kit 2.0</productname>
                és Java tekintetében a
                <computeroutput>java version "1.6.0-beta2"</computeroutput>
                verziójú Sun-os Java, a
                <productname>Java Platform, Standard Edition 6 Development Kit</productname>
                mellett végeztük el.                
            </para>
            
            <para>
                
                A C forrásból készítünk bináris futtathatót, majd a Java forrásból
                ugyancsak bináris futtathatót, végül a Java forrásból a
                hagyományos <filename>class</filename> bájtkódot. A fordítások
                után mindhármat futtatjuk egymás után.
                
                <screen>
                    <![CDATA[
[norbi@niobe ~]$ gcc pi_bbp_bench.c -o pi_bbp_bench -lm
[norbi@niobe ~]$ gcj -o pibbpbench --main=PiBBPBench PiBBPBench.java
[norbi@niobe ~]$ javac PiBBPBench.java
[norbi@niobe ~]$ ./pi_bbp_bench
6
4.390000
[norbi@niobe ~]$ ./pibbpbench
6
6.386
[norbi@niobe ~]$ java PiBBPBench
6
4.246
                    ]]>
                </screen>     

                A forrásokban megemeljük a <varname>d</varname> értékét, most a 
                10<superscript>7</superscript>. jegyet vizsgáljuk.
                Újra fordítunk, majd futtatunk.

                <screen>
                    <![CDATA[
[norbi@niobe ~]$ gcc pi_bbp_bench.c -o pi_bbp_bench -lm
[norbi@niobe ~]$ gcj -o pibbpbench --main=PiBBPBench PiBBPBench.java
[norbi@niobe ~]$ javac PiBBPBench.java
[norbi@niobe ~]$ ./pi_bbp_bench
7
51.190000
[norbi@niobe ~]$ ./pibbpbench
7
74.503
[norbi@niobe ~]$ java PiBBPBench
7
49.465
                    ]]>
                </screen>     
                
                A forrásokban tovább emeljük a <varname>d</varname> értékét, most a 
                10<superscript>8</superscript>. jegyet vizsgáljuk.
                Megint újra fordítunk, majd futtatunk.

                <screen>
                    <![CDATA[
[norbi@niobe ~]$ gcc pi_bbp_bench.c -o pi_bbp_bench -lm
[norbi@niobe ~]$ gcj -o pibbpbench --main=PiBBPBench PiBBPBench.java
[norbi@niobe ~]$ javac PiBBPBench.java
[norbi@niobe ~]$ ./pi_bbp_bench
12
586.000000
[norbi@niobe ~]$ ./pibbpbench
12
854.993
[norbi@niobe ~]$ java PiBBPBench
12
556.935
                    ]]>
                </screen>     
                
                Az alábbi táblázatba foglaljuk eredményeinket.
                
                    <table frame="all"><title>Java, gcj és C egyszerű sebesség összehasonlítása</title>
                        <tgroup cols="5">
                            <thead>
                                <row>
                                    <entry>
                                        <para>Pozíció</para>
                                    </entry>
                                    <entry>
                                        <para>0xJegy</para>
                                    </entry>
                                    <entry>
                                        <para>C [sec]</para>
                                    </entry>
                                    <entry>
                                        <para>gcj [sec]</para>
                                    </entry>
                                    <entry>
                                        <para>Java [sec]</para>
                                    </entry>
                                </row>                                
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                    <para>10<superscript>6</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>6</para>
                                    </entry>
                                    <entry>
                                        <para>4.39</para>
                                    </entry>
                                    <entry>
                                        <para>6.386</para>
                                    </entry>
                                    <entry>
                                        <para>4.246</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para>10<superscript>7</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>7</para>
                                    </entry>
                                    <entry>
                                        <para>51.19</para>
                                    </entry>
                                    <entry>
                                        <para>74.503</para>
                                    </entry>
                                    <entry>
                                        <para>49.465</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para>10<superscript>8</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>C</para>
                                    </entry>
                                    <entry>
                                        <para>586.0</para>
                                    </entry>
                                    <entry>
                                        <para>854.993</para>
                                    </entry>
                                    <entry>
                                        <para>556.935</para>
                                    </entry>
                                </row>
                                </tbody></tgroup></table>
                

            </para>    
                                
                                
            <para>    
                                
                <screen>
                    <![CDATA[
C:\...> csc PiBBPBench.cs
C:\...> javac PiBBPBench.java
C:\...> PiBBPBench
6
10,65625
C:\...> java PiBBPBench
6
12.578
                    ]]>
                </screen>     

                A forrásokban megemeljük a <varname>d</varname> értékét, most a 
                10<superscript>7</superscript>. jegyet vizsgáljuk.
                Újra fordítunk, majd futtatunk.

                <screen>
                    <![CDATA[
C:\...> csc PiBBPBench.cs
C:\...> javac PiBBPBench.java
C:\...> PiBBPBench
7
125,0625
C:\...> java PiBBPBench
7
147.407
                    ]]>
                </screen>     
                                
                Az alábbi táblázatba foglaljuk eredményeinket.
                                 
                    <table frame="all"><title>Java és C# egyszerű sebesség összehasonlítása</title>
                        <tgroup cols="4">
                            <thead>
                                <row>
                                    <entry>
                                        <para>Pozíció</para>
                                    </entry>
                                    <entry>
                                        <para>0xJegy</para>
                                    </entry>
                                    <entry>
                                        <para>C# [sec]</para>
                                    </entry>
                                    <entry>
                                        <para>Java [sec]</para>
                                    </entry>
                                </row>                                
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                    <para>10<superscript>6</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>6</para>
                                    </entry>
                                    <entry>
                                        <para>10,65625</para>
                                    </entry>
                                    <entry>
                                        <para>12.578</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                    <para>10<superscript>7</superscript></para>
                                    </entry>
                                    <entry>
                                        <para>7</para>
                                    </entry>
                                    <entry>
                                        <para>125,0625</para>
                                    </entry>
                                    <entry>
                                        <para>147.407</para>
                                    </entry>
                                </row>
                                </tbody></tgroup></table>
                                
            </para>    
                                
                      
                      <sect3>
                      <title>A PiBBPBench Java osztály</title>          
            <para>                                                          
            A <filename>PiBBPBench.java</filename> állomány kódja.

					</para>
					
            <programlisting>
            <![CDATA[
/*
 * PiBBPBench.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A PiBBP.java-ból kivettük az "objektumorientáltságot", így kaptuk
 * ezt az osztályt.
 *
 * (A PiBBP osztály a BBP (Bailey-Borwein-Plouffe) algoritmust a Pi hexa
 * jegyeinek számolását végző osztály. A könnyebb olvahatóság
 * kedvéért a változó és metódus neveket megpróbáltuk az algoritmust
 * bemutató [BBP ALGORITMUS] David H. Bailey: The BBP Algorithm for Pi.
 * cikk jelöléseihez.)
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class PiBBPBench {
    /**
     * BBP algoritmus a Pi-hez, a [BBP ALGORITMUS] David H. Bailey: The
     * BBP Algorithm for Pi. alapján a {16^d Sj} részlet kiszámítása.
     *
     * @param   d   a d+1. hexa jegytől számoljuk a hexa jegyeket
     * @param   j   Sj indexe
     */
    public static double d16Sj(int d, int j) {
        
        double d16Sj = 0.0d;
        
        for(int k=0; k<=d; ++k)
            d16Sj += (double)n16modk(d-k, 8*k + j) / (double)(8*k + j);
        
        /* (bekapcsolva a sorozat elejen az első utáni jegyekben növeli pl.
            a pontosságot.)
        for(int k=d+1; k<=2*d; ++k)
            d16Sj += Math.pow(16.0d, d-k) / (double)(8*k + j);
         */
        
        return d16Sj - Math.floor(d16Sj);
    }
    /**
     * Bináris hatványozás mod k, a 16^n mod k kiszámítása.
     *
     * @param   n   kitevő
     * @param   k   modulus
     */
    public static long n16modk(int n, int k) {
        
        int t = 1;
        while(t <= n)
            t *= 2;
        
        long r = 1;
        
        while(true) {
            
            if(n >= t) {
                r = (16*r) % k;
                n = n - t;
            }
            
            t = t/2;
            
            if(t < 1)
                break;
            
            r = (r*r) % k;
            
        }
        
        return r;
    }
    /**
     * A [BBP ALGORITMUS] David H. Bailey: The
     * BBP Algorithm for Pi. alapján a
     * {16^d Pi} = {4*{16^d S1} - 2*{16^d S4} - {16^d S5} - {16^d S6}}
     * kiszámítása, a {} a törtrészt jelöli. A Pi hexa kifejtésében a
     * d+1. hexa jegytől
     */
    public static void main(String args[]) {
        
        double d16Pi = 0.0d;
        
        double d16S1t = 0.0d;
        double d16S4t = 0.0d;
        double d16S5t = 0.0d;
        double d16S6t = 0.0d;
        
        int jegy = 0;
        
        long delta = System.currentTimeMillis();
        
        for(int d=1000000; d<1000001; ++d) {
            
            d16Pi = 0.0d;
            
            d16S1t = d16Sj(d, 1);
            d16S4t = d16Sj(d, 4);
            d16S5t = d16Sj(d, 5);
            d16S6t = d16Sj(d, 6);
            
            d16Pi = 4.0d*d16S1t - 2.0d*d16S4t - d16S5t - d16S6t;
            
            d16Pi = d16Pi - Math.floor(d16Pi);
            
            jegy = (int)Math.floor(16.0d*d16Pi);
            
        }
        
        System.out.println(jegy);
        delta = System.currentTimeMillis() - delta;
        System.out.println(delta/1000.0);
    }
} 
            ]]>
            </programlisting>
</sect3>
                      <sect3>
                      <title>A pi_bbp_bench forrás</title>          
            <para>    

            A <filename>pi_bbp_bench.c</filename> állomány kódja.
                                
                                </para>
            <programlisting>
            <![CDATA[
#include <stdio.h>
#include <math.h>
#include <time.h>
/*
 * pi_bbp_bench.c
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 * A PiBBP.java-ból kivettük az "objektumorientáltságot", így kaptuk
 * a PiBBPBench osztályt, amit pedig átírtuk C nyelvre.
 *
 */

/*
 * 16^n mod k
 * [BBP ALGORITMUS] David H. Bailey: The
 * BBP Algorithm for Pi. alapján.
 */
long
n16modk (int n, int k)
{
  long r = 1;

  int t = 1;
  while (t <= n)
    t *= 2;

  for (;;)
    {

      if (n >= t)
	{
	  r = (16 * r) % k;
	  n = n - t;
	}

      t = t / 2;

      if (t < 1)
	break;

      r = (r * r) % k;

    }

  return r;
}

/* {16^d Sj}
 * [BBP ALGORITMUS] David H. Bailey: The
 * BBP Algorithm for Pi. alapján.
 */
double
d16Sj (int d, int j)
{

  double d16Sj = 0.0;
  int k;

  for (k = 0; k <= d; ++k)
    d16Sj += (double) n16modk (d - k, 8 * k + j) / (double) (8 * k + j);

  /*
     for(k=d+1; k<=2*d; ++k)
     d16Sj += pow(16.0, d-k) / (double)(8*k + j);
   */

  return d16Sj - floor (d16Sj);
}

/*
 * {16^d Pi} = {4*{16^d S1} - 2*{16^d S4} - {16^d S5} - {16^d S6}}
 * [BBP ALGORITMUS] David H. Bailey: The
 * BBP Algorithm for Pi. alapján.
 */
main ()
{

  double d16Pi = 0.0;

  double d16S1t = 0.0;
  double d16S4t = 0.0;
  double d16S5t = 0.0;
  double d16S6t = 0.0;

  int jegy;
  int d;

  clock_t delta = clock ();

  for (d = 1000000; d < 1000001; ++d)
    {

      d16Pi = 0.0;

      d16S1t = d16Sj (d, 1);
      d16S4t = d16Sj (d, 4);
      d16S5t = d16Sj (d, 5);
      d16S6t = d16Sj (d, 6);

      d16Pi = 4.0 * d16S1t - 2.0 * d16S4t - d16S5t - d16S6t;

      d16Pi = d16Pi - floor (d16Pi);

      jegy = (int) floor (16.0 * d16Pi);

    }

  printf ("%d\n", jegy);
  delta = clock () - delta;
  printf ("%f\n", (double) delta / CLOCKS_PER_SEC);
} 
            ]]>
            </programlisting>

            </sect3>
                      <sect3>
                      <title>A PiBBPBench C Sharp osztály</title>          
              

            <para>    

            A <filename>PiBBPBench.cs</filename> állomány kódja.                
                
                </para>
                
            <programlisting>
            <![CDATA[
/*
 * FileName: PiBBPBench.cs
 * Author: Bátfai Norbert, nbatfai@inf.unideb.hu
 * DIGIT 2005, Javat tanítok
 */
/// <summary>
/// A PiBBPBench C# átírata.
/// </summary>
/// <remark>
/// A PiBBP.java-ból kivettük az "objektumorientáltságot", így kaptuk
/// a PiBBPBench osztályt, amit pedig átírtuk C# nyelvre.
///
/// (A PiBBP osztály a BBP (Bailey-Borwein-Plouffe) algoritmust a Pi hexa
/// jegyeinek számolását végző osztály. A könnyebb olvahatóság
/// kedvéért a változó és metódus neveket megpróbáltuk az algoritmust
/// bemutató [BBP ALGORITMUS] David H. Bailey: The BBP Algorithm for Pi.
/// cikk jelöléseihez.)
/// </remark>
public class PiBBPBench {
    /// <remark>
    /// BBP algoritmus a Pi-hez, a [BBP ALGORITMUS] David H. Bailey: The
    /// BBP Algorithm for Pi. alapján a {16^d Sj} részlet kiszámítása.
    /// </remark>
    /// <param>
    /// d   a d+1. hexa jegytől számoljuk a hexa jegyeket
    /// </param>
    /// <param>
    /// j   Sj indexe
    /// </param>
    public static double d16Sj(int d, int j) {
        
        double d16Sj = 0.0d;
        
        for(int k=0; k<=d; ++k)
            d16Sj += (double)n16modk(d-k, 8*k + j) / (double)(8*k + j);
        
        /*
        for(int k=d+1; k<=2*d; ++k)
            d16Sj += System.Math.pow(16.0d, d-k) / (double)(8*k + j);
         */
        
        return d16Sj - System.Math.Floor(d16Sj);
    }
    /// <summary>
    /// Bináris hatványozás mod k, a 16^n mod k kiszámítása.
    /// </summary>
    /// <param>
    /// n   kitevő
    /// </param>
    /// <param>
    /// k   modulus
    /// </param>
    public static long n16modk(int n, int k) {
        
        int t = 1;
        while(t <= n)
            t *= 2;
        
        long r = 1;
        
        while(true) {
            
            if(n >= t) {
                r = (16*r) % k;
                n = n - t;
            }
            
            t = t/2;
            
            if(t < 1)
                break;
            
            r = (r*r) % k;
            
        }
        
        return r;
    }
    /// <remark>
    /// A [BBP ALGORITMUS] David H. Bailey: The
    /// BBP Algorithm for Pi. alapján a
    /// {16^d Pi} = {4*{16^d S1} - 2*{16^d S4} - {16^d S5} - {16^d S6}}
    /// kiszámítása, a {} a törtrészt jelöli. A Pi hexa kifejtésében a
    /// d+1. hexa jegytől
    /// </remark>
     public static void Main(System.String[]args) { 
        
        double d16Pi = 0.0d;
        
        double d16S1t = 0.0d;
        double d16S4t = 0.0d;
        double d16S5t = 0.0d;
        double d16S6t = 0.0d;
        
        int jegy = 0;
        
        System.DateTime kezd = System.DateTime.Now;
        
        for(int d=1000000; d<1000001; ++d) {
            
            d16Pi = 0.0d;
            
            d16S1t = d16Sj(d, 1);
            d16S4t = d16Sj(d, 4);
            d16S5t = d16Sj(d, 5);
            d16S6t = d16Sj(d, 6);
            
            d16Pi = 4.0d*d16S1t - 2.0d*d16S4t - d16S5t - d16S6t;
            
            d16Pi = d16Pi - System.Math.Floor(d16Pi);
            
            jegy = (int)System.Math.Floor(16.0d*d16Pi);
            
        }
        
        System.Console.WriteLine(jegy);
        System.TimeSpan delta = System.DateTime.Now.Subtract(kezd);
        System.Console.WriteLine(delta.TotalMilliseconds/1000.0);
    }
} 
            ]]>
            </programlisting>

            </sect3> 
            
            
    </sect2>            
    
                    <sect2 id="java_csharp">
                        <title>A Java és a C Sharp nyelvi szintű összehasonlítása</title>

                        <para> Az elmaradhatatlan, alább bemutatásra kerülő
                        <emphasis>„Helló, világ!”</emphasis>
                        programok jól mutatják, hogy érdekesebb és érdemesebb 
                        az összehasonlítást a 
                        két nyelv közötti hasonlóságokkal kezdeni.
                        <programlisting>
                            <![CDATA[
public class HellóVilág {
    
    public static void main(String args[]) {
        
        System.out.println("Helló Világ!");
        
    }
    
}                            ]]>
                        </programlisting>
                        
                        A <classname>HellóVilág</classname> osztály statikus, azaz
                        nem az osztályból származtatott példányokhoz, hanem magához
                        az osztályhoz tartozó indító <function>main</function> függvényének
                        egyetlen utasítása arról szól, hogy a meghívjuk a 
                        <classname>System</classname> osztály <varname>out</varname>
                        tagjának <function>println()</function> metódusát, aminek
                        paraméteréül a <computeroutput>"Helló Világ!"</computeroutput>
                        sztringet adjuk. A megszólított <varname>out</varname> tag
                        a <classname>System</classname> osztály 
                        egy <classname>PrintStream</classname> osztálybeli (típusú)
                        változója, s mint ilyen egy kimeneti csatorna; a programhoz
                        rendelt sztenderd kimeneti csatorna: tipikusan a képernyő.
                        
                        Tehát a programot a <application>javac</application>
                        nevű Java fordítóprogrammal lefordítva és futtatva, azaz az osztályt
                        a <command>javac</command> Java Virtuális Gépnek
                        átadva, a kimenet a
                        parancsablakban jelenik meg:
                        <screen>
                            <![CDATA[
C:\...> javac HellóVilág.java
C:\...> java HellóVilág
Helló Világ!
                            ]]>
                        </screen>                                 
                        
                        </para>
                        
                        <para> A Java számtalan osztályt biztosít a fejlesztő
                        rendelkezésére, amiket az egyszerűbb kezelés érdekében
                        egy fa szerkezetbe szervez. Ezt a fa szerkezetet nevezzük
                        Java API-nak. A <classname>System</classname> osztály
                        például a <classname>java</classname> alól nyíló
                        <classname>lang</classname> ágban van, amit a Java
                        terminológia egyébként csomagnak nevez és röviden, 
                        ponttal minősítve a <classname>java.lang</classname>
                        alakban ír. Tehát a <classname>System</classname>
                        osztály teljes neve <classname>java.lang.System</classname>,
                        de ez a csomag annyira általános, hogy eltekinthetünk
                        és szokás szerint el is tekintünk a kiírásától.                     
                        </para>
                        
                        
                        <para>
                        Ránézésre a megfelelő C Sharp programunk megegyezik a Java
                        változattal, de itt a <classname>System</classname> 
                        nem osztály, hanem egy névtér. Ami jelen összehasonlításunkban
                        a <classname>java.lang</classname> csomaggal állítható 
                        rokonságba. A <classname>Console</classname> viszont már
                        egy osztály, a konzolt absztraháló osztály, minek 
                        <function>WriteLine()</function> metódusával tudunk a 
                        sztenderd kimenetre írni. (Ebben az értelemben a 
                        <computeroutput>System.Console.WriteLine("Helló Világ!");</computeroutput>
                        utasításnak Javaban a 
                        <computeroutput>java.lang.System.out.println("Helló Világ!");</computeroutput>
                        utasítás felel meg formálisan.)
                        <programlisting>
                            <![CDATA[
public class HellóVilág {

    public static void Main() {

        System.Console.WriteLine("Helló Világ!");

    }

}                            
                            ]]>
                        </programlisting>
                        
                        A programot a <command>csc</command> nevű
                        C Sharp fordítóprogrammal
                         <citation>.NET Framework SDK 2.0</citation> 
                         lefordítva és futtatva a kimenet az
                        ablakban jelenik meg:
                        <screen>
                            <![CDATA[
C:\...> csc HellóVilág.cs
C:\...> HellóVilág.exe
Helló Világ!                            
                            ]]>
                        </screen>                                 
                        
                        </para>

                        <para>
                            A következő példával nagyot ugrunk,
                            a bemutatásra kerülő 
                            többszálú szerveroldali TCP kiszolgáló
                            programmal továbbra is az a célunk, hogy 
                            kihangsúlyozzuk a nyelvek közötti
                            hasonlóságokat.
                            
                           <warning>
                            <title>Figyelmeztetés a Javaban kezdő Olvasóknak</title>                           
                               <para>
                                   A következő Java és C Sharp nyelvű 
                                   hálózati példát csak
                                   felületesen fussa át a kezdő Olvasó. De most akár
                                   ki is hagyhatja, s az olvasást a következő,
                                   az alapvető programnyelvi
                                   konstrukciókat bemutató résznél folytathatja.
                                   Ez esetben a hálózati alapfogalmakat és a Java 
                                   programozást bevezető tárgyaló 
                                   rész után érdemes ide visszalapozni.
                               </para>
                           </warning>                                       
                           
                           A részletesebb tárgyalás előtt vessünk egy 
                           pillantást a Java megvalósításunk alábbi 
                           fő osztályára!
                           
                        <programlisting>
                            <![CDATA[
public class Szerver {
    
    public static void main(String [] args) {
        
        try {
            java.net.ServerSocket serverSocket =
                    new java.net.ServerSocket(2006);
            
            while(true) {
                
                java.net.Socket socket = serverSocket.accept();
                new Thread(new Kiszolgáló(socket)).start();
                
            }
            
        } catch(java.io.IOException ioE) {
            ioE.printStackTrace();
        }
    }
}
                            ]]>
                        </programlisting>
                            
                           A <classname>Szerver</classname> osztály indító
                           függvényében megpróbáljuk lefoglalni a 
                           2006 számú szerver socketet, azaz OO nyelven:
                           megpróbálunk létrehozni egy 
                           <classname>ServerSocket</classname>, egy szerver
                           socketet absztraháló Java objektumot a 2006 sorszámú
                           
                        <programlisting>
                            <![CDATA[
        try {
            java.net.ServerSocket serverSocket =
                    new java.net.ServerSocket(2006);
                            ]]>
                        </programlisting>                           
                           
                           TCP kapu felett. Ha nem sikerül, akkor egy kivétel, 
                           OO terminológiában kivétel objektum
                           keletkezik,
                           s a program végrehajtása egy megfelelő kivételkezelő
                           keresésével folytatódik. Ez a kivétel objektum
                           tipikusan egy <classname>BindException</classname>
                           osztálybeli objektum szokott lenni, ami azt jelöli,
                           hogy a lefoglalni óhajtott 2006 sorszámú kapu éppen
                           foglalt. Ez a kivétel osztály leszármazottja az 
                           <classname>IOException</classname> osztálynak, így a 
                           kivétel objektum kezelésére a 
                           
                        <programlisting>
                            <![CDATA[
        } catch(java.io.IOException ioE) {
            ioE.printStackTrace();
        }
                            ]]>
                        </programlisting>
                        
                        kivételkezelő blokk alkalmas, ahol egyébként nem teszünk
                        mást, mint kiírjuk, hogy hogyan került ebbe a helyzetbe
                        a programunk. Majd programunk a kivételkezelő blokk
                        utáni résszel folytatódik, azaz gyakorlatilag véget ér.
                            </para>
                        
                            <para>
                           Ha viszont sikerrel járunk, akkor programunk
                           egy végtelen ciklusba kezd, melyben nem tesz mást,
                           mint a szerver socket felett blokkolódva 
                           várakozik a kliensek
                           kapcsolatfelvételi kérelmeinek beérkezésére:
                           
                        <programlisting>
                            <![CDATA[
            while(true) {
                
                java.net.Socket socket = serverSocket.accept();
                            ]]>
                        </programlisting>
                           
                           ha egy kliens kapcsolatfelvételi kérelme
                           érkezik a 2006 sorszámú kapuhoz, akkor az eddig
                           blokkolódott <function>accept()</function>
                           metódus visszaadja a kliens socketet. A jelentkező
                           kliens kiszolgálására külön szálat, azaz 
                           programunk eddig tekintett fő szálával 
                           párhuzamosan futó külön szálat készítünk. Mivel 
                           minden, így a párhuzamosan futó szálak is
                           objektumok, ezek a <classname>Thread</classname>
                           osztálybeli objektumok. A példányosításkor a 
                           szálnak átadjuk a párhuzamosan végrehajtani kívánt 
                           kódot implementáló objektumot, egy a kliens
                           socket fölött éppen létrehozott 
                           <classname>Kiszolgáló</classname> objektumot.
                           
                        <programlisting>
                            <![CDATA[
                new Thread(new Kiszolgáló(socket)).start();
                            ]]>
                        </programlisting>

                        A létrehozott szál objektumot <function>start()</function> 
                        metódusával rögtön el is indítjuk, miután programunk
                        végrehajtása ketté vált:
                        
                       <itemizedlist>
                            <listitem><para>a program fő szálában a vezérlés 
                            a végtelen ciklusban folytatódik tovább, azaz program
                            újra várakozni kezd az <function>accept()</function>
                            metódusban.
                            </para></listitem>                    
                            <listitem><para>az indított szálban a 
                            párhuzamosan végrehajtani kívánt
                            kódot implementáló objektum <function>run()</function> 
                            metódusának végrehajtása kezdődik meg.
                            </para></listitem>
                        </itemizedlist>                          
                        
                        De mielőtt a <classname>Kiszolgáló</classname> objektumot
                        és annak <function>run()</function> metódusát megvizsgálnánk,
                        nézzük meg az eddig bemutatott szerverünk C Sharp nyelvi
                        megvalósítását!
                           
                        <programlisting>
                            <![CDATA[
public class Szerver {
    
    public static void Main(System.String[]args) {
        
        try {
            
            System.Net.Sockets.TcpListener tcpListener =
                    new System.Net.Sockets.TcpListener(
                                System.Net.IPAddress.Loopback, 2006);
            
            tcpListener.Start();
            
            while (true) {
                System.Net.Sockets.TcpClient socket =
                        tcpListener.AcceptTcpClient();
                
                Kiszolgáló kiszolgáló = new Kiszolgáló(socket);
                System.Threading.ThreadStart threadStart =
                        new System.Threading.ThreadStart(kiszolgáló.run);
                System.Threading.Thread szál =
                        new System.Threading.Thread(threadStart);
                szál.Start();
                
            }
            
        } catch (System.Exception e) {        
            System.Console.WriteLine(e);
        }
    }
}                            
                            ]]>
                        </programlisting>
 
                        Jól láthatóan a C Sharp megvalósítás dallama ugyanaz,
                        mint a Java megvalósításé volt. 
                        </para>
                        
                        <para>
                        Folytassuk az iménti C Sharp
                        kitérő miatt 
                        felfüggesztett Java nyelven implementált
                        <classname>Kiszolgáló</classname> osztály tárgyalását.
                       A részletek előtt megint csak vessünk egy 
                       pillantást az egész osztályra!                       
                        
                        <programlisting>
                            <![CDATA[
class Kiszolgáló implements Runnable {
    
    java.net.Socket socket;
    
    public Kiszolgáló(java.net.Socket socket) {
        
        this.socket = socket;
        
    }
    
    public void run() {
        
        try {
            java.io.BufferedReader bejövőCsatorna =
                    new java.io.BufferedReader(
                    new java.io.InputStreamReader(socket.getInputStream()));
            java.io.PrintWriter kimenőCsatorna =
                    new java.io.PrintWriter(socket.getOutputStream());
            
            String sor = null;
            while((sor = bejövőCsatorna.readLine()) != null) {
                
                kimenőCsatorna.println(sor);
                kimenőCsatorna.flush();
                
            }
            socket.close();
            
        } catch(java.io.IOException ioE) {
            ioE.printStackTrace();
        }
    }
}
                            ]]>
                        </programlisting>

                        Az osztály a <classname>Runnable</classname> interfész
                        implementálásával jelzi, hogy tartalmaz egy párhuzamosan
                        végrehajtható <function>run()</function> metódust.
                        
                        <programlisting>
                            <![CDATA[
class Kiszolgáló implements Runnable {
                            ]]>
                        </programlisting>
 
                        A <function>run()</function> metódusban megpróbálunk
                        két szöveges csatorna objektumot készíteni a kliens kapu
                        fölött, egy bemenetit, amelyről olvasni szeretnénk a 
                        klienstől érkező adatokat és egy kimenetit, amelyre írni
                        akarjuk a kliensnek küldeni kívánt adatokat.
                        
                        <programlisting>
                            <![CDATA[
        try {
            java.io.BufferedReader bejövőCsatorna =
                    new java.io.BufferedReader(
                    new java.io.InputStreamReader(socket.getInputStream()));
            java.io.PrintWriter kimenőCsatorna =
                    new java.io.PrintWriter(socket.getOutputStream());
                            ]]>
                        </programlisting>

                        A csatorna objektumok sikeres elkészítése után a 
                        bejövő csatornáról a <classname>BufferedReader</classname>
                        osztály <function>readLine()</function> módszerével
                        sorokat olvasunk be, egészen addig, ameddig csak 
                        tudunk. Ha már nem tudunk, akkor ezt a 
                        <function>readLine()</function> metódus majd a 
                        <literal>null</literal> érték visszaadásával jelzi.

                        <programlisting>
                            <![CDATA[
            while((sor = bejövőCsatorna.readLine()) != null) {
                
                kimenőCsatorna.println(sor);
                kimenőCsatorna.flush();
                
            }
                            ]]>
                        </programlisting>
                        
                        A bejövő csatornáról olvasó ciklus testében nem teszünk
                        mást, mint a beolvasott sztring visszaírását a 
                        kimenő csatornára. Tehát szerverünk egy echo szerver
                        jelleggel működik. Ha már nincs több olvasható sor
                        a bejövő csatornán, akkor kilépünk az Olvasó ciklusból
                        és lezárjuk a kliensre mutató kaput.
                        
                        <programlisting>
                            <![CDATA[
            socket.close();
                            ]]>
                        </programlisting>

                        Nézzük meg az imént
                        Java nyelven implementált
                        <classname>Kiszolgáló</classname> osztály C Sharp nyelven
                        készített
                        megvalósítását!
                        
                        <programlisting>
                            <![CDATA[
class Kiszolgáló {
    
    System.Net.Sockets.TcpClient socket;
    
    public Kiszolgáló(System.Net.Sockets.TcpClient socket) {
        
        this.socket = socket;
        
    }
    
    public void run() {
        
        System.IO.StreamReader bejövőCsatorna =
                new System.IO.StreamReader(socket.GetStream());
        System.IO.StreamWriter kimenőCsatorna =
                new System.IO.StreamWriter(socket.GetStream());
        
        System.String sor;
        
        while((sor = bejövőCsatorna.ReadLine()) != null) {
        
            kimenőCsatorna.WriteLine(sor);
            kimenőCsatorna.Flush();
            
        }
        socket.Close();
    }
}
]]>
                        </programlisting>
                        
                        Ismét jól látható, hogy a C Sharp megvalósítás dallama ugyanaz,
                        mint ami a Java megvalósításé volt.                         
                        </para>

                        <sect3>
                            <title>Az alapvető nyelvi elemek összehasonlítása</title>
                        
                            <para>
                                Ebben a pontban - csupán demonstrációs céllal - 
                                néhány nyelvi elem leírására vetünk 
                                egy-egy pillantást. Alapvetően a Java nyelvi
                                konstrukciókat tárgyaljuk, de ha külön nem 
                                emeljük ki a C Sharp nyelvbeli különbséget, akkor
                                az megegyezik a Java konstrukcióval.
                           </para>
                                                        
                            <para>
                                Osztályt a 
                                <programlisting>
                                    <![CDATA[
public class OsztályNév {
    
}                                    ]]>
                                </programlisting>
                                alakban definiálunk. Javaban fontos, hogy ezt 
                                a publikus <classname>OsztályNév</classname> osztály
                                definíciót tartalmazó szöveges forrásállomány neve
                                megegyezzen ezzel a publikus osztálynévvel, azaz
                                az állomány neve
                                <filename>OsztályNév.java</filename> legyen. 
                                
                           </para>
                           
                            <para>
                                Nem javasoljuk, de egyetlen forrásállomány
                                több, nem publikus osztály definícióját is
                                tartalmazhatja.
                                <programlisting>
                                    <![CDATA[
public class OsztályNév {

}

class MásikOsztályNév {
    
}
                                    ]]>
                                </programlisting>
                                
                           </para>

                            <para>
                                Ezek az osztálydefiníciók (akár a most tárgyalt
                                üresek is) lefordíthatók a <command>javac</command>
                                nevű Java fordítóprogrammal.
                        <screen>
                            <![CDATA[
C:\...> javac OsztályNév.java
                            ]]>
                        </screen>                                 
                                C Sharpban az osztály lefordításához egy 
                                belépési pontra is szükség van, ez a C örökségnek
                                megfelelően a <function>main()</function> függvény.
                                <programlisting>
                                    <![CDATA[
public class OsztályNév {
    
    public static void Main() {

    }

}

public class MásikOsztályNév {
    

}                                    ]]>
                                </programlisting>
                                
                                Javaban ugyancsak, de itt az esetleges
                                parancssor argumentumok átvételét szolgáló
                                <computeroutput>String[] args</computeroutput>
                                sztring tömböt is szerepeltetnünk kell a 
                                belépési függvény formális paraméter listájában.
                                
                                <programlisting>                                
                                    <![CDATA[
public class OsztályNév {
    
    public static void main(String[] args) {
        
    }
    
}

class MásikOsztályNév {
    
}
                                    ]]>
                                </programlisting>
                                
                                De ugyanezzel a konstrukcióval vesszük át a 
                                parancssor argumentumokat C Sharpban is:
                                
                                <programlisting>
                                    <![CDATA[
    public static void Main(System.String[] args) {

    }
                                    ]]>
                                </programlisting>
                                                                
                           </para>
                                                      
                           <para>
                               A <function>main()</function> függvényben rendszerint
                               példányosítunk, azaz a <computeroutput>new</computeroutput> operátorral 
                               objektumot, objektumokat hozunk
                               létre. 
                                <programlisting>                                
                                    <![CDATA[
    public static void main(String[] args) {
        
        OsztályNév példányReferencia = new OsztályNév("Hello");
        
    }                                    
                                    ]]>
                                </programlisting>

                                Itt az <classname>OsztályNév</classname> osztályból
                                példányosítottunk, azaz létrehoztunk egy konkrét, a
                                továbbiakban a <varname>példányReferencia</varname>
                                névvel azonosított objektumot. Ez azt jelenti, hogy
                                lefutott a <classname>OsztályNév</classname>
                                osztály megfelelő konstruktora:
                                
                                <programlisting>                                
                                    <![CDATA[
public class OsztályNév {

    String példányTagReferencia;
    
    public OsztályNév(String példányTagReferencia) {
    
        this.példányTagReferencia = példányTagReferencia;
        
    }
                                     ]]>
                                </programlisting>
                                
                                ami nem csinált mást, mint a
                                <computeroutput>new OsztályNév("Hello");</computeroutput>
                                hívásban érkező
                                 aktuális
                                <computeroutput>"Hello"</computeroutput>
                                paraméter sztring objektum referenciáját értékül 
                                adja az osztály aktuális példánya
                                <varname>példányTagReferencia</varname>
                                nevű változójának.                                
                           </para>

                           <para>
                               A referenciák neve után egy pontot írva tudjuk
                               megszólítani az objektum példányokat, tagjaikra
                               vagy módszereikre hivatkozhatunk. Előbbire lássuk
                               az alábbi példát, utóbbira majd a következő feladatot!
                                <programlisting>                                
                                    <![CDATA[
public class OsztályNév {

    String példányTagReferencia;
    
    public OsztályNév(String példányTagReferencia) {
    
        this.példányTagReferencia = példányTagReferencia;
        
    }
    
    public static void main(String[] args) {
        
        OsztályNév osztályPéldány = new OsztályNév("Hello");
        
        System.out.println(osztályPéldány.példányTagReferencia);
    }
    
}                                    
                                    ]]>
                                </programlisting>
                           </para>
                           
                           <example>
                               <title>Írjunk az <classname>OsztályNév</classname>
                               osztályunkhoz egy példánymetódust, ami 
                               visszaadja az osztály <classname>String</classname>
                               tagját!</title>
                   
                               <para>
                                <programlisting>                                
                                    <![CDATA[
public class OsztályNév {

    String példányTagReferencia;
    
    public OsztályNév(String példányTagReferencia) {
    
        this.példányTagReferencia = példányTagReferencia;
        
    }
    
    public String példányMetódus() {
    
        return példányTagReferencia;
        
    }
    
    public static void main(String[] args) {
        
        OsztályNév osztályPéldány = new OsztályNév("Hello");
        
        System.out.println(osztályPéldány.példányTagReferencia);
        System.out.println(osztályPéldány.példányMetódus());
        
    }
    
}
                                    ]]>
                                </programlisting>
                                
                                Ha a kedves  Olvasó lefordítaná és 
                                futtatná a példát, akkor az alábbi
                                eredményeket kapná.
                                
                        <screen>
                            <![CDATA[
C:\...> javac OsztályNév.java
C:\...> java OsztályNév
Hello
Hello
                            ]]>
                        </screen>                                 
                               </para>
                               
                               <para>                                                               
                                Adjuk meg a megoldást C Sharp nyelven is:
                                
                                <programlisting>                                
                                    <![CDATA[
public class OsztályNév {
 
   System.String példányTagReferencia;
    
    public OsztályNév(System.String példányTagReferencia) {
    
        this.példányTagReferencia = példányTagReferencia;
        
    }
    
    public System.String példányMetódus() {
    
        return példányTagReferencia;
        
    }
   
    public static void Main() {

        OsztályNév osztályPéldány = new OsztályNév("Hello");
        
        System.Console.WriteLine(osztályPéldány.példányTagReferencia);
        System.Console.WriteLine(osztályPéldány.példányMetódus());

    }

}                                
                                    ]]>
                                </programlisting>

                                A Java példához hasonlóan, ha a kedves 
                                Olvasó lefordítaná és 
                                futtatná a példát, akkor az alábbi
                                eredményeket kapná.
                                
                        <screen>
                            <![CDATA[
C:\...> csc Osztály.java
C:\...> Osztály.exe
Hello
Hello
                            ]]>
                        </screen>                                 
                               </para>
                                
                           </example>

                           <para>
                           A Java és a C Sharp összehasonlítása iránt tovább
                           érdeklődő kedves Olvasónak a 
                           <citation>JAVA ás C SHARP</citation>,
                           <citation>C SHARP J--</citation> cikkeket 
                           ajánljuk.
                           </para>
                           
                        </sect3>
                        
                    </sect2>

    </sect1>
    
    </appendix>

    <appendix>
    
        <appendixinfo>
        <keywordset>
			  <keyword>pontmátrix</keyword>
              <keyword>emberi genom</keyword>                            
              <keyword>humán genom</keyword>                            
              <keyword>genom</keyword>                            
              <keyword>C. elegans</keyword>                            
              <keyword>fehérje</keyword>                            
              <keyword>DNS</keyword>                            
              <keyword>Pi</keyword>                            
              <keyword>fraktál</keyword>                            
              <keyword>fraktálok</keyword>                            
              <keyword>Mandelbrot halmaz</keyword>                            
              <keyword>Sejtautomata</keyword>                            
              <keyword>életjáték</keyword>                            
              <keyword>Orch OR</keyword>                            
        </keywordset>
    </appendixinfo>

        <title>Számítási mellékletek</title>
    
    <epigraph>
        <attribution>Roger Penrose
            <citetitle>A császár új elméje</citetitle>
        </attribution>
        <para>
            „Mégis kitartok a remény mellett, hogy az értelem megértésében a
            természettudományokon és a matematikán keresztül kell komoly
            előrehaladásnak létrejönnie.”
        </para>
    </epigraph>
    
    <sect1 id="biol_java">
        <title>Biológiai témájú programok</title>
        
        
        <sect2 id="pontmatrix">
            <title>Genomi, aminosav vagy akár tetszőleges szekvenciák összehasonlítása</title>

            <para>
            Ebben a pontban egy olyan (Swinges) grafikus felülettel ellátott
            pontmátrixot kiszámoló/megmutató/kimentő programot készítünk, 
            amivel tetszőleges sorozatokat, de főleg
            genomi vagy fehérje szekvenciákat tudunk összehasonlítani. A pontmátrix
            részletes leírását a <citation>BIOINFOMATIKA</citation> könyvben
            találjuk. A pontmátrix egyszerűen a mátrix, ami
            i. oszlopának és j. sorának értéke fekete, azaz az alábbi kódban
            <computeroutput>0x00000000</computeroutput>, ha az egyik minta i.
            eleme és a másik minta j. eleme megegyezik, különben 
            <computeroutput>0x00ffffff</computeroutput> fehér.
            
            <programlisting>
            <![CDATA[
            // A pontmátrix számítása:
            for(int i=0; i<egyikMinta.length; ++i) {
                for(int j=0; j<másikMinta.length; ++j) {
                    
                    pontmátrixKép.setRGB(i,j, 0x00ffffff);
                    if(egyikMinta[i] == másikMinta[j])
                        pontmátrixKép.setRGB(i,j, 0x00000000);
                    
                }
            }
            ]]>
            </programlisting>

            A pontmátrix arról ad tehát tájékoztatást, hogy a két vizsgált
            minta mennyire egyezik meg. Ha például mindkét mintának ugyanazt a 
            sorozatot adjuk meg, akkor egy átlós egyenes jól láthatóvá
            válik a pontmátrixon.
            
            </para>

            <para>
                A fejlesztendő pontmátrixos 
                programot legördülő menüvel készítjük el, e menün
                keresztül vesszük át a felhasználói inputot: a minták
                betöltését, a pontmátrix számításának indítását stb.
            </para>
            
            <para>
            <inlinemediaobject>
                <imageobject>
                    <imagedata fileref="images/biol/pontmatrix.png" />
                </imageobject>
                <textobject>
                    <phrase>A Pontmátrix osztály grafikus felülete.</phrase>
                </textobject>	
            </inlinemediaobject>                       
            </para>
                        
            <para>
                A minta szekvenciákat tartalmazó állományok betöltését és 
                a kiszámolt pontmátrix képek mentését a 
                <classname>javax.swing.JFileChooser</classname> osztály
                segítségével végezzük. Az alábbi ábra egy ilyen objektum
                üzemét mutatja az egyik minta betöltésénél.
                
                    </para>
                    <para>
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/biol/betolt.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A Pontmátrix program betölt egy vizsgálandó minta állományt.</phrase>
                    </textobject>	
                </inlinemediaobject>                       
                    </para>
                    <para>
                
                A <classname>javax.swing.JFileChooser</classname> osztály
                használata kényelmes és egyszerű, például a kimentést megvalósító kódunk
                az alábbi lesz.
                
                <programlisting>
                <![CDATA[
        } else if("Mentés...".equals(menü)) {
            
            javax.swing.JFileChooser betöltő = new javax.swing.JFileChooser();
            betöltő.showSaveDialog(getContentPane());
            pillanatfelvétel(betöltő.getSelectedFile().getAbsolutePath());
            
        }                
                ]]>
                </programlisting>
                             
                
                ahol a 
                <computeroutput>betöltő.getSelectedFile().getAbsolutePath()</computeroutput>
                a
                    </para>
                    <para>
                
                <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/biol/ment.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A Pontmátrix program ment egy kiszámolt pontmátrix képet.</phrase>
                    </textobject>	
                </inlinemediaobject>                       
                    </para>
                    <para>
                
                ablakban megadott
                <filename>Ember_egér_tubulin_összehasonlítása.png</filename>
                állománynevet adja vissza, a <function>pillanatfelvétel()</function> függvény 
                pedig ebbe a 
                paraméterként kapott nevű állományba menti majd a pontmátrix képét.
                
            </para>

            <para>
                A következő ábra üzem közben mutatja a példaprogramunkat. 
                Éppen az 
                 <itemizedlist>
                    <listitem>
                      <para>
                ember
                <ulink url="http://www.expasy.org/uniprot/Q13748">http://www.expasy.org/uniprot/Q13748</ulink>                
                (UniProtKB-Swiss-Prot entry Q13748 [TBA2_HUMAN] Tubulin alpha-2 chain)
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                és az egér
                <ulink url="http://www.expasy.org/uniprot/P05213">http://www.expasy.org/uniprot/P05213</ulink>
                (UniProtKB-Swiss-Prot entry P05213 [TBA2_MOUSE] Tubulin alpha-2 chain)
                      </para>
                    </listitem>
                    </itemizedlist>
                alfa tubulin 2 fehérjéjének kódját hasonlítjuk össze.
            </para>
            
            <para>
            <inlinemediaobject>
                <imageobject>
                    <imagedata fileref="images/biol/ember_eger.png" />
                </imageobject>
                <textobject>
                    <phrase>UniProtKB/Swiss-Prot entry Q13748 és UniProtKB/Swiss-Prot entry P05213 összehasonlítása a pontmátrixunkkal.</phrase>
                </textobject>	
            </inlinemediaobject>                       
            </para>
            
            <para>
                A kapott kép láthatóan zajos, ezért implementáltuk a 
                <guimenuitem>Pontmátrix/Szűrés</guimenuitem> menüpontot is, amely
                annyiban több az egyszerű számításnál, hogy az egyezéseket nem
                csupán a vizsgált szekvenciák egyedi tagjainál, hanem kis csoportjaiban
                vizsgáljuk. Azaz nem csupán az i. és j. elemnek kell megegyeznie, hanem
                    környezetükből többnek is.
                
                    </para>
                    <para>
            <inlinemediaobject>
                <imageobject>
                    <imagedata fileref="images/biol/ablak_szures.png" />
                </imageobject>
                <textobject>
                    <phrase>Nem csupán az i. és j. elemnek kell megegyeznie, hanem
                    környezetükből többnek is.</phrase>
                </textobject>	
            </inlinemediaobject>                       
                    </para>
                    <para>
                                
                <programlisting>
                <![CDATA[
            // A pontmátrix szűrése:
            int ablakMéret = 7;
            for(int i=0; i<egyikMinta.length; ++i) {
                for(int j=0; j<másikMinta.length; ++j) {
                    int egyforma = 0;
                    for(int k = -ablakMéret; k<ablakMéret; ++k) {
                        if( i+k > 0 && i+k < egyikMinta.length
                                && j+k > 0 && j+k < másikMinta.length)
                            if(egyikMinta[i+k] == másikMinta[j+k])
                                ++egyforma;
                    }
                    pontmátrixKép.setRGB(i,j, 0x00ffffff);
                    if(egyforma > 2*ablakMéret-2)
                        pontmátrixKép.setRGB(i,j, 0x00000000);
                }
            }                
                ]]>
                </programlisting>
                                
            </para>
            
            <para>
            A programmal végzett számítás (és szűrés) jól mutatja,
                 <itemizedlist>
                    <listitem>
                      <para>az ember
                        <ulink url="http://www.expasy.org/uniprot/Q13748">http://www.expasy.org/uniprot/Q13748</ulink>                
                      </para>
                    </listitem>                        
                    <listitem>
                      <para>és egér
            <ulink url="http://www.expasy.org/uniprot/P05213">http://www.expasy.org/uniprot/P05213</ulink>
                      </para>
                    </listitem>                        
                    <listitem>
                      <para>és az ember és  C. elegans fonalféreg a 
            <ulink url="http://www.expasy.org/uniprot/P34690">http://www.expasy.org/uniprot/P34690</ulink>
                      </para>
                    </listitem>                        
                    </itemizedlist>
            alfa tubulin 2 fehérjéjének hasonlóságát:            
            </para>
                        
            <para>
            <inlinemediaobject>
                <imageobject>
                    <imagedata fileref="images/biol/ember_eger_szurt.png" />
                </imageobject>
                <textobject>
                    <phrase>UniProtKB/Swiss-Prot entry Q13748 és UniProtKB/Swiss-Prot entry P05213 összehasonlítása a szűrt pontmátrixunkkal.</phrase>
                </textobject>	
            </inlinemediaobject>                       
            </para>
            
            <para>
                Láthatóan az emberé és az egéré sokkal inkább hasonló, mint alább, az
                emberé és a fonalféregé.
            </para>
                        
            <para>
            <inlinemediaobject>
                <imageobject>
                    <imagedata fileref="images/biol/ember_caeel_szurt.png" />
                </imageobject>
                <textobject>
                    <phrase>UniProtKB/Swiss-Prot entry Q13748 és UniProtKB/Swiss-Prot entry P34690 összehasonlítása a szűrt pontmátrixunkkal.</phrase>
                </textobject>	
            </inlinemediaobject>                       
            </para>
            
            
            <sect3>
            <title>A Pontmátrix osztály</title>

            <programlisting>
            <![CDATA[
/*
 * Pontmátrix.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A pontmátrixot tartalmazó képet kirajzoló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
class PontmátrixVászon extends javax.swing.JPanel {
    /** A pontmátrixot tartalmazó kép. */
    java.awt.image.BufferedImage pontmátrixKép;
    // A panel mérete
    java.awt.Dimension mátrixMéret =
            new java.awt.Dimension(800, 800);
    // A panel mérete
    public java.awt.Dimension getPreferredSize() {
        return mátrixMéret;
    }
    /** A pontmátrixot tartalmazó kép kirajzolása. */
    public void paintComponent(java.awt.Graphics g) {
        
        super.paintComponent(g);
        
        if(pontmátrixKép != null)
            g.drawImage(pontmátrixKép, 0, 0, this);
    }
    /** A pontmátrixot tartalmazó kép beállítása. */
    public void beállítKép(java.awt.image.BufferedImage pontmátrixKép) {
        
        this.pontmátrixKép = pontmátrixKép;
        mátrixMéret.setSize(pontmátrixKép.getWidth(),
                pontmátrixKép.getHeight());
    }
}
/**
 * A pontmátrixot számoló osztály.
 * A pontmátrix leírását lásd a [BIOINFORMATIKA] hivatkozásban:
 * (Maróti Péter: Információelmélet a biológiában, JATEPress 2003.)
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class Pontmátrix extends javax.swing.JFrame
        implements java.awt.event.ActionListener {
    /** Az egyik minta. */
    byte [] egyikMinta;
    /** A másik minta. */
    byte [] másikMinta;
    /** A pontmátrix képe. */
    java.awt.image.BufferedImage pontmátrixKép;
    /** A pontmátrix képét tartalmazó panel. */
    PontmátrixVászon pontmátrixVászon;
    /** A pontmátrix képét tartalmazó panelt tartalmazó görgető objektum. */
    javax.swing.JScrollPane pontmátrixGörgető;
    /** Informáló szövegdoboz. */
    javax.swing.JTextArea infóTextArea;
    /** A GUI felépítése. */
    public Pontmátrix() {
        // Az ablak adatai, fejléce:
        super("Mindenféle szekvenciák összehasonlítása.");
        // Pozíció és méret
        java.awt.Dimension képernyőMéret =
                java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        // Középre tesszük:
        setBounds((int)képernyőMéret.getWidth()/2-300,
                (int)képernyőMéret.getHeight()/2-200,
                600, 400);
        // Az ablak komponenseinek elhelyezési stratégiája:
        // középen lesz a kép (CENTER), alatta (SOUTH) az
        // informáló szövegdoboz.
        getContentPane().setLayout(new java.awt.BorderLayout());
        // Az ablak szokásos bezár gombjára is kilép a program:
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        // Legördülő menü elkészítése.
        // A Menüsor:
        javax.swing.JMenuBar menüSor = new javax.swing.JMenuBar();
        // A Fájl menü
        javax.swing.JMenu menü = new javax.swing.JMenu("Fájl");
        menüSor.add(menü);
        javax.swing.JMenuItem menüPont
                = new javax.swing.JMenuItem("Egyik minta...");
        menüPont.addActionListener(this);
        menü.add(menüPont);
        menüPont = new javax.swing.JMenuItem("Másik minta...");
        menüPont.addActionListener(this);
        menü.add(menüPont);
        menüPont = new javax.swing.JMenuItem("Mentés...");
        menüPont.addActionListener(this);
        menü.add(menüPont);
        menüPont = new javax.swing.JMenuItem("Kilépés");
        menüPont.addActionListener(this);
        menü.add(menüPont);
        // A Pontmárix menü
        menü = new javax.swing.JMenu("Pontmátrix");
        menüPont.addActionListener(this);
        menüSor.add(menü);
        menüPont = new javax.swing.JMenuItem("Számol");
        menüPont.addActionListener(this);
        menü.add(menüPont);
        menüPont = new javax.swing.JMenuItem("Szűrés");
        menüPont.addActionListener(this);
        menü.add(menüPont);
        // A névjegy menü
        menü = new javax.swing.JMenu("Névjegy");
        menüPont.addActionListener(this);
        menüSor.add(menü);
        menüPont = new javax.swing.JMenuItem("Névjegy");
        menüPont.addActionListener(this);
        menü.add(menüPont);
        // A menü hozzáadása az ablakhoz
        setJMenuBar(menüSor);
        // A pontmátrix képet erre a vászonra (panelre) rajzoljuk majd
        pontmátrixVászon = new PontmátrixVászon();
        pontmátrixVászon.setSize(800, 800);
        // legyen görgethető
        pontmátrixGörgető = new javax.swing.JScrollPane(pontmátrixVászon);
        getContentPane().add(pontmátrixGörgető,
                java.awt.BorderLayout.CENTER);
        // Az informáló szövegdoboz
        infóTextArea = new javax.swing.JTextArea();
        // ez is legyen görgethető
        javax.swing.JScrollPane infóScrollPane
                = new javax.swing.JScrollPane();
        infóScrollPane.setViewportView(infóTextArea);
        infóScrollPane.setPreferredSize(new java.awt.Dimension(400, 100));
        getContentPane().add(infóScrollPane,  java.awt.BorderLayout.SOUTH);
        // Kezdeti informáló szöveg
        infóTextArea.append("Ez a Javat tanítok kézikönyv pontmátrix " +
                "példaprogramja\nA pontmátrix leírását lásd a " +
                "[BIOINFORMATIKA] hivatkozásban\n\n" +
                "A Fájl/Egyik minta... Másik minta... " +
                "menüpontok kiválasztásával tölts be a két mintát,\n" +
                "majd alkalmazhatod a Pontmátrix/Számol menüpontot.\n");
        // Lássuk!
        setVisible(true);
    }
    /** Eseménykezelés. */
    public void actionPerformed(java.awt.event.ActionEvent e) {
        
        String menü = e.getActionCommand();
        if("Egyik minta...".equals(menü)) {
            
            egyikMinta = betöltMinta();
            
        } else if("Másik minta...".equals(menü)) {
            
            másikMinta = betöltMinta();
            
        } else if("Számol".equals(menü)) {
            
            if(egyikMinta == null) {
                infóTextArea.append("A egyik minta nincs betöltve.\n");
                return;
            }
            if(másikMinta == null) {
                infóTextArea.append("A másik minta nincs betöltve.\n");
                return;
            }
            
            pontmátrixKép =
                    new java.awt.image.BufferedImage(egyikMinta.length,
                    másikMinta.length,
                    java.awt.image.BufferedImage.TYPE_INT_RGB);
            // A pontmátrix számítása:
            for(int i=0; i<egyikMinta.length; ++i) {
                for(int j=0; j<másikMinta.length; ++j) {
                    
                    pontmátrixKép.setRGB(i,j, 0x00ffffff);
                    if(egyikMinta[i] == másikMinta[j])
                        pontmátrixKép.setRGB(i,j, 0x00000000);
                    
                }
            }
            infóTextArea.append("Pontrátrix számítása kész.\n");
            // A kiszámolt pontmátrix megjelenítése
            pontmátrixVászon.beállítKép(pontmátrixKép);
            pontmátrixGörgető.setViewportView(pontmátrixVászon);
            
        } else if("Névjegy".equals(menü)) {
            
            // Egy informáló dialógus ablakot nyitunk a névjegynek:
            javax.swing.JOptionPane.showMessageDialog(null,
                    "Pontmátrix, 0.0.1 verzió\nJavat tanítok példaprogram",
                    "Névjegy", javax.swing.JOptionPane.INFORMATION_MESSAGE);
            
        } else if("Szűrés".equals(menü)) {
            
            if(pontmátrixKép == null) {
                infóTextArea.append("A pontmátrix nincs kiszámítva.\n");
                return;
            }
            // A pontmátrix szűrése:
            int ablakMéret = 7;
            for(int i=0; i<egyikMinta.length; ++i) {
                for(int j=0; j<másikMinta.length; ++j) {
                    int egyforma = 0;
                    for(int k = -ablakMéret; k<ablakMéret; ++k) {
                        if( i+k > 0 && i+k < egyikMinta.length
                                && j+k > 0 && j+k < másikMinta.length)
                            if(egyikMinta[i+k] == másikMinta[j+k])
                                ++egyforma;
                    }
                    pontmátrixKép.setRGB(i,j, 0x00ffffff);
                    if(egyforma > 2*ablakMéret-2)
                        pontmátrixKép.setRGB(i,j, 0x00000000);
                }
            }
            infóTextArea.append("Pontrátrix szűrése kész.\n");
            // A szűrt pontmátrix megjelenítése
            pontmátrixVászon.beállítKép(pontmátrixKép);
            pontmátrixGörgető.setViewportView(pontmátrixVászon);
            
        } else if("Mentés...".equals(menü)) {
            
            javax.swing.JFileChooser betöltő = new javax.swing.JFileChooser();
            betöltő.showSaveDialog(getContentPane());
            pillanatfelvétel(betöltő.getSelectedFile().getAbsolutePath());
            
        } else if("Kilépés".equals(menü)) {
            System.exit(0);
        }
    }
    /**
     * Fájl betöltése fájl kiválasztó ablakkal.
     *
     * @return byte [] a fájl tartalma, mint minta.
     */
    public byte [] betöltMinta() {
        
        javax.swing.JFileChooser betöltő = new javax.swing.JFileChooser();
        betöltő.showOpenDialog(getContentPane());
        java.io.File fájl = betöltő.getSelectedFile().getAbsoluteFile();
        
        byte [] buffer = new byte[(int)fájl.length()];
        
        try {
            java.io.FileInputStream fájlCsatorna =
                    new java.io.FileInputStream(fájl);
            
            fájlCsatorna.read(buffer, 0, buffer.length);
            
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
        
        infóTextArea.append("A " + fájl.getName() + " minta betöltve.\n");
        
        return buffer;
    }
    /** Pillanatfelvételek készítése. */
    public void pillanatfelvétel(String fájlNév) {
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(pontmátrixKép, "png",
                    new java.io.File(fájlNév));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }    
    /** Példányosít egy Pontmátrix obektumot.*/
    public static void main(String [] args) {
        new Pontmátrix();
    }
}            
            ]]>
            </programlisting>
                            
            <example>
                <title>Pontmátrix osztály kiegészítése</title>
                
                <para>A pontmátrix programunk névjegye mintájára
                dialógusablakokban is közöljük a program hibaüzeneteit a 
                felhasználó felé. Ezt a módszert alkalmaztuk a névjegy 
                információk megjelenítésénél:

            <programlisting>
            <![CDATA[           
        } else if("Névjegy".equals(menü)) {
            
            // Egy informáló dialógus ablakot nyitunk a névjegynek:
            javax.swing.JOptionPane.showMessageDialog(null,
                    "Pontmátrix, 0.0.1 verzió\nJavat tanítok példaprogram",
                    "Névjegy", javax.swing.JOptionPane.INFORMATION_MESSAGE);             
            ]]>
            </programlisting>
                                
                    </para>
                    <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/biol/nevjegy.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A pontmátrix programunk névjegye.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                           
                    </para>
                    <para>
                    
                    Ha például valamelyik minta még nincs
                betöltve, akkor ezt ne csak az 
                
            <programlisting>
            <![CDATA[
           
            if(egyikMinta == null) {
                infóTextArea.append("A egyik minta nincs betöltve.\n");
                return;
            }
             
            ]]>
            </programlisting>
            informáló ablakban, hanem egy dialógus ablakban is közöljük.                
            
            <programlisting>
            <![CDATA[           
            javax.swing.JOptionPane.showMessageDialog(null,
                    "A egyik minta nincs betöltve.",
                    "Hiba", javax.swing.JOptionPane.ERROR_MESSAGE);             
            ]]>
            </programlisting>
            
            
                </para>
                
            </example>

            <example>
                <title>További kísérletek a Pontmátrix osztályunkkal</title>
                
                <para>
                    <emphasis><link linkend="pi_jegyei">A Pi jegyeinek nyomában</link></emphasis>
                    pont programját felhasználva legenerálhatjuk a Pi hexadecimális
                    kifejtésének mondjuk első és második ezer hexa jegyét, majd
                    ezeket a pontmátrix módszerrel összehasonlíthatjuk. De mindkét
                    mintának az első ezer jegyet átadva afelől tudakolódhatunk, hogy
                    mennyire van ismétlődés ebben az ezer hexa jegyes szekvenciában
                    önmagában.
                </para>
                    
                <para>
                A következő <classname>TCAG2Hexa</classname> osztálybeli
                rövid kóddal az előző pontban említett 
                    emberi 2. kromoszóma genomjának
                    egy részét hexadecimális számjegyekké alakítva 
                    összevethetjük a
                    humán genom e részét például a Pi hexadecimális
                    kifejtésének számjegyeivel!
            
                    </para>
                    <para>
                        A <classname>TCAG2Hexa</classname> osztály
                        a bemenetéről olvasott T, C, A, G betűket
                        kettessével - mert 4 féle * 4 féle éppen 
                        16 - hexa 
                        számjegyekké alakítja:
                    
                    <programlisting>
                    <![CDATA[
public class TCAG2Hexa {
    
    public static void main(String[] args) throws Exception {
        
        Character hexaJegyek[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        
        boolean páratlan = false;
        int első=0, második=0;
        
        int i = 0;
        while((i=System.in.read()) != -1) {
            
            switch(i) {
                
                case 'T':
                    második = 0;
                    break;
                case 'C':
                    második = 1;
                    break;
                case 'A':
                    második = 2;
                    break;
                case 'G':
                    második = 3;
                    break;
            }
            
            if(páratlan) {
                
                int jegy = 4*első + második;
                
                if(jegy<10)
                    System.out.print(jegy);
                else
                    System.out.print(hexaJegyek[jegy-10]);
                
            }
                páratlan = !páratlan;
            első = második;                        
        }        
    }
}                    
                    ]]>
                    </programlisting>

                    A hexába konvertáló <classname>TCAG2Hexa</classname>
                    osztályt fordítva és futtatáskor a humán genom említett,
                    most 1875 betűt 
                    részét tartalmazó
                    <filename>2cgenom1875.fasta</filename> állomány tartalmát
                    beleirányítva a kimenetet a <filename>genom.hexa</filename>
                    állományban kapjuk.
                
                <screen>
                            <![CDATA[
C:\...> javac TCAG2Hexa.java
C:\...> java TCAG2Hexa <2cgenom1875.fasta > genom.hexa
                            ]]>
                </screen>                           
                    
                A kapott <filename>genom.hexa</filename> állományt és a Pi
                első ezer jegyét tartalmazó állományt adjuk majd át a pontmátrix
                programunknak. Ez persze egy erősen spekulatív példánk volt,
                de ha kirajzolódott volna egy átlós egyenes a pontmártixon, akkor
                talán hasonló élményünk lehetett volna, mint Mandelbrotnak, amikor
                rábukkant híres halmazára.                    
                    </para>
                    
                    </example>
            
            </sect3>
            <sect3>
                <title>A Swinges felület építésének alapszabálya</title>
                
                <para>
                    A Swinges felületek építésének alapszabálya, hogy 
                    ne csináltassunk időigényes dolgokat az
                    eseménykezelőkben, mivel
                    az eseménykezelést és a megjelenítést ugyanaz a programszál 
                    végzi, így
                    ha az eseménykezelőt egy hosszadalmas számítással blokkoljuk, 
                    akkor
                    ezzel egyben a felület megjelenítését is blokkoljuk, azaz 
                    lefagyasztjuk a programunk felületét!                
               </para>
               
                <para>
                    Szerezzünk most konkrét tapasztalatot az említett szabállyal
                    kapcsolatban! Például pontmátrix számoló programunknak 
                    inputként adjuk meg a 2. emberi kromoszóma egy
                    hozzávetőlegesen 2000 (T, C, A, G) nukleotid betűs 
                    részletét, az egyik és a 
                    másik mintaként is. Ebben az esetben a
                    szekvenciában az ismétlődő részeket tudjuk megfigyelni.
                    Az érdeklődő Olvasó a Humán Genom Projekt keretében
                    meghatározott emberi DNS adatokat a 
                    <ulink url="http://www.ncbi.nlm.nih.gov/genome/seq">http://www.ncbi.nlm.nih.gov/genome/seq</ulink>                
                    címen találhatja meg.
                    Erre a nagy, közel 2000x2000 pixel méretű képre a 
                    <guimenuitem>Szűrés</guimenuitem> menüpontot alkalmazva, amíg a szűrés 
                    be nem fejeződik, addig a felület lefagyott állapotban van, 
                    nem 
                    frissül és felhasználói eseményekre sem reagál, azaz 
                    hiába kattintunk például a <guimenuitem>Névjegy</guimenuitem> menüpontra, semmi
                    nem történik, amíg be nem fejeződik a szűrés.                    
               </para>
               
                    <para>
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/biol/genom.png" />
                        </imageobject>
                        <textobject>
                            <phrase>amíg a szűrés be nem fejeződik, addig a felület lefagyott állapotban van.</phrase>
                        </textobject>	
                    </inlinemediaobject>                                           
                    </para>
                
            </sect3>

        </sect2>    
            
        <sect2 id="conway">
            <title>Sejtautomata szimuláció programja</title>

            <para>
                Egy konkrét sejtautomatával - talán a legismertebb ilyennel - a 
                <emphasis>John Horton Conway-féle életjátékkal</emphasis>
                  (<citation>MATEK JÁTÉK</citation>, 
                 <citation>ÉLET CIKK</citation>)                
                foglalkozunk részletesen. Itt
                egy sejt egy sejttér eleme, a sejt állapota lehet élő vagy halott.
                A diszkrét időben működő sejttér adott sejtjének állapotát a 
                következő időpillanatban a következő átmeneti szabályok alapján
                számolhatjuk ki:
                <itemizedlist>
                    <listitem>
                      <para>
                        Élő sejt élő marad, ha kettő vagy három élő
                        szomszédja van, különben halott lesz.                          
                      </para>
                     </listitem>
                    <listitem>
                      <para>
                        Halott sejt halott marad, ha három élő
                        szomszédja van, különben élő lesz.
                       </para>
                     </listitem>
                </itemizedlist>                

                Ezeket az átmeneti szabályokat az 
                <function>időFejlődés()</function> függvényben fogalmaztuk meg:
                
                <programlisting>
                <![CDATA[
    public void időFejlődés() {
        
        boolean [][] rácsElőtte = rácsok[rácsIndex];
        boolean [][] rácsUtána = rácsok[(rácsIndex+1)%2];
        
        for(int i=0; i<rácsElőtte.length; ++i) { // sorok
            for(int j=0; j<rácsElőtte[0].length; ++j) { // oszlopok
                
                int élők = szomszédokSzáma(rácsElőtte, i, j, ÉLŐ);
                
                if(rácsElőtte[i][j] == ÉLŐ) {
                /* Élő élő marad, ha kettő vagy három élő
                 szomszedja van, különben halott lesz. */
                    if(élők==2 || élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }  else {
                /* Halott halott marad, ha három élő
                 szomszedja van, különben élő lesz. */
                    if(élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }
            }
        }
        rácsIndex = (rácsIndex+1)%2;
    }
                 
                ]]>
                </programlisting>
                
                
            </para>

            
                <programlisting>
                <![CDATA[
/*
 * Sejtautomata.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * Sejtautomata osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class Sejtautomata extends java.awt.Frame implements Runnable {
    /** Egy sejt lehet élő */
    public static final boolean ÉLŐ = true;
    /** vagy halott */
    public static final boolean HALOTT = false;
    /** Két rácsot használunk majd, az egyik a sejttér állapotát
     * a t_n, a másik a t_n+1 időpillanatban jellemzi. */
    protected boolean [][][] rácsok = new boolean [2][][];
    /** Valamelyik rácsra mutat, technikai jellegű, hogy ne kelljen a
     * [2][][]-ból az első dimenziót használni, mert vagy az egyikre
     * állítjuk, vagy a másikra. */
    protected boolean [][] rács;
    /** Megmutatja melyik rács az aktuális: [rácsIndex][][] */
    protected int rácsIndex = 0;
    /** Pixelben egy cella adatai. */
    protected int cellaSzélesség = 20;
    protected int cellaMagasság = 20;
    /** A sejttér nagysága, azaz hányszor hány cella van? */
    protected int szélesség = 20;
    protected int magasság = 10;
    /** A sejttér két egymást követő t_n és t_n+1 diszkrét időpillanata
     közötti valós idő. */  
    protected int várakozás = 1000;
    // Pillanatfelvétel készítéséhez
    private java.awt.Robot robot;
    /** Készítsünk pillanatfelvételt? */
    private boolean pillanatfelvétel = false;
    /** A pillanatfelvételek számozásához. */
    private static int pillanatfelvételSzámláló = 0;
    /**
     * Létrehoz egy <code>Sejtautomata</code> objektumot.
     *
     * @param      szélesség    a sejttér szélessége.
     * @param      magasság     a sejttér szélessége.
     */
    public Sejtautomata(int szélesség, int magasság) {
        this.szélesség = szélesség;
        this.magasság = magasság;
        // A két rács elkészítése
        rácsok[0] = new boolean[magasság][szélesség];
        rácsok[1] = new boolean[magasság][szélesség];
        rácsIndex = 0;
        rács = rácsok[rácsIndex];
        // A kiinduló rács minden cellája HALOTT
        for(int i=0; i<rács.length; ++i)
            for(int j=0; j<rács[0].length; ++j)
                rács[i][j] = HALOTT;
        // A kiinduló rácsra "élőlényeket" helyezünk
        //sikló(rács, 2, 2);
        siklóKilövő(rács, 5, 60);
        // Az ablak bezárásakor kilépünk a programból.
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
        // A billentyűzetről érkező események feldolgozása
        addKeyListener(new java.awt.event.KeyAdapter() {
            // Az 'k', 'n', 'l', 'g' és 's' gombok lenyomását figyeljük
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_K) {
                    // Felezük a cella méreteit:
                    cellaSzélesség /= 2;
                    cellaMagasság /= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    // Duplázzuk a cella méreteit:
                    cellaSzélesség *= 2;
                    cellaMagasság *= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel = !pillanatfelvétel;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_G)
                    várakozás /= 2;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_L)
                    várakozás *= 2;
                repaint();
            }
        });
        // Egér kattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            // Egér kattintással jelöljük ki a nagyítandó területet
            // bal felső sarkát vagy ugyancsak egér kattintással
            // vizsgáljuk egy adott pont iterációit:
            public void mousePressed(java.awt.event.MouseEvent m) {
                // Az egérmutató pozíciója
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = !rácsok[rácsIndex][y][x];
                repaint();
            }
        });
        // Egér mozgás események feldolgozása:
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            // Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = ÉLŐ;
                repaint();
            }
        });
        // Cellaméretek kezdetben
        cellaSzélesség = 10;
        cellaMagasság = 10;
        // Pillanatfelvétel készítéséhez:
        try {
            robot = new java.awt.Robot(
                    java.awt.GraphicsEnvironment.
                    getLocalGraphicsEnvironment().
                    getDefaultScreenDevice());
        } catch(java.awt.AWTException e) {
            e.printStackTrace();
        }
        // A program ablakának adatai:
        setTitle("Sejtautomata");
        setResizable(false);
        setSize(szélesség*cellaSzélesség,
                magasság*cellaMagasság);
        setVisible(true);
        // A sejttér életrekeltése:
        new Thread(this).start();
    }
    /** A sejttér kirajzolása. */
    public void paint(java.awt.Graphics g) {
        // Az aktuális
        boolean [][] rács = rácsok[rácsIndex];
        // rácsot rajzoljuk ki:
        for(int i=0; i<rács.length; ++i) { // végig lépked a sorokon
            for(int j=0; j<rács[0].length; ++j) { // s az oszlopok
                // Sejt cella kirajzolása
                if(rács[i][j] == ÉLŐ)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
                // Rács kirajzolása
                g.setColor(java.awt.Color.LIGHT_GRAY);
                g.drawRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
            }
        }
        // Készítünk pillanatfelvételt?
        if(pillanatfelvétel) {
            // a biztonság kedvéért egy kép készítése után
            // kikapcsoljuk a pillanatfelvételt, hogy a
            // programmal ismerkedő Olvasó ne írja tele a
            // fájlrendszerét a pillanatfelvételekkel
            pillanatfelvétel = false;
            pillanatfelvétel(robot.createScreenCapture
                    (new java.awt.Rectangle
                    (getLocation().x, getLocation().y,
                    szélesség*cellaSzélesség,
                    magasság*cellaMagasság)));
        }
    }
    /**
     * Az kérdezett állapotban lévő nyolcszomszédok száma.
     *
     * @param   rács    a sejttér rács
     * @param   sor     a rács vizsgált sora
     * @param   oszlop  a rács vizsgált oszlopa
     * @param   állapor a nyolcszomszédok vizsgált állapota
     * @return int a kérdezett állapotbeli nyolcszomszédok száma.
     */
    public int szomszédokSzáma(boolean [][] rács,
            int sor, int oszlop, boolean állapot) {        
        int állapotúSzomszéd = 0;
        // A nyolcszomszédok végigzongorázása:
        for(int i=-1; i<2; ++i)
            for(int j=-1; j<2; ++j)
                // A vizsgált sejtet magát kihagyva:
                if(!((i==0) && (j==0))) {
            // A sejttérből szélének szomszédai
            // a szembe oldalakon ("periódikus határfeltétel")
            int o = oszlop + j;
            if(o < 0)
                o = szélesség-1;
            else if(o >= szélesség)
                o = 0;
            
            int s = sor + i;
            if(s < 0)
                s = magasság-1;
            else if(s >= magasság)
                s = 0;
            
            if(rács[s][o] == állapot)
                ++állapotúSzomszéd;
                }
        
        return állapotúSzomszéd;
    }
    /**
     * A sejttér időbeli fejlődése a John H. Conway féle
     * életjáték sejtautomata szabályai alapján történik.
     * A szabályok részletes ismertetését lásd például a
     * [MATEK JÁTÉK] hivatkozásban (Csákány Béla: Diszkrét
     * matematikai játékok. Polygon, Szeged 1998. 171. oldal.)
     */
    public void időFejlődés() {
        
        boolean [][] rácsElőtte = rácsok[rácsIndex];
        boolean [][] rácsUtána = rácsok[(rácsIndex+1)%2];
        
        for(int i=0; i<rácsElőtte.length; ++i) { // sorok
            for(int j=0; j<rácsElőtte[0].length; ++j) { // oszlopok
                
                int élők = szomszédokSzáma(rácsElőtte, i, j, ÉLŐ);
                
                if(rácsElőtte[i][j] == ÉLŐ) {
                /* Élő élő marad, ha kettő vagy három élő
                 szomszedja van, különben halott lesz. */
                    if(élők==2 || élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }  else {
                /* Halott halott marad, ha három élő
                 szomszedja van, különben élő lesz. */
                    if(élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }
            }
        }
        rácsIndex = (rácsIndex+1)%2;
    }
    /** A sejttér időbeli fejlődése. */
    public void run() {
        
        while(true) {
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
            
            időFejlődés();
            repaint();
        }
    }
    /**
     * A sejttérbe "élőlényeket" helyezünk, ez a "sikló".
     * Adott irányban halad, másolja magát a sejttérben.
     * Az élőlény ismertetését lásd például a
     * [MATEK JÁTÉK] hivatkozásban (Csákány Béla: Diszkrét
     * matematikai játékok. Polygon, Szeged 1998. 172. oldal.)
     *
     * @param   rács    a sejttér ahová ezt az állatkát helyezzük
     * @param   x       a befoglaló tégla bal felső sarkának oszlopa
     * @param   y       a befoglaló tégla bal felső sarkának sora
     */
    public void sikló(boolean [][] rács, int x, int y) {
        
        rács[y+ 0][x+ 2] = ÉLŐ;
        rács[y+ 1][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 2] = ÉLŐ;
        rács[y+ 2][x+ 3] = ÉLŐ;
        
    }
    /**
     * A sejttérbe "élőlényeket" helyezünk, ez a "sikló ágyú".
     * Adott irányban siklókat lő ki.
     * Az élőlény ismertetését lásd például a
     * [MATEK JÁTÉK] hivatkozásban /Csákány Béla: Diszkrét
     * matematikai játékok. Polygon, Szeged 1998. 173. oldal./,
     * de itt az ábra hibás, egy oszloppal told még balra a 
     * bal oldali 4 sejtes négyzetet. A helyes ágyú rajzát 
     * lásd pl. az [ÉLET CIKK] hivatkozásban /Robert T. 
     * Wainwright: Life is Universal./ (Megemlíthetjük, hogy
     * mindkettő tartalmaz két felesleges sejtet is.)
     *
     * @param   rács    a sejttér ahová ezt az állatkát helyezzük
     * @param   x       a befoglaló tégla bal felső sarkának oszlopa
     * @param   y       a befoglaló tégla bal felső sarkának sora
     */    
    public void siklóKilövő(boolean [][] rács, int x, int y) {
        
        rács[y+ 6][x+ 0] = ÉLŐ;
        rács[y+ 6][x+ 1] = ÉLŐ;
        rács[y+ 7][x+ 0] = ÉLŐ;
        rács[y+ 7][x+ 1] = ÉLŐ;
        
        rács[y+ 3][x+ 13] = ÉLŐ;
        
        rács[y+ 4][x+ 12] = ÉLŐ;
        rács[y+ 4][x+ 14] = ÉLŐ;
        
        rács[y+ 5][x+ 11] = ÉLŐ;
        rács[y+ 5][x+ 15] = ÉLŐ;
        rács[y+ 5][x+ 16] = ÉLŐ;
        rács[y+ 5][x+ 25] = ÉLŐ;
        
        rács[y+ 6][x+ 11] = ÉLŐ;
        rács[y+ 6][x+ 15] = ÉLŐ;
        rács[y+ 6][x+ 16] = ÉLŐ;
        rács[y+ 6][x+ 22] = ÉLŐ;
        rács[y+ 6][x+ 23] = ÉLŐ;
        rács[y+ 6][x+ 24] = ÉLŐ;
        rács[y+ 6][x+ 25] = ÉLŐ;
        
        rács[y+ 7][x+ 11] = ÉLŐ;
        rács[y+ 7][x+ 15] = ÉLŐ;
        rács[y+ 7][x+ 16] = ÉLŐ;
        rács[y+ 7][x+ 21] = ÉLŐ;
        rács[y+ 7][x+ 22] = ÉLŐ;
        rács[y+ 7][x+ 23] = ÉLŐ;
        rács[y+ 7][x+ 24] = ÉLŐ;
        
        rács[y+ 8][x+ 12] = ÉLŐ;
        rács[y+ 8][x+ 14] = ÉLŐ;
        rács[y+ 8][x+ 21] = ÉLŐ;
        rács[y+ 8][x+ 24] = ÉLŐ;
        rács[y+ 8][x+ 34] = ÉLŐ;
        rács[y+ 8][x+ 35] = ÉLŐ;
        
        rács[y+ 9][x+ 13] = ÉLŐ;
        rács[y+ 9][x+ 21] = ÉLŐ;
        rács[y+ 9][x+ 22] = ÉLŐ;
        rács[y+ 9][x+ 23] = ÉLŐ;
        rács[y+ 9][x+ 24] = ÉLŐ;
        rács[y+ 9][x+ 34] = ÉLŐ;
        rács[y+ 9][x+ 35] = ÉLŐ;
        
        rács[y+ 10][x+ 22] = ÉLŐ;
        rács[y+ 10][x+ 23] = ÉLŐ;
        rács[y+ 10][x+ 24] = ÉLŐ;
        rács[y+ 10][x+ 25] = ÉLŐ;
        
        rács[y+ 11][x+ 25] = ÉLŐ;
        
    }
    /** Pillanatfelvételek készítése. */
    public void pillanatfelvétel(java.awt.image.BufferedImage felvetel) {
        // A pillanatfelvétel kép fájlneve
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("sejtautomata");
        sb.append(++pillanatfelvételSzámláló);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(felvetel, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    // Ne villogjon a felület (mert a "gyári" update()
    // lemeszelné a vászon felületét).    
    public void update(java.awt.Graphics g) {
        paint(g);
    }    
    /**
     * Példányosít egy Conway-féle életjáték szabályos
     * sejttér obektumot.
     */    
    public static void main(String[] args) {
        // 100 oszlop, 75 sor mérettel:
        new Sejtautomata(100, 75);
    }
}                
                ]]>
                </programlisting>
            
            <para>
                Könnyen végezhetünk saját szimulációkat az osztály imént megadott
                kódjával. Jelöljük ki a forrásszöveget és illesszük be egy
                <filename>Sejtautomata.java</filename> nevű állományba, majd fordítsuk az 
                állományt és futtassuk a számítást:
                
                <screen>
                            <![CDATA[
C:\...> javac Sejtautomata.java
C:\...> java Sejtautomata
                            ]]>
                </screen>                 
                
                 A program futása alatt az <keycap>s</keycap> billentyűt
                 lenyomva a sejttér aktuális pillanatbeli állapotáról
                 egy felvételt készít a 
                 program. A készített képeket abban a könyvtárban találjuk, ahonnan a 
                 programot a fent ajánlott módon elindítottuk. 
                </para>                 
                
                <para>                 
                 Korábbi tárgyalásunknak megfelelően a program a
                 következő inputokat dolgoza fel:
                 
                <itemizedlist>
                    <listitem>
                      <para>
                        Az <keycap>s</keycap> billentyű
                        lenyomásával egy felvétel kép készül a sejttér aktuális állapotáról.                           
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        Az <keycap>n</keycap> billentyű
                        lenyomásával növeljük a sejtek méretét.
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        A <keycap>k</keycap> billentyű
                        lenyomásával csökkentjük a sejtek méretét.
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        A <keycap>g</keycap> billentyű
                        lenyomásával csökkentjük a sejttér két diszkrét állapota
                        közötti valóságos időt, azaz gyorsítjuk a szimulációt.
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        Az <keycap>l</keycap> billentyű
                        lenyomásával lassítjuk a szimulációt.
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        Az egérmutató jobb vagy bal gombjával egy sejt állapotát az
                        ellenkezőjére változtatjuk.
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        Az egérmutató vonszolásával az érintett sejteket élő
                        állapotba kapcsoljuk.
                      </para>                      
                 </listitem>
                 </itemizedlist>
                 
            </para>                          
            <para id="siklo_agyu">                                           
                 A következő ábrasorozaton bemutatjuk az R. W. Gosper
                 találta 
                 <citation>MATEK JÁTÉK</citation>,
                 <citation>ÉLET CIKK</citation>
                 „sikló ágyú” élőlényt üzem közben (az első
                 hivatkozásban közölt ágyú picit hibás, ezért csak három
                 lövést ad le, de mindkét hivatkozás tartalmaz két felesleges
                 sejtet).
                 
            </para>                          
                 
                 
           
                            <table frame="all">
                                <title>Az R. W. Gosper-féle sikló ágyú élőlény bemutatása</title>
                                <tgroup cols="2">
                                    <tbody>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata1.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata2.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata3.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata4.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata5.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata6.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata7.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata8.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata9.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata10.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata11.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata12.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata13.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata14.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata15.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata16.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata17.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata18.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata19.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata20.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata21.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata22.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata23.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata24.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata25.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata26.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata27.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata28.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata29.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata30.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata31.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata32.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata33.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata34.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata35.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata36.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata37.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata38.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata39.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata40.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata41.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata42.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata43.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata44.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata45.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata46.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata47.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata48.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata49.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata50.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata51.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata52.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata53.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata54.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata55.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata56.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata57.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata58.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata59.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata60.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata61.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata62.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata63.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata64.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata65.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata66.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata67.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata68.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata69.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata70.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata71.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata72.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata73.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata74.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata75.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata76.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata77.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata78.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata79.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                            <entry>
                                                <para>
                                                <inlinemediaobject>
                                                    <imageobject>
                                                        <imagedata fileref="images/sejtaut/sejtautomata80.png" />
                                                    </imageobject>
                                                    <textobject>
                                                        <phrase>A sikló ágyú üzemben.</phrase>
                                                    </textobject>	
                                                </inlinemediaobject>                       
                                                </para>
                                            </entry>
                                        </row>
                                        
                                        </tbody>
                                        </tgroup>
                                        </table>                
                
        </sect2>
        
        <sect2>
            <title>Orch OR demonstrációk</title>

            <para>
                A mikrotubulus sejtautomata - szemben az előző pont példájával -
                nem négy vagy nyolc szomszéddal dolgozik, hanem amint a 
                <emphasis><link linkend="hameroff_mikrotubulus_sejtautomata">Hameroff mikrotubulus sejtautomatái</link></emphasis> című 
                 pontban megmutattuk, egy hexagonális rácson, ahol egy adott
                sejtnek hat szomszédja van. 
            </para>
            
            <sect3>
                <title>Hexagonális rács</title>

                <para>
                    Ilyen hexagonális rácsot geometriailag könnyen
                    kaphatunk, ha klasszikus tömbünket (rácsunkat) lerajzoljuk
                    és minden második
                    oszlopát egy rajzolt cella felével eltoljuk. Azért használjuk
                    ezt a triviális szemléletbeli képet, mert a klasszikus tömbök
                    kezelése - lévén, hogy elemei a Java nyelvnek - egyszerű.
                    
                    <inlinemediaobject>
                        <objectinfo>
                            <title>Hexagonális rács eltolással egy mátrixból.</title>
                        </objectinfo>
                        <imageobject>
                            <imagedata fileref="images/mikrotubulus/hexaracs.png" />
                        </imageobject>
                        <textobject>
                            <phrase>Hexagonális rács eltolással egy mátrixból.</phrase>
                        </textobject>
                    </inlinemediaobject>                    
                    
                    Tehát, ha klasszikus tömböket akarunk használni a 
                    szimuláció programozásánál, csak arra kell figyelni, hogy 
                    az eltolt rácson lévő adott sejt hat szomszédai kik lesznek a
                    klasszikusra visszatolt rácson?

                    <inlinemediaobject>
                        <objectinfo>
                            <title>Kik a szomszédok az eltolásos hexagonális rácsunkon?</title>
                        </objectinfo>
                        <imageobject>
                            <imagedata fileref="images/mikrotubulus/hexaszomszed.png" />
                        </imageobject>
                        <textobject>
                            <phrase>Kik a szomszédok az eltolásos hexagonális rácsunkon?</phrase>
                        </textobject>
                    </inlinemediaobject>                     
                    
                    Az ábráról leolvasható, hogy triviálisan tudunk szokásos tömböket használni,
                    amiket majd a megjelenítés során, második oszloponként eltolva rajzolunk ki.
                    A szomszédok pozíciója pedig attól függ, hogy eltolt vagy nem eltolt
                    oszlopban van-e a vizsgált sejt.
                </para>

				<sect4>
                <title>A Mikrotubulus osztály</title>
            
                <para>
                GUI programozási szempontból tartjuk fontosnak megjegyezni, hogy
                a <classname>Mikrotubulus</classname> osztály közvetlenül önmagára rajzol,
                jobb gyakorlat egy az ablakra helyezett vászonra vagy képre rajzolni.
                Az utóbbira például a kézikönyv 
                <emphasis><link linkend="mandelbrot_halmaz">Mandelbrot halmaz</link></emphasis>
                című pontjában láthatunk példát. 
                Itt a <classname>MandelbrotHalmaz</classname> 
                osztály <function>pillanatfelvétel()</function> pillanatfelvételt
                készítő függvényében 
                használjuk ki például a képre rajzolást. 
                </para>
                
					<programlisting>
						<![CDATA[
/*
 * Mikrotubulus.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * Orch OR sejtautomata demonstráció.
 * A jelen szimulációs vagy pontosabban csupán - az [ORCH OR] Stuart
 * Hameroff és Roger Penrose, Orchestrated Objective Reduction of
 * Quantum Coherence in Brain Microtubules: The “Orch OR” Model for
 * Consciousmess,
 * http://www.quantumconsciousness.org/penrose-hameroff/orchOR.html
 * [ORCH OR TUDAT] Stuart Hameroff és Roger Penrose, Conscious Events
 * as Orchestrated Space-Time Selections,
 * http://www.quantumconsciousness.org/penrosehameroff/consciousevents.html
 * cikkek képei alapján készített - demonstrációs osztály azt mutatja,
 * hogy egyre több tubulin dimer kerül koherens állapotba, míg az
 * objektív redukció következtében egy előre nem kiszámítható módon
 * ugranak a résztvevő cellák valamely lehetséges állapotukba,
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class Mikrotubulus extends java.awt.Frame implements Runnable {
    /** Rácspont az egyik állapotában. */
    public static final int EGYIK = 0;
    /** Rácspont a másik állapotában. */
    public static final int MÁSIK = 1;
    /** Rácspont az összefonódott állapotban. */
    public static final int SZUPER = 2;
    /** Hány összefonódott rácspont indítja be az OR-t? */
    public static final int EGY_GRAVITON_SZINTNYI = 235;
    /** Két ráccsal dolgozunk: a diszkrét időskála adott
     * pillanata előtti és utáni rácsot írjuk le velük. */
    int [][][] hexagonálisRácsok = new int [2][][];
    /** Melyik az éppen aktuális rács? */
    int [][] hexagonálisRács;
    /** A 0. vagy az 1. ? */
    int rácsIndex = 0;
    /* A kirajzolás adatai: */
    int cellaSzélesség = 20;
    int cellaMagasság = 20;
    /* A rács adatai: */
    int szélesség = 13;
    int magasság = 20;
    // Technikai:
    java.util.Random random = new java.util.Random();
    /* Képek a kirajzoláshoz */
    java.awt.Image fehérKép;
    java.awt.Image feketeKép;
    java.awt.Image pirosKép;
    // A pillanatfelvételekhez, technikai:
    java.awt.Robot robot;
    /**
     * Az adott méretű {@code Mikrotubulus} objektumot
     * felépítő konstruktor.
     *
     * @param   szélesség  tubulin-dimerek száma vízszintesen
     * @param   magasság  tubulin-dimerek száma függőlegesen
     */
    public Mikrotubulus(int szélesség, int magasság) {
        
        this.szélesség = szélesség;
        this.magasság = magasság;
        // A diszkrét időskála adott
        // pillanata előtti és utáni rácsok:
        hexagonálisRácsok[0] = new int[magasság][szélesség];
        hexagonálisRácsok[1] = new int[magasság][szélesség];
        
        hexagonálisRács = hexagonálisRácsok[rácsIndex];
        // a rácspontok egy véletlen állapotából indul a sejtautomata
        for(int i=0; i<hexagonálisRács.length; ++i)
            for(int j=0; j<hexagonálisRács[0].length; ++j)
                hexagonálisRács[i][j] = random.nextInt(2);
        // innen indul ki egy összefonódás
        hexagonálisRács[10][6] = SZUPER;
        
        // a program ablaka, amit be is lehet csukni
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
        // Képek betöltése
        fehérKép = new javax.swing.ImageIcon
                ("fehér.png").getImage();
        feketeKép = new javax.swing.ImageIcon
                ("fekete.png").getImage();
        pirosKép = new javax.swing.ImageIcon
                ("piros.png").getImage();
        
        cellaSzélesség = fehérKép.getWidth(this);
        cellaMagasság = fehérKép.getHeight(this);
        
        // a lokális grafikus környezet elkérése
        java.awt.GraphicsEnvironment graphicsEnvironment
                = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment();
        // a grafikus környzetből a képernyővel dolgozunk
        java.awt.GraphicsDevice graphicsDevice
                = graphicsEnvironment.getDefaultScreenDevice();
        try {
            robot = new java.awt.Robot(graphicsDevice);
        } catch(java.awt.AWTException e) {
            e.printStackTrace();
        }
        
        // Ablak jellemzőinek beállítása
        setTitle("Mikrotubulus");
        setResizable(false);
        //setUndecorated(true);
        
        setSize(szélesség*cellaSzélesség,
                magasság*cellaMagasság);
        setVisible(true);
        
        // Szimulációs (demonstrációs) szál elkészítése és beindítása
        new Thread(this).start();
    }
    /* A felület kirajzolása */
    public void paint(java.awt.Graphics g) {
        // Éppen melyik rácsot kell rajzolnunk:
        int [][] hexagonálisRács = hexagonálisRácsok[rácsIndex];
        // "Töröljük" a felületet (ha villog, töröljünk a
        // következő ciklusban kis darabokat)
        g.setColor(java.awt.Color.GRAY);
        g.fillRect(0,0, szélesség*cellaSzélesség,
                magasság*cellaMagasság);
        // Végigmegyünk a rácspontokon:
        for(int i=0; i<hexagonálisRács.length; ++i) { // sorok
            for(int j=0; j<hexagonálisRács[0].length; ++j) { // oszlopok
                
               /* Csak a rácsot rajzolja
                
                g.setColor(java.awt.Color.BLACK);
                g.drawRect(j*20, i*20+(j%2)*10, 20, 20);
                
                 Csak a rácsot rajzolja */
                
                /* Nem képeket, színes téglalapokat rajzol
                 
                if(hexagonálisRács[i][j] == EGYIK)
                    g.setColor(java.awt.Color.BLACK);
                else if(hexagonálisRács[i][j] == MÁSIK)
                    g.setColor(java.awt.Color.WHITE);
                else
                    g.setColor(java.awt.Color.RED);
                 
                // a +(j%2)*10 a páratlanadik oszlopokat
                // lefelé tolja
                g.fillRect(j*20, i*20+(j%2)*10, 20, 20);
                 
                Nem képeket, színes téglalapokat rajzol */
                
                // A szimulációs képeket rajzolja
                
                if(hexagonálisRács[i][j] == EGYIK)
                    g.drawImage(fehérKép, j*fehérKép.getWidth(this),
                            i*fehérKép.getHeight(this)
                            +(j%2)*(fehérKép.getHeight(this)/2), null);
                else if(hexagonálisRács[i][j] == MÁSIK)
                    g.drawImage(feketeKép, j*feketeKép.getWidth(this),
                            i*feketeKép.getHeight(this)
                            +(j%2)*(fehérKép.getHeight(this)/2), null);
                else
                    g.drawImage(pirosKép, j*pirosKép.getWidth(this),
                            i*pirosKép.getHeight(this)
                            +(j%2)*(fehérKép.getHeight(this)/2), null);
                
                // A szimulációs képeket rajzolja
            }
        }
        
        boolean pillanatfelvetel = false;
        if(pillanatfelvetel) {
            pillanatfelvetel = false;
            pillanatfelvetel(robot.createScreenCapture
                    (new java.awt.Rectangle
                    (0, 0, szélesség*cellaSzélesség,
                    magasság*cellaMagasság)));
        }
    }
    /* Technikai a villogás ellen (nem meszeli le a hátteret az update(),
     mert most felüldefiniáljuk meszelés nélkül). */
    public void update(java.awt.Graphics g) {
        paint(g);
    }
    // A pillanatfelvételek számozásához
    public static int fotoSzamlalo = 0;
    /** ScreenShot készítése. */
    public void pillanatfelvetel(java.awt.image.BufferedImage felvetel) {
        // tech. a sztringezéshez: a képfájl nevének előállítása
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("mikrotubulus");
        sb.append(++fotoSzamlalo);
        sb.append(".png");
        // a kép mentése
        try {
            // png-t mentünk
            javax.imageio.ImageIO.write(felvetel, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    /**
     * A rács adott cellájának hány szomszéda van a kérdezett állapotban?
     */
    public int szomszédokSzáma(int [][] hexagonálisRács,
            int sor, int oszlop, int állapot) {
        
        int állapotúSzomszéd = 0;
        
        if(oszlop%2 == 1) {
            
            if(sor-1>0)
                if(hexagonálisRács[sor-1][oszlop] == állapot)
                    ++állapotúSzomszéd;
            if(sor+1<magasság)
                if(hexagonálisRács[sor+1][oszlop] == állapot)
                    ++állapotúSzomszéd;
            
            if(oszlop-1>0) {
                if(hexagonálisRács[sor][oszlop-1] == állapot)
                    ++állapotúSzomszéd;
                if(sor+1<magasság)
                    if(hexagonálisRács[sor+1][oszlop-1] == állapot)
                        ++állapotúSzomszéd;
            }
            
            if(oszlop+1<szélesség) {
                if(hexagonálisRács[sor][oszlop+1] == állapot)
                    ++állapotúSzomszéd;
                if(sor+1<magasság)
                    if(hexagonálisRács[sor+1][oszlop+1] == állapot)
                        ++állapotúSzomszéd;
            }
            
        } else {
            
            if(sor-1>0)
                if(hexagonálisRács[sor-1][oszlop] == állapot)
                    ++állapotúSzomszéd;
            if(sor+1<magasság)
                if(hexagonálisRács[sor+1][oszlop] == állapot)
                    ++állapotúSzomszéd;
            
            if(oszlop-1>0) {
                if(hexagonálisRács[sor][oszlop-1] == állapot)
                    ++állapotúSzomszéd;
                if(sor-1>0)
                    if(hexagonálisRács[sor-1][oszlop-1] == állapot)
                        ++állapotúSzomszéd;
            }
            
            if(oszlop+1<szélesség) {
                if(hexagonálisRács[sor][oszlop+1] == állapot)
                    ++állapotúSzomszéd;
                if(sor-1>0)
                    if(hexagonálisRács[sor-1][oszlop+1] == állapot)
                        ++állapotúSzomszéd;
            }
            
        }
        
        return állapotúSzomszéd;
    }
    /** Van összefonódott állapotban lévő szomszédja a rács
     * adott cellájának? */
    public boolean vanSzuperSzomszéd(int [][] hexagonálisRács,
            int sor, int oszlop) {
        
        if(oszlop%2 == 1) {
            
            if(sor-1>0)
                if(hexagonálisRács[sor-1][oszlop] == SZUPER)
                    return true;
            if(sor+1<magasság)
                if(hexagonálisRács[sor+1][oszlop] == SZUPER)
                    return true;
            
            if(oszlop-1>0) {
                if(hexagonálisRács[sor][oszlop-1] == SZUPER)
                    return true;
                if(sor+1<magasság)
                    if(hexagonálisRács[sor+1][oszlop-1] == SZUPER)
                        return true;
            }
            
            if(oszlop+1<szélesség) {
                if(hexagonálisRács[sor][oszlop+1] == SZUPER)
                    return true;
                if(sor+1<magasság)
                    if(hexagonálisRács[sor+1][oszlop+1] == SZUPER)
                        return true;
            }
            
        } else {
            
            if(sor-1>0)
                if(hexagonálisRács[sor-1][oszlop] == SZUPER)
                    return true;
            if(sor+1<magasság)
                if(hexagonálisRács[sor+1][oszlop] == SZUPER)
                    return true;
            
            if(oszlop-1>0) {
                if(hexagonálisRács[sor][oszlop-1] == SZUPER)
                    return true;
                if(sor-1>0)
                    if(hexagonálisRács[sor-1][oszlop-1] == SZUPER)
                        return true;
            }
            
            if(oszlop+1<szélesség) {
                if(hexagonálisRács[sor][oszlop+1] == SZUPER)
                    return true;
                if(sor-1>0)
                    if(hexagonálisRács[sor-1][oszlop+1] == SZUPER)
                        return true;
            }
            
        }
        
        return false;
    }
    /** A szimuláció időfejlődése, diszkrét időskálán dolgozunk. */
    public void időFejlődés() {
        
        /* Két ráccsal dolgozunk: a diszkrét időskála adott
           pillanata előtti és utáni ráccsal: */        
        int [][] hexagonálisRácsElőtte = hexagonálisRácsok[rácsIndex];
        int [][] hexagonálisRácsUtána = hexagonálisRácsok[(rácsIndex+1)%2];
        
        // Hány összefonódott van ebben az időpillanatban?
        int szuperszámláló = 0;
        
        for(int i=0; i<hexagonálisRácsElőtte.length; ++i) { // sorok
            for(int j=0; j<hexagonálisRácsElőtte[0].length; ++j) { // oszlopok
                
                if(hexagonálisRácsElőtte[i][j] == SZUPER) {
                    // Összefonódott az is marad
                    hexagonálisRácsUtána[i][j] = hexagonálisRácsElőtte[i][j];
                    ++szuperszámláló;
                    
                } else {
                    // Egyébként a következő, hasraütésre vett
                    // átmeneti szabályokat alkalmazzuk:
                    if(vanSzuperSzomszéd(hexagonálisRácsElőtte, i, j)) {
                        
                        if(random.nextInt(4) > 0) {
                            hexagonálisRácsUtána[i][j] = SZUPER;
                            ++szuperszámláló;
                        }
                        
                    } else if(random.nextInt(125) == 0) {
                        
                        hexagonálisRácsUtána[i][j] = SZUPER;
                        ++szuperszámláló;
                        
                    } else {
                        
                        int egyik = szomszédokSzáma(hexagonálisRácsElőtte,
                                i, j, EGYIK);
                        int másik = szomszédokSzáma(hexagonálisRácsElőtte,
                                i, j, MÁSIK);
                        
                        if(hexagonálisRácsElőtte[i][j] == EGYIK) {
                            
                            if(egyik == másik)
                                hexagonálisRácsUtána[i][j] = MÁSIK;
                            
                        }  else {
                            
                            if(másik < egyik)
                                hexagonálisRácsUtána[i][j] = EGYIK;
                            else
                                hexagonálisRácsUtána[i][j] = MÁSIK;
                            
                        }
                    }
                }
                // ha elértük az egy graviton szintet, akkor
                // bekövetkezik 
                if(szuperszámláló >= EGY_GRAVITON_SZINTNYI) {
                    // az OR folyamat:
                    állapotvektorRedukció();
                    szuperszámláló = 0;
                }
            }
        }
        // a régi rács lesz az új:
        rácsIndex = (rácsIndex+1)%2;
    }    
    /** Az OR folyamat demonstrációja. */
    public void állapotvektorRedukció() {
        
        int [][] hexagonálisRács1 = hexagonálisRácsok[rácsIndex];
        
        for(int i=0; i<hexagonálisRács.length; ++i)
            for(int j=0; j<hexagonálisRács[0].length; ++j) {
            if(hexagonálisRácsok[0][i][j] == SZUPER ||
                    hexagonálisRácsok[1][i][j] == SZUPER) {
                hexagonálisRácsok[0][i][j] = random.nextInt(2);
                hexagonálisRácsok[1][i][j] = hexagonálisRácsok[0][i][j];
            }
            }
        
        hexagonálisRácsok[0][2+random.nextInt(magasság-2)]
                [2+random.nextInt(szélesség-2)] = SZUPER;
        hexagonálisRácsok[1][2+random.nextInt(magasság-2)]
                [2+random.nextInt(szélesség-2)] = SZUPER;
        
    }
    /** A szimulációs szál időfejlődése. */
    public void run() {
        
        while(true) {
            try {
                
                Thread.sleep(500);
                
            } catch (InterruptedException e) {}
            
            időFejlődés();
            repaint();
        }
    }
    
    public static void main(String[] args) {
        new Mikrotubulus(13, 20);
    }
}						
						]]>
					</programlisting>            

                <para>
                Megjegyezhetjük, hogy ha az időfejlődésben a
                <computeroutput>Thread.sleep(50);</computeroutput> mósodított
                utasítást alkalmazzuk, akkor - az általunk alkalmazott öszefonódási 
                fejlődés mellett, ami körülbelül 10 diszkrét időpillanat - hozzávetőlegesen 
                fél másodpercenként látjuk
                bekövetkezni az OR folyamatot.
                </para>
                
				<para>
                A demonstrációs programot magunk is kipróbálhatjuk. Ehhez ne fejeljtsük el a 
                tubulin fehérjék konformációs állapotait reprezentáló
                <filename>fehér.png</filename>, 
                <filename>fekete.png</filename> és 
                <filename>piros.png</filename>
                képeket a munkakönyvtárunkba másolni. Ezeket a 
				<emphasis><link linkend="forras_letoltes">A példaprogramok forrásainak letöltése</link></emphasis>                 című pontban ismertetett és belinkelt 
				<filename>javat_tanitok_kepek.zip</filename> állományban találja meg a kedves Olvasó.
			Ezután
                jelöljük ki az iménti forrásszöveget és illesszük be egy
                <filename>Mikrotubulus.java</filename> nevű állományba, aztán fordítsuk az 
                állományt és futtassuk a számítást:
                
                <screen>
                            <![CDATA[
C:\...> javac Mikrotubulus.java
C:\...> java Mikrotubulus
                            ]]>
                </screen>                 
                
                Eredményül a kézikönyvben már korábban, a 
				<emphasis><link linkend="orch_or">Mikrotubulus sejtautomata szimuláció</link></emphasis>                 című pontban tárgyalt
                 képekhez hasonlóakat kapunk.
                </para>
                
                
                </sect4>
                
            </sect3>
                        
        </sect2>
        
    </sect1>        

    <sect1 id="mat_java">
        <title>Matematikai témájú programok</title>
        
        <para>
        </para>

        <sect2 id="galton_program">
            <title>Galton deszka kísérlet programja</title>

            <para>
                Magát a kísérletet a 
                <emphasis><link linkend="galton_kiserlet">Galton deszka kísérlet</link></emphasis>
                című pontban ismertettük. Most megadjuk a kísérleti elrendezést
                absztraháló, általunk készített osztály kódját is.
            </para>
            
            <programlisting>
                <![CDATA[
/*
 * GaltonDeszka.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A Galton deszka kísérletet szimuláló osztály.
 * A kísérlet leírását lásd a [RÉNYI VALSÉG KÖNYV] (Rényi
 * Alfréd: Valószínűségszámítás, Tankönyvkiadó, 1973, 144 o.) 
 * könyvben.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class GaltonDeszka extends java.awt.Frame implements Runnable {
    /** Melyik oszlopban van éppen az eső golyó? */
    private int oszlop = 0;
    /** Melyik sorban van éppen az eső golyó? */
    private int sor = 0;
    /** Hová hány golyó esett, az i. helyre hisztogram[i] */
    private int [] hisztogram;
    /** Hány pixel magas legyen egy deszkasor. */
    private int sorMagasság;
    /** Hány pixel széles legyen a kísérleti elrendezés ablaka? */
    private int ablakSzélesség;
    /** Hány pixel magas legyen a kísérleti elrendezés ablaka? */
    private int ablakMagasság;
    // Véletlenszám generátor
    private java.util.Random random = new java.util.Random();
    // Pillanatfelvétel készítéséhez
    private java.awt.Robot robot;
    /** Készítsünk pillanatfelvételt? */
    private boolean pillanatfelvétel = false;
    /** A pillanatfelvételek számozásához. */
    private static int pillanatfelvételSzámláló = 0;
    /**
     * Létrehoz egy Galton deszka kísérleti elrendezést
     * absztraháló <code>GaltonDeszka</code> objektumot.
     *
     * @param      magasság       a deszkasorok száma.
     * @param      sorMagasság    a deszkasorok magassága pixelben.
     */
    public GaltonDeszka(int magasság, int sorMagasság) {
        // Hová hány golyó esett, az i. helyre hisztogram[i]
        hisztogram = new int [magasság];
        // Nullázzuk a hisztogram elemeit (nem lenne szükséges, de ez a
        // biztonságos taktika)
        for(int i=0; i<hisztogram.length; ++i)
            hisztogram[i] = 0;
        this.sorMagasság = sorMagasság;
        // Az ablak bezárásakor kilépünk a programból.
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
        // Az s gomb benyomásával ki/bekapcsoljuk a 
        // pillanatfelvétel készítést a kísérletről:
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel = !pillanatfelvétel;
            }
        });
        // Pillanatfelvétel készítéséhez:
        try {
            robot = new java.awt.Robot(
                    java.awt.GraphicsEnvironment.
                    getLocalGraphicsEnvironment().
                    getDefaultScreenDevice());
        } catch(java.awt.AWTException e) {
            e.printStackTrace();
        }
        // Ablak tulajdonságai
        setTitle("Galton deszka kísérlet");
        setResizable(false);
        ablakSzélesség = magasság*sorMagasság*2;
        ablakMagasság = magasság*sorMagasság+400;                
        setSize(ablakSzélesség, ablakMagasság);
        setVisible(true);
        // A kísérlet indul:
        new Thread(this).start();
    }
    /**
     * A kísérlet aktuális állapotának kirajzolása.
     */
    public void paint(java.awt.Graphics g) {
        // A deszkasorok és a golyó kirajzolása
        for(int i=0; i<hisztogram.length; ++i) {
            // Deszkák kirajzolása
            g.setColor(java.awt.Color.BLACK);
            for(int j=0; j<i; ++j)
                g.fillRect(getWidth()/2
                        -((i-1)*sorMagasság+sorMagasság/2)
                        +j*2*sorMagasság+sorMagasság/3,
                        50+i*sorMagasság, sorMagasság/3, sorMagasság);
            // Minden lehetséges pozícióra egy fehér
            // golyó kirajzolása (törli a korábbi piros golyókat)
            g.setColor(java.awt.Color.WHITE);
            for(int j=0; j<=i; ++j)
                g.fillArc(getWidth()/2
                        -(i*sorMagasság+sorMagasság/2)+j*2*sorMagasság,
                        50+i*sorMagasság,
                        sorMagasság,
                        sorMagasság, 0, 360);
            // A most éppen aláhulló golyó kirajzolása
            if(i == sor) {
                g.setColor(java.awt.Color.RED);
                g.fillArc(getWidth()/2
                        -(i*sorMagasság+sorMagasság/2)+oszlop*2*sorMagasság,
                        50+i*sorMagasság, sorMagasság, sorMagasság, 0, 360);
            }
        }
        // A hisztogram kirajzolása
        g.setColor(java.awt.Color.GREEN);
        for(int j=0; j<hisztogram.length; ++j)
            g.fillRect(getWidth()/2
                    -((hisztogram.length-1)*sorMagasság
                    +sorMagasság/2)+j*2*sorMagasság,
                    50+hisztogram.length*sorMagasság,
                    sorMagasság, sorMagasság*hisztogram[j]/10);
        // Készítünk pillanatfelvételt?
        if(pillanatfelvétel) {            
            // a biztonság kedvéért egy kép készítése után
            // kikapcsoljuk a pillanatfelvételt, hogy a 
            // programmal ismerkedő Olvasó ne írja tele a 
            // fájlrendszerét a pillanatfelvételekkel        
            pillanatfelvétel = false;
            pillanatfelvétel(robot.createScreenCapture
                    (new java.awt.Rectangle
                    (getLocation().x, getLocation().y, 
                    ablakSzélesség, ablakMagasság)));                
        }
    }
    // Ne villogjon a felület (mert a "gyári" update()
    // lemeszelné a vászon felületét).
    public void update(java.awt.Graphics g) {
        paint(g);
    }
    /**
     * Pillanatfelvételek készítése.
     */
    public void pillanatfelvétel(java.awt.image.BufferedImage felvetel) {
        
        // A pillanatfelvétel kép fájlneve
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("GaltonDeszkaKiserlet");
        sb.append(++pillanatfelvételSzámláló);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(felvetel, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    /**
     * A kísérlet időbeli fejlődésének vezérlése.
     */
    public void run() {
        // Végtelen ciklus, azaz végtelen sok golyót
        // dobunk le a deszkák között.
        while(true) {
            // Kezdetben a golyó a legfelső deszka felett.
            oszlop = 0;
            // A ciklus minden iterációja egy deszkasornyi
            // esést jelent a golyó életében
            for(int i=0; i<hisztogram.length; ++i) {
                // Melyik sorban van éppen az eső golyó?
                sor = i;
                // Ha növelni akarjuk a sebességet (a
                // látvány rovására) akkor kommentezzük be
                // ezt a várakozó try blokkot (de ekkor
                // ne felejtsük el a hisztogram oszlopainak
                // magasságát sorMagasság*hisztogram[j]/10-ről
                // például sorMagasság*hisztogram[j]/10000-re állítani).
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {}
                
                // Az tetején a golyó az első deszka felett
                if(i>0)
                    // ha nem a tetején, akkor 50%-50%, hogy
                    // jobbra vagy balra esik tovább.
                    // Melyik oszlopban van éppen az eső golyó?
                    oszlop = oszlop + random.nextInt(2);
                // Rajzoljuk ki a kísérlet aktuális állapotát!
                repaint();
            }
            // Ha kilép a golyó a ciklusból, akkor
            // végig esett a deszkasorokon és valamelyik
            // tárolóba esett
            ++hisztogram[oszlop];
        }
    }
    /**
     * Példányosít egy Galton deszkás kísérleti
     * elrendezés obektumot.
     */
    public static void main(String[] args) {
        // Legyen 30 sor, soronként 10 pixellel
        new GaltonDeszka(30, 10);
    }
}                
                ]]>
            </programlisting>            

            <para>
                Könnyen végezhetünk saját kísérleteket az osztály imént megadott
                kódjával. Jelöljük ki a forrásszöveget és illesszük be egy
                <filename>GaltonDeszka.java</filename> nevű állományba, majd fordítsuk az 
                állományt és futtassuk a kísérletet:
                
                <screen>
                            <![CDATA[
C:\...> javac GaltonDeszka.java
C:\...> java GaltonDeszka
                            ]]>
                </screen>                 
                
                 A program futása alatt az <keycap>s</keycap> billentyűt
                 lenyomva a kísérletről egy pillanatfelvétel képet készít a 
                 program. A készített képeket abban a könyvtárban találjuk, ahonnan a 
                 programot a fent ajánlott módon elindítottuk. Ilyen kép
                 például az alábbi <filename>GaltonDeszkaKiserlet1.png</filename>
                 kép.                            
            </para>

            <para>            
                   <inlinemediaobject>
                        <objectinfo>
                            <title>A Galton deszkás kísérlet programjának ablaka.</title>
                        </objectinfo>
                        <imageobject>
                            <imagedata fileref="images/mat/galton.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Galton deszkás kísérlet programjának ablaka.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>

            <para>
            Végezzünk néhány további kísérletet a programmal! Például legyen
            soronként 5 pixel magas, 100 deszkasor, ennek megfelelően módosítsuk a 
            kísérleti elrendezést (paraméterezzük a konstruktort), 
            majd fordítsuk újra a programot és futtassuk!
            <programlisting>
                <![CDATA[
        new GaltonDeszka(100, 5);
                ]]>
            </programlisting>            
            </para>
            
            <example>
                <title>A Galton deszka kísérlet programjának kiegészítései</title>

                <para>
                Végezze el az Olvasó az alábbi továbbfejlesztéseket a programon!
                </para>
                
                <itemizedlist>
                    <listitem>
                      <para>A kísérleti elrendezés ablakában jelenjen meg, hogy
                      eddig hány golyó esett le a kísérlet során!
                      </para>
                      <para>
                          Ha csak ezzel az egy sorral bővítjük a 
                          <function>paint()</function> függvényt
                    <programlisting>
                        <![CDATA[
g.drawString("golyók száma" + golyóSzámláló, 20, 100);                        
                        ]]>
                    </programlisting>                          
                    akkor az egymást követő kiírások, mivel nem törlődik a képernyő
                    ezen része, a változó számok miatt olvashatatlanok lesznek.
                    Számos megoldás kínálkozik ennek elkerülésére, de 
                    nézzünk egy olyat, ami nem
                    használ fel olyan osztályokat az API-ból, amit még eddig
                    nem használtunk. Az új kiírás előtt a háttérszínnel újra
                    kiírjuk a régi golyószámot.                    
                    <programlisting>
                        <![CDATA[
    StringBuffer golyókSb = new StringBuffer();
    
    public void paint(java.awt.Graphics g) {
        // Lemeszeljük az előző kiírást:
        g.setColor(java.awt.Color.WHITE);        
        g.drawString(golyókSb.toString(), 20, 100);
        // Összerakjuk az új kiírást:
        golyókSb.delete(0, golyókSb.length());
        golyókSb.append("golyók száma: ");
        golyókSb.append(golyóSzámláló);
        // és zölddel kiírjuk:
        g.setColor(java.awt.Color.GREEN);        
        g.drawString(golyókSb.toString(), 20, 100);  
        // A deszkasorok és a golyó kirajzolása
        ...
                        ]]>
                    </programlisting>            
                  </para>
                      </listitem>
                    <listitem>
                      <para>A kísérleti elrendezés ablakában jelenjen meg, hogy
                      be van-e kapcsolva a pillanatfelvétel készítés.
                      </para>
                  </listitem>
                    <listitem>
                      <para>Az <keycap>s</keycap> billentyűt
                         lenyomva a leeső golyó minden deszkasorbeli jobb vagy bal oldalra
                         esési választásáról készítsen a program egy pillanatfelvétel képet,
                         majd maga kapcsolja ki e fotósorozat elkészítése
                         után a pillanatfelvétel készítést!                 
                      </para>
                  </listitem>
              </itemizedlist>
                
            </example>
            
        </sect2>
        
        <sect2 id="mandelbrot_halmaz">
            <title>Mandelbrot halmaz programja</title>

            <para>
                Az előző pont programját alakítjuk most át, a Mandelbrot
                halmazt fogjuk kiszámolni és kirajzolni.
                A Mandelbrot halmaz, vagy a halmaz nagyításainak 
                látható szépsége még azokat is
                megérinti, akik egyébként a matematikai jellegű élmények 
                befogadására nincsenek ráhangolva.                
            </para>

            <para>
            A Mandelbrot halmazt a <citation>BARNSLEY KÖNYV</citation> vagy
            ismeretterjesztő szinten a <citation>CSÁSZÁR KÖNYV</citation> könyvekből
            ismerhetjük meg, de az algoritmust itt is ismertetjük, mert 
            gyakorlásképpen be
            akarjuk programozni Javaban! 
            Az algoritmussal és az őt implementáló Java programmal párhuzamosan
            ismerkedünk meg, de az alábbi tárgyalás után összefoglalásul a 
            teljes program kódját is bevágjuk.
            Az algoritmus komplex számsíkon 
            működik. A komplex számsíkot benépesítő komplex számoknak
            könnyű geometriai interpretációt tulajdonítani, amiután már 
            barátságos velük dolgozni. Egy komplex számnak két része van, az
            egyik valós, a másik imaginárius, azaz képzetesnek nevezett.
            </para>

            <para>            
               <inlinemediaobject>
                    <objectinfo>
                        <title>A komplex számok geometriai értelmezése.</title>
                    </objectinfo>
                    <imageobject>
                        <imagedata fileref="images/mat/komplex.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A komplex számok geometriai értelmezése.</phrase>
                    </textobject>
                </inlinemediaobject>            
            </para>

            <para>            
            A Mandelbrot halmazt a komplex sík 
            <varname>a</varname>, 
            <varname>b</varname>, 
            <varname>c</varname>, 
            <varname>d</varname>
            határolta tartományára húzott            
            <programlisting>
                <![CDATA[
    /** A komplex sík vizsgált tartománya [a,b]x[c,d]. */
    protected double a, b, c, d;
    /** A komplex sík vizsgált tartományára feszített
     * háló szélessége és magassága. */
    protected int szélesség, magasság;                 
                ]]>
            </programlisting>            
            <varname>szélesség</varname> széles és <varname>magasság</varname>
            magas rács pontjaiban számoljuk. 
            </para>
            
            <para>            
               <inlinemediaobject>
                    <objectinfo>
                        <title>A Mandelbrot halmazt a komplex síkra húzott
                        rácson pontjaiban számoljuk.</title>
                    </objectinfo>
                    <imageobject>
                        <imagedata fileref="images/mat/komplexracs.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A Mandelbrot halmazt a komplex síkra húzott
                        rácson pontjaiban számoljuk.</phrase>
                    </textobject>
                </inlinemediaobject>            
            </para>
            
            <para>
            Ennek a rácsnak minden pontjában 
            <programlisting>
                <![CDATA[
        // Végigzongorázzuk a szélesség x magasság hálót:
        for(int j=0; j<magasság; ++j) {
            sor = j;
            for(int k=0; k<szélesség; ++k) {
                ]]>
            </programlisting>            
            elkezdjük
            számolni a 
            z<subscript>n+1</subscript> =
            z<subscript>n</subscript><superscript>2</superscript> + c
            iterációt a z<subscript>0</subscript> = 0 és c a megfelelő
            rácspont kezdő értékekkel.
            A c komplex szám reC + imC*i alakja alapján a rácspontnak
            megfelelő komplex szám valós része 
            <computeroutput>reC = a+k*dx</computeroutput>, képzetes része pedig
            <computeroutput>imC = d-j*dy</computeroutput>. Arra kell még figyelnünk,
            hogy a komplex számok szorzása rendhagyó, mert az alábbi szabályt
            mindig szem előtt kell tartanunk i*i = -1, azaz a 
            z<superscript>2</superscript> = z*z = (reZ+imZ*i)*(reZ+imZ*i)=
            reZ*reZ + reZ*imZ*i + imZ*i*reZ + imZ*i*imZ*i = 
            reZ*reZ - imZ*imZ + 2*reZ*imZ*i
            <programlisting>
                <![CDATA[
        // Végigzongorázzuk a szélesség x magasság hálót:
        for(int j=0; j<magasság; ++j) {
            sor = j;
            for(int k=0; k<szélesség; ++k) {
                // c = (reC, imC) a háló rácspontjainak
                // megfelelő komplex szám
                reC = a+k*dx;
                imC = d-j*dy;
                // z_0 = 0 = (reZ, imZ)
                reZ = 0;
                imZ = 0;
                iteráció = 0;
                // z_{n+1} = z_n * z_n + c iterációk
                // számítása, amíg |z_n| < 2 vagy még
                // nem értük el a 255 iterációt, ha
                // viszont elértük, akkor úgy vesszük,
                // hogy a kiinduláci c komplex számra
                // az iteráció konvergens, azaz a c a
                // Mandelbrot halmaz eleme
                while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {
                    // z_{n+1} = z_n * z_n + c
                    ujreZ = reZ*reZ - imZ*imZ + reC;
                    ujimZ = 2*reZ*imZ + imC;
                    reZ = ujreZ;
                    imZ = ujimZ;
                    
                    ++iteráció;
                    
                }
                ]]>
            </programlisting>
            Az iterációk során azt figyeljük, hogy a 
            z<subscript>n</subscript> mennyire távolodik el az induló
            z<subscript>0</subscript> ponttól, azaz a
            koordinátarendszer
            középpontjától, az origótól. Ha ez a távolság nagyobb lesz
            kettőnél, akkor azt mondjuk, hogy a vizsgált c pontban az
            iteráció nem sűrűsödik be az origóhoz közeli valamelyik
            pontba. Ellenkező esetben, tehát ha az iterációs határ
            elérése miatt lépünk ki a 
            <programlisting>
                <![CDATA[
                while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {
                ]]>
            </programlisting>
            ciklusból, akkor azt tételezzük fel, hogy ebben a pontban 
            az iteráció konvergens és a Mandelbrot halmaz elemének
            tekintjük, feketére színezzük:
            <programlisting>
                <![CDATA[
                // sorozat konvergens, azaz iteráció = iterációsHatár
                // ekkor az iteráció %= 256 egyenlő 255, mert az esetleges
                // nagyítasok során az iteráció = valahány * 256 + 255
                iteráció %= 256;
                // így a halmaz elemeire 255-255 értéket használjuk,
                // azaz (Red=0,Green=0,Blue=0) fekete színnel:
                rgb = (255-iteráció)|
                        ((255-iteráció) << 8) |
                        ((255-iteráció) << 16);
                // rajzoljuk a képre az éppen vizsgált pontot:
                kép.setRGB(k, j, rgb);
                ]]>
            </programlisting>
            
            </para>

            <para>
                A Mandelbrot halmazt kiszámoló, kirajzoló programunk teljes kódja
                a következő.
            </para>
            
            <programlisting>
                <![CDATA[
/*
 * MandelbrotHalmaz.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A Mandelbrot halmazt kiszámoló és kirajzoló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class MandelbrotHalmaz extends java.awt.Frame implements Runnable {
    /** A komplex sík vizsgált tartománya [a,b]x[c,d]. */
    protected double a, b, c, d;
    /** A komplex sík vizsgált tartományára feszített
     * háló szélessége és magassága. */
    protected int szélesség, magasság;
    /** A komplex sík vizsgált tartományára feszített hálónak megfelelő kép.*/
    protected java.awt.image.BufferedImage kép;
    /** Max. hány lépésig vizsgáljuk a z_{n+1} = z_n * z_n + c iterációt?
     * (tk. most a nagyítási pontosság) */
    protected int iterációsHatár = 255;
    /** Jelzi, hogy éppen megy-e a szamítás? */
    protected boolean számításFut = false;
    /** Jelzi az ablakban, hogy éppen melyik sort számoljuk. */
    protected int sor = 0;
    /** A pillanatfelvételek számozásához. */
    protected static int pillanatfelvételSzámláló = 0;
    /**
     * Létrehoz egy a Mandelbrot halmazt a komplex sík
     * [a,b]x[c,d] tartománya felett kiszámoló
     * <code>MandelbrotHalmaz</code> objektumot.
     *
     * @param      a              a [a,b]x[c,d] tartomány a koordinátája.
     * @param      b              a [a,b]x[c,d] tartomány b koordinátája.
     * @param      c              a [a,b]x[c,d] tartomány c koordinátája.
     * @param      d              a [a,b]x[c,d] tartomány d koordinátája.
     * @param      szélesség      a halmazt tartalmazó tömb szélessége.
     * @param      iterációsHatár a számítás pontossága.
     */
    public MandelbrotHalmaz(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.szélesség = szélesség;
        this.iterációsHatár = iterációsHatár;
        // a magasság az (b-a) / (d-c) = szélesség / magasság
        // arányból kiszámolva az alábbi lesz:
        this.magasság = (int)(szélesség * ((d-c)/(b-a)));
        // a kép, amire rárajzoljuk majd a halmazt
        kép = new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        // Az ablak bezárásakor kilépünk a programból.
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
        // A billentyűzetről érkező események feldolgozása
        addKeyListener(new java.awt.event.KeyAdapter() {
            // Az 's', 'n' és 'm' gombok lenyomását figyeljük 
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel();
                // Az 'n' gomb benyomásával pontosabb számítást végzünk.
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    if(számításFut == false) {
                        MandelbrotHalmaz.this.iterációsHatár += 256;
                        // A számítás újra indul:
                        számításFut = true;
                        new Thread(MandelbrotHalmaz.this).start();
                    }
                // Az 'm' gomb benyomásával pontosabb számítást végzünk,
                // de közben sokkal magasabbra vesszük az iterációs
                // határt, mint az 'n' használata esetén
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_M) {
                    if(számításFut == false) {
                        MandelbrotHalmaz.this.iterációsHatár += 10*256;
                        // A számítás újra indul:
                        számításFut = true;
                        new Thread(MandelbrotHalmaz.this).start();
                    }
                }
            }
        });
        // Ablak tulajdonságai
        setTitle("A Mandelbrot halmaz");
        setResizable(false);
        setSize(szélesség, magasság);
        setVisible(true);
        // A számítás indul:
        számításFut = true;
        new Thread(this).start();
    }
    /**
     * A halmaz aktuális állapotának kirajzolása.
     */
    public void paint(java.awt.Graphics g) {
        // A Mandelbrot halmaz kirajzolása
        g.drawImage(kép, 0, 0, this);
        // Ha éppen fut a számítás, akkor egy vörös
        // vonallal jelöljük, hogy melyik sorban tart:
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }
    }
    // Ne villogjon a felület (mert a "gyári" update()
    // lemeszelné a vászon felületét).
    public void update(java.awt.Graphics g) {
        paint(g);
    }
    /**
     * Pillanatfelvételek készítése.
     */
    public void pillanatfelvétel() {
        // Az elmentendő kép elkészítése:
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.BLUE);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        g.dispose();
        // A pillanatfelvétel képfájl nevének képzése:
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmaz_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        // A fájl nevébe belevesszük, hogy melyik tartományban
        // találtuk a halmazt:
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    /** 
     * A Mandelbrot halmaz számítási algoritmusa.
     * Az algoritmus részletes ismertetését lásd például a
     * [BARNSLEY KÖNYV] (M. Barnsley: Fractals everywhere, 
     * Academic Press, Boston, 1986) hivatkozásban vagy 
     * ismeretterjesztő szinten a [CSÁSZÁR KÖNYV] hivatkozásban.
     */     
     public void run() {
        // A [a,b]x[c,d] tartományon milyen sűrű a
        // megadott szélesség, magasság háló:
        double dx = (b-a)/szélesség;
        double dy = (d-c)/magasság;
        double reC, imC, reZ, imZ, ujreZ, ujimZ;
        int rgb;
        // Hány iterációt csináltunk?
        int iteráció = 0;
        // Végigzongorázzuk a szélesség x magasság hálót:
        for(int j=0; j<magasság; ++j) {
            sor = j;
            for(int k=0; k<szélesség; ++k) {
                // c = (reC, imC) a háló rácspontjainak
                // megfelelő komplex szám
                reC = a+k*dx;
                imC = d-j*dy;
                // z_0 = 0 = (reZ, imZ)
                reZ = 0;
                imZ = 0;
                iteráció = 0;
                // z_{n+1} = z_n * z_n + c iterációk
                // számítása, amíg |z_n| < 2 vagy még
                // nem értük el a 255 iterációt, ha
                // viszont elértük, akkor úgy vesszük,
                // hogy a kiinduláci c komplex számra
                // az iteráció konvergens, azaz a c a
                // Mandelbrot halmaz eleme
                while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {
                    // z_{n+1} = z_n * z_n + c
                    ujreZ = reZ*reZ - imZ*imZ + reC;
                    ujimZ = 2*reZ*imZ + imC;
                    reZ = ujreZ;
                    imZ = ujimZ;
                    
                    ++iteráció;
                    
                }
                // ha a < 4 feltétel nem teljesült és a
                // iteráció < iterációsHatár sérülésével lépett ki, azaz
                // feltesszük a c-ről, hogy itt a z_{n+1} = z_n * z_n + c
                // sorozat konvergens, azaz iteráció = iterációsHatár
                // ekkor az iteráció %= 256 egyenlő 255, mert az esetleges
                // nagyítasok során az iteráció = valahány * 256 + 255
                iteráció %= 256;
                // így a halmaz elemeire 255-255 értéket használjuk,
                // azaz (Red=0,Green=0,Blue=0) fekete színnel:
                rgb = (255-iteráció)|
                        ((255-iteráció) << 8) |
                        ((255-iteráció) << 16);
                // rajzoljuk a képre az éppen vizsgált pontot:
                kép.setRGB(k, j, rgb);
            }
            repaint();
        }
        számításFut = false;
    }
    /**
     * Példányosít egy Mandelbrot halmazt kiszámoló obektumot.
     */
    public static void main(String[] args) {
        // A halmazt a komplex sík [-2.0, .7]x[-1.35, 1.35] tartományában
        // keressük egy 400x400-as hálóval:
        new MandelbrotHalmaz(-2.0, .7, -1.35, 1.35, 600, 255);
    }
}                
                ]]>
            </programlisting>            

            <para>
                Könnyen végezhetünk saját számításokat az osztály imént megadott
                kódjával. Jelöljük ki a forrásszöveget és illesszük be egy
                <filename>MandelbrotHalmaz.java</filename> nevű állományba, majd fordítsuk a
                állományt és futtassuk a számítást:
                
                <screen>
                            <![CDATA[
C:\...> javac MandelbrotHalmaz.java
C:\...> java MandelbrotHalmaz
                            ]]>
                </screen>                 
                
                 A program futása alatt az <keycap>s</keycap> billentyűt
                 lenyomva a kiszámolt halmazról egy felvételt készít a 
                 program. A készített képeket abban a könyvtárban találjuk, ahonnan a 
                 programot a fent ajánlott módon elindítottuk. Ilyen kép
                 például az alábbi 
                 <filename>MandelbrotHalmaz_1_-2.0_0.7_-1.35_1.35.png</filename>
                 kép.                            
            </para>

            <para>            
                   <inlinemediaobject>
                        <objectinfo>
                            <title>A Mandelbrot halmaz, a 
                            komplex sík vizsgált [-2.0, .7] x [-1.35, 1.35] tartománya.</title>
                        </objectinfo>
                        <imageobject>
                            <imagedata fileref="images/mat/mandelbrot1.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz, a 
                            komplex sík vizsgált [-2.0, .7] x [-1.35, 1.35] tartománya.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>

            <para>
            A program alább bemutatott ablakában a kép adatait nem írattuk ki, 
            illetve a kép tetejéből
            az ablak fejléce néhány pixelsort eltakar.
            </para>            

            <para>            
                   <inlinemediaobject>
                        <objectinfo>
                            <title>A Mandelbrot halmaz rajzoló program ablaka.</title>
                        </objectinfo>
                        <imageobject>
                            <imagedata fileref="images/mat/mandelbrot2.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz rajzoló program ablaka.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
                        
        </sect2>
        
        <sect2>
            <title>Mandelbrot halmaz nagyító programja</title>

            <para>
                Az előző pont programját fejlesztjük most tovább, a program
                által kiszámolt és kirajzolt Mandelbrot
                halmaz valamely részét fogjuk kinagyítani és annak valamely
                részét ... és így tovább. 
                Az áhított nagyító programot úgy valósítjuk meg, 
                hogy a fejlesztendő <classname>MandelbrotHalmazNagyító</classname> 
                osztállyal
                kiterjesztjük a <classname>MandelbrotHalmaz</classname> osztályunkat.
            </para>
        
            <programlisting>
                <![CDATA[
/*
 * MandelbrotHalmazNagyító.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A Mandelbrot halmazt nagyító és kirajzoló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class MandelbrotHalmazNagyító extends MandelbrotHalmaz {
    /** A nagyítandó kijelölt területet bal felső sarka. */
    private int x, y;
    /** A nagyítandó kijelölt terület szélessége és magassága. */
    private int mx, my;
    /**
     * Létrehoz egy a Mandelbrot halmazt a komplex sík
     * [a,b]x[c,d] tartománya felett kiszámoló és nygítani tudó
     * <code>MandelbrotHalmazNagyító</code> objektumot.
     *
     * @param      a              a [a,b]x[c,d] tartomány a koordinátája.
     * @param      b              a [a,b]x[c,d] tartomány b koordinátája.
     * @param      c              a [a,b]x[c,d] tartomány c koordinátája.
     * @param      d              a [a,b]x[c,d] tartomány d koordinátája.
     * @param      szélesség      a halmazt tartalmazó tömb szélessége.
     * @param      iterációsHatár a számítás pontossága.
     */
    public MandelbrotHalmazNagyító(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        // Az ős osztály konstruktorának hívása
        super(a, b, c, d, szélesség, iterációsHatár);
        setTitle("A Mandelbrot halmaz nagyításai");
        // Egér kattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            // Egér kattintással jelöljük ki a nagyítandó területet
            // bal felső sarkát:
            public void mousePressed(java.awt.event.MouseEvent m) {
                // A nagyítandó kijelölt területet bal felső sarka:
                x = m.getX();
                y = m.getY();
                mx = 0;
                my = 0;
                repaint();
            }
            // Vonszolva kijelölünk egy területet...
            // Ha felengedjük, akkor a kijelölt terület
            // újraszámítása indul:
            public void mouseReleased(java.awt.event.MouseEvent m) {
                double dx = (MandelbrotHalmazNagyító.this.b
                        - MandelbrotHalmazNagyító.this.a)
                        /MandelbrotHalmazNagyító.this.szélesség;
                double dy = (MandelbrotHalmazNagyító.this.d
                        - MandelbrotHalmazNagyító.this.c)
                        /MandelbrotHalmazNagyító.this.magasság;
                // Az új Mandelbrot nagyító objektum elkészítése:
                new MandelbrotHalmazNagyító(MandelbrotHalmazNagyító.this.a+x*dx,
                        MandelbrotHalmazNagyító.this.a+x*dx+mx*dx,
                        MandelbrotHalmazNagyító.this.d-y*dy-my*dy,
                        MandelbrotHalmazNagyító.this.d-y*dy,
                        600,
                        MandelbrotHalmazNagyító.this.iterációsHatár);
            }
        });
        // Egér mozgás események feldolgozása:
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            // Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                // A nagyítandó kijelölt terület szélessége és magassága:
                mx = m.getX() - x;
                my = m.getY() - y;
                repaint();
            }
        });
    }
    /**
     * Pillanatfelvételek készítése.
     */
    public void pillanatfelvétel() {
        // Az elmentendő kép elkészítése:
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.BLUE);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
        g.dispose();        
        // A pillanatfelvétel képfájl nevének képzése:
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmazNagyitas_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        // A fájl nevébe belevesszük, hogy melyik tartományban
        // találtuk a halmazt:
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }    
    /**
     * A nagyítandó kijelölt területet jelző négyzet kirajzolása.
     */
    public void paint(java.awt.Graphics g) {
        // A Mandelbrot halmaz kirajzolása
         g.drawImage(kép, 0, 0, this);
        // Ha éppen fut a számítás, akkor egy vörös
        // vonallal jelöljük, hogy melyik sorban tart:         
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        // A jelző négyzet kirajzolása:
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
    }
    /**
     * Példányosít egy Mandelbrot halmazt nagyító obektumot.
     */
    public static void main(String[] args) {
        // A kiinduló halmazt a komplex sík [-2.0, .7]x[-1.35, 1.35]
        // tartományában keressük egy 600x600-as hálóval és az
        // aktuális nagyítási pontossággal:
        new MandelbrotHalmazNagyító(-2.0, .7, -1.35, 1.35, 600, 255);
    }
}                
                ]]>
            </programlisting>            

            <para>
                Ezzel a továbbfejlesztéssel ugyancsak könnyen végezhetünk 
                saját nagyításokat az osztály imént megadott
                kódjával. Jelöljük ki a forrásszöveget és illesszük be egy
                <filename>MandelbrotHalmazNagyító.java</filename> nevű állományba -
                amit ugyanabba a könyvtárba helyezünk, mint az
                előző <filename>MandelbrotHalmaz.java</filename> állományt - 
                majd fordítsuk a
                állományt és futtassuk a számítást:
                
                <screen>
                            <![CDATA[
C:\...> javac MandelbrotHalmazNagyító.java
C:\...> java MandelbrotHalmazNagyító
                            ]]>
                </screen>                 
                
                 Nézzünk meg néhány, a program futása alatt 
                 az <keycap>s</keycap> billentyű
                 lenyomásával készített felvételt a nagyított Mandelbrot 
                 halmazokról:                    
            </para>
            
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel1.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>

            <para> 
            A <mousebutton>bal egérgomb</mousebutton> lenyomásával kijelöljük a nagyítandó területet. A
                <classname>MandelbrotHalmazNagyító</classname> 
                osztályban ezt egy beágyazott, a <classname>MouseAdapter</classname> 
                adapter osztályt kiterjesztő névtelen osztálybeli
                eseménykezelő objektummal oldjuk meg:
                    <programlisting>
                        <![CDATA[
       // Egér kattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            // Egér kattintással jelöljük ki a nagyítandó területet
            // bal felső sarkát:
            public void mousePressed(java.awt.event.MouseEvent m) {
                // A nagyítandó kijelölt területet bal felső sarka:
                x = m.getX();
                y = m.getY();
                mx = 0;
                my = 0;
                repaint();
            }                        ]]>
                    </programlisting>                          
                    A kijelölő, zölddel kirajzolt, nagyítandó területet
                    kijelölő téglalap bal felső sarkának
                    koordinátái az osztály <varname>x</varname> és  
                    <varname>y</varname> tagjai. A kijelölő téglalap 
                    szélessége és magassága az <varname>mx</varname> és  
                    az <varname>my</varname> tagok.
                    <programlisting>
                        <![CDATA[
    /** A nagyítandó kijelölt területet bal felső sarka. */
    private int x, y;
    /** A nagyítandó kijelölt terület szélessége és magassága. */
    private int mx, my;
    ]]>
                    </programlisting>                          
    Ezek állítása történik az eseménykezelő egérkattintást 
    feldolgozó <function>mousePressed()</function> módszerében. A függvény
    aktuális paramétereként megkapott eseményobjektumtól megkérdezzük a
    kattintás helyét:
                    <programlisting>
                        <![CDATA[
                x = m.getX();
                y = m.getY();
                mx = 0;
                my = 0;
                repaint();
            }                        ]]>
                    </programlisting>                          
    az <varname>mx</varname> és <varname>my</varname>  szélességet,
    magasságot nullára állítjuk, ezeket majd az 
    <mousebutton>egérgomb</mousebutton> nyomvatartása melletti
    vonszolás állítja be a vonszolás méretének megfelelő értékre.
    Az egérmutató vonszolásának megfigyelését ugyancsak
    egy beágyazott, de most a <classname>MouseMotionAdapter</classname> 
                adapter osztályt kiterjesztő névtelen osztálybeli
                eseménykezelő objektummal oldjuk meg:    
                    <programlisting>
                        <![CDATA[
        // Egér mozgás események feldolgozása:
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            // Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                // A nagyítandó kijelölt terület szélessége és magassága:
                mx = m.getX() - x;
                my = m.getY() - y;
                repaint();
            }
        });
                        ]]>
                    </programlisting>                          
                    
                    Az <varname>x</varname> és  
                    <varname>y</varname> példányok tárolják a négyzet
                    bal felső sarkának oszlop és sor koordinátáját, ezeket
                    az egérmutató aktuális helyéből kivonva kapjuk a 
                    kijelölt terület szélességét, illetve magasságát,
                    például: <computeroutput>mx = m.getX() - x;</computeroutput>.
                    A <function>repaint()</function> hívása biztosítja, hogy a megváltozott
                    példánytagoknak megfelelő zöld tégla kirajzolásra kerüljön, azaz a
                    <function>paint()</function> függvény meghívódjon, ahol
                    
                    <programlisting>
                        <![CDATA[
        // A jelző négyzet kirajzolása:
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);                        
                        ]]>
                    </programlisting>                          
                    
            </para>
            
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel2.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>

            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel3.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel4.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel5.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel6.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel7.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel8.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel9.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel10.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            
            <para>
                Ha úgy érezzük, hogy a nagyítások során leromlott a pontosság, akkor
                az <userinput>n</userinput> gomb nyomásával növelni tudjuk a 
                számítások iterációs határát. Ezt a billenytűzet eseményt
                egy beágyazott, a <classname>KeyAdapter</classname> 
                adapter osztályt kiterjesztő névtelen osztálybeli
                eseménykezelő objektummal oldjuk meg:
                    <programlisting>
                        <![CDATA[
        // A billentyűzetről érkező események feldolgozása
        addKeyListener(new java.awt.event.KeyAdapter() {
            // Az 's', 'n' és 'm' gombok lenyomását figyeljük 
            public void keyPressed(java.awt.event.KeyEvent e) {            
                ...                    
                // Az 'n' gomb benyomásával pontosabb számítást végzünk.
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    if(számításFut == false) {
                        MandelbrotHalmaz.this.iterációsHatár += 256;
                        // A számítás újra indul:
                        számításFut = true;
                        new Thread(MandelbrotHalmaz.this).start();
                    }
                        ]]>
                    </programlisting>
                    Ha éppen nem fut számítás, akkor növeljük a 
                    számítások <varname>iterációsHatár</varname>
                    iterációs határát, majd készítünk egy számítást
                    végző <computeroutput>new Thread(MandelbrotHalmaz.this).start();</computeroutput>
                    szálat. Ez a pontosabb számítás ekkor jól megfigyelhető, de egy
                    vörös csíkkal is jeleztük
                    <programlisting>
                        <![CDATA[
        // Ha éppen fut a számítás, akkor egy vörös
        // vonallal jelöljük, hogy melyik sorban tart:         
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        ]]>
                    </programlisting>
                    a rajzolást végző <function>paint()</function> függvényekben.
                    
            </para>
            
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel11.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel12.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel13.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel14.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel15.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel16.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel17.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel18.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel19.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel20.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel21.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel22.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel23.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel24.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel25.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel26.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel27.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel28.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel29.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
            </para>
            <para>            
                   <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="images/mat/mandel30.png" />
                        </imageobject>
                        <textobject>
                            <phrase>A Mandelbrot halmaz egy nagyítása.</phrase>
                        </textobject>
                    </inlinemediaobject>            
                    
                    <!--
                    Ezen az utolsó nagyítási képen már látható, hogy 
                    programunk, mint a komplex síkot nagyító 
                    mikroszkóp elértt pontosságának határára. Már olyan
                    kis tartományt nagyítunk, az a és b, c és d
                    értékek már olyan közel kerültek egymáshoz, hogy
                    a tartományra húzott rács csúcspontjai már nem
                    különböző komplex számokat jelentenek, mert a 
                    használt double típus ilyen kis dx és dy 
                    rácspontok közötti lépéseket már nem tesz 
                    lehetővé.                    
                    -->
                    
            </para>

            <example>
                <title>A Mandelbrot halmaz nagyító programjának kiegészítései</title>

                <para>
                Végezze el az Olvasó az alábbi továbbfejlesztéseket a programon!
                Próbálkozzunk például mindenféle más színezési stratégiákkal!
                </para>
                
                <itemizedlist>
                    <listitem>
                      <para>
                          Az alábbi módosítás pontosabb, de kevésbé
                          látványos színezést produkál:
                        <programlisting>
                        <![CDATA[
                iteráció = iteráció / (iterációsHatár / 255);
                rgb = (255-iteráció)|
                        (255-iteráció) << 8 |
                        ((255-iteráció) << 16);
                        ]]>
                        </programlisting>                          
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                          Ezzel a színezéssel már a vörös árnyalataiban pompáznak a 
                          nagyítások:
                        <programlisting>
                        <![CDATA[
                if(iteráció == iterációsHatár)
                    rgb = 0;
                else {
                    iteráció = iteráció % 255;
                    rgb = 0|
                            0 << 8 |
                            ((255-iteráció) << 16);
                }                        
                        ]]>
                        </programlisting>                          
                      </para>
                      <para>            
                           <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/mat/szinezes_piros.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>A Mandelbrot halmaz színezése vörössel.</phrase>
                                </textobject>
                            </inlinemediaobject>            
                        </para>                      
                    </listitem>
                    <listitem>
                      <para>
                          Nemcsak egyfajta szín árnyalatait használva:
                        <programlisting>
                        <![CDATA[
                if(iteráció == iterációsHatár)
                    rgb = 0;
                else {
                    iteráció = iteráció % 255;
                    rgb = (255-iteráció%16)|
                            (255-iteráció%64) << 8 |
                            ((255-iteráció) << 16);
                }
                        ]]>
                        </programlisting>                          
                      </para>
                      <para>            
                           <inlinemediaobject>
                                <imageobject>
                                    <imagedata fileref="images/mat/szinezes_kekes.png" />
                                </imageobject>
                                <textobject>
                                    <phrase>A Mandelbrot halmaz színezése kékes kompozícióval.</phrase>
                                </textobject>
                            </inlinemediaobject>            
                        </para>                      
                    </listitem>                    
              </itemizedlist>
                
            </example>
            
        </sect2>

        <sect2>
            <title>Mandelbrot halmaz pontjait grafikusan iteráló program</title>

            <para>
                Az előző pontban kifejlesztett nagyító program már jól
                használható matematikai kísérleti eszközünk volt, 
                erről tanúskodtott az imént 
                bemutatott nagyítási fotósorozat is. 
                Ebben a részben a nagyítóhoz egy olyan számoló szál
                objektumot készítünk, ami képes a felhasználó 
                kérésére a halmaz egy tetszőleges 
                pontjából megvizsgálni a 
                z<subscript>n+1</subscript> =
                z<subscript>n</subscript><superscript>2</superscript> + c
                iteráció lépéseit: kirajzoljuk a komplex síkra az
                iteráció bejárta                 
                z<subscript>0</subscript>, 
                z<subscript>1</subscript>, 
                z<subscript>3</subscript> ... komplex számokat és az
                egymást követőeket egy egyenessel kötjük majd össze:
                
                        <programlisting>
                        <![CDATA[
            g.drawLine(
                    (int)((reZ - a)/dx),
                    (int)((d - imZ)/dy),
                    (int)((ujreZ - a)/dx),
                    (int)((d - ujimZ)/dy)
                    );
                        ]]>
                        </programlisting>                                          
            </para>
            
            <para>
                A program felhasználója a bal egér gombbal jelöli ki azt a 
                pontot, amelyből az iterációban szereplő pontokat meg akarja
                tekinteni. A jobb egér gomb nyomása továbbra is a nagyítandó
                terület bal felső sarkának koordinátája.
                        <programlisting>
                        <![CDATA[
        // Egér kattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            // Egér kattintással jelöljük ki a nagyítandó területet
            // bal felső sarkát vagy ugyancsak egér kattintással
            // vizsgáljuk egy adott pont iterációit:
            public void mousePressed(java.awt.event.MouseEvent m) {
                // Az egérmutató pozíciója
                x = m.getX();
                y = m.getY();
                // Az 1. egér gombbal a nagyítandó terület kijelölését
                // végezzük:
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
                    // A nagyítandó kijelölt területet bal felső sarka: (x,y)
                    // és szélessége (majd a vonszolás növeli)
                    mx = 0;
                    my = 0;
                    repaint();
                } else {
                    // Nem az 1. egér gombbal az egérmutató mutatta c
                    // komplex számból indított iterációkat vizsgálhatjuk
                    MandelbrotIterációk iterációk =
                            new MandelbrotIterációk(
                            MandelbrotHalmazNagyító.this, 50);
                    new Thread(iterációk).start();
                }
            }                        
                        ]]>
                        </programlisting>                                          
                        Most fejlesztendő szál osztályunkat a 
                        <classname>MandelbrotIterációk</classname>
                        osztályban implementáljuk:
                        <programlisting>
                        <![CDATA[
public class MandelbrotIterációk implements Runnable{                        
                        ]]>
                        </programlisting>                                          
                        Az osztály hozzáfér Mandelbrot halmazunk adataihoz,
                        párhuzamosan végrehajtandó
                        <function>run()</function> metódusa is majdnem
                        ugyanaz, mint a <classname>MandelbrotHalmaz</classname>
                        osztályé, de itt nem az egész rácson kell az
                        iterációt vizsgálnunk, hanem csupán a 
                        <classname>MandelbrotHalmazNagyító</classname> futó
                        objektumon az egérmutató mutatta rácspontban.
                        <programlisting>
                        <![CDATA[
    /** Az vizsgált pontból induló iterációk bemutatása. */
    public void run() {
        /* Az alábbi kód javarészt a MandelbrotHalmaz.java számolást 
         végző run() módszeréből származik, hiszen ugyanazt csináljuk,
         csak most nem a hálón megyünk végig, hanem a háló adott a
         példányosításunkkor az egérmutató mutatta csomópontjában (ennek
         felel meg a c kompelx szám) számolunk, tehát a két külső for 
         ciklus nem kell. */
        // A [a,b]x[c,d] tartományon milyen sűrű a
        // megadott szélesség, magasság háló:
        double dx = (b-a)/szélesség;
        double dy = (d-c)/magasság;
        double reC, imC, reZ, imZ, ujreZ, ujimZ;
        // Hány iterációt csináltunk?
        int iteráció = 0;
        // c = (reC, imC) a háló rácspontjainak
        // megfelelő komplex szám
        reC = a+k*dx;
        imC = d-j*dy;
        // z_0 = 0 = (reZ, imZ)
        reZ = 0;
        imZ = 0;
        iteráció = 0;
        // z_{n+1} = z_n * z_n + c iterációk
        // számítása, amíg |z_n| < 2 vagy még
        // nem értük el a 255 iterációt, ha
        // viszont elértük, akkor úgy vesszük,
        // hogy a kiinduláci c komplex számra
        // az iteráció konvergens, azaz a c a
        // Mandelbrot halmaz eleme
        while(reZ*reZ + imZ*imZ < 4 && iteráció < 255) {
            // z_{n+1} = z_n * z_n + c
            ujreZ = reZ*reZ - imZ*imZ + reC;
            ujimZ = 2*reZ*imZ + imC;
         
            // az iteráció (reZ, imZ) -> (ujreZ, ujimZ)
            // ezt az egyenest kell kirajzolnunk, de most
            // a komplex számokat vissza kell transzformálnunk
            // a rács oszlop, sor koordinátájává:
            java.awt.Graphics g = kép.getGraphics();
            g.setColor(java.awt.Color.WHITE);
            g.drawLine(
                    (int)((reZ - a)/dx),
                    (int)((d - imZ)/dy),
                    (int)((ujreZ - a)/dx),
                    (int)((d - ujimZ)/dy)
                    );
            g.dispose();
            nagyító.repaint();
            
            reZ = ujreZ;
            imZ = ujimZ;
            
            ++iteráció;
            // Várakozunk, hogy közben csodálhassuk az iteráció
            // látványát:
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
        }
    }                            
                        ]]>
                        </programlisting>                                                                  
            </para>
          <para>                          
              A következő ábrán egy olyan futó 
              <classname>MandelbrotHalmazNagyító</classname> objektumot 
              látunk, ahol néhány pontban megnéztük az iterációkban szereplő
              pontokat.
               <inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="images/mat/mandel_utazas.png" />
                    </imageobject>
                    <textobject>
                        <phrase>Kijelölt pontokban az iterációk megjelenítése.</phrase>
                    </textobject>
                </inlinemediaobject>            
            </para>                      
        </sect2>

        <sect2>
            <title>A Mandelbrot halmazzal kapcsolatos osztályaink összefoglalása</title>

            <para>
            A Mandelbrot halmazos programozási gyakorlatunkhoz három osztályt
            fejlesztettünk ki, a <classname>MandelbrotHalmaz</classname>,            
            a <classname>MandelbrotHalmazNagyító</classname> és a 
            <classname>MandelbrotIterációk</classname> osztályokat.
            Az osztályokkal való kísérletezéshez az alább közölt megfelelő 
            <filename>MandelbrotHalmaz.java</filename>,
            a <filename>MandelbrotHalmazNagyító.java</filename> és a 
            <filename>MandelbrotIterációk.java</filename> forrásállományokat
            helyezzük egy könyvtárba, majd egy olyan parancsablakból, ahol
            a Java megfelelően be van állítva, fordítsuk az osztályokat és
            futtassuk a programot így:
                <screen>
                            <![CDATA[
C:\...> javac MandelbrotHalmazNagyító.java
C:\...> java MandelbrotHalmazNagyító
                            ]]>
                </screen>                 
                
                 Korábbi tárgyalásunknak megfelelően a program ablakok a
                 következő inputokat dolgozzák fel:
                 
                <itemizedlist>
                    <listitem>
                      <para>
                        Az <keycap>s</keycap> billentyű
                        lenyomásával egy felvétel kép készül az aktív ablakban számolt fraktálról.                           
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        Az <keycap>n</keycap> billentyű
                        lenyomásával növeljük a halmaz kiszámolásának pontosságát,
                        256-al megnöveljük az iterációk számát.
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        Az <keycap>m</keycap> billentyű
                        lenyomásával nagyobb ugrással növeljük a halmaz kiszámolásának pontosságát,
                        10*256-al megnöveljük az iterációk számát.
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        Az egérmutató bal gombjával kijelöljük a nagyítandó terület bal
                        felső sarkát, az egér vonszolásával megadjuk a terület
                        nagyságát, az <mousebutton>egérgomb</mousebutton> felengedésére új ablakban megkezdődik
                        a kijelölt terület nagyítása.
                      </para>
                 </listitem>
                    <listitem>
                      <para>
                        Az egérmutató jobb gombjával kijelölt pontból végzett
                        iterációkat grafikusan kirajzolja a program.
                      </para>                      
                 </listitem>
                 </itemizedlist>
                 
                 A következő ábrán mutatjuk be kifejlesztett programunk tipikus használati 
                 esetét: számos ablakban nagyítgatunk, visszatérünk egy korábbihoz,
                 pontosítjuk a számítást stb.
            </para>                          
                
            <para>            
               <inlinemediaobject>
                    <objectinfo>
                        <title>A Mandelbrot halmazos osztályaink tipikus használati esete.</title>
                    </objectinfo>
                    <imageobject>
                        <imagedata fileref="images/mat/mandel_programok.png" />
                    </imageobject>
                    <textobject>
                        <phrase>A Mandelbrot halmazos osztályaink tipikus használati esete.</phrase>
                    </textobject>
                </inlinemediaobject>            
            </para>

            <sect3>
                <title>A MandelbrotHalmaz osztály</title>

                    <para>
                        A korábbi pontok fejlesztései eredményeképpen
                        a <classname>MandelbrotHalmaz</classname>
                        osztály alábbi, a 0.0.2 verziója az aktuális.
                        Az alábbi forrásszöveget kijelölve a 
                        <filename>MandelbrotHalmaz.java</filename>
                        forrásállományba kell beillesztenie az Olvasónak 
                        a felhasználáshoz.
                    </para>
                
                    <programlisting>
                    <![CDATA[
/*
 * MandelbrotHalmaz.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A Mandelbrot halmazt kiszámoló és kirajzoló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.2
 */
public class MandelbrotHalmaz extends java.awt.Frame implements Runnable {
    /** A komplex sík vizsgált tartománya [a,b]x[c,d]. */
    protected double a, b, c, d;
    /** A komplex sík vizsgált tartományára feszített
     * háló szélessége és magassága. */
    protected int szélesség, magasság;
    /** A komplex sík vizsgált tartományára feszített hálónak megfelelő kép.*/
    protected java.awt.image.BufferedImage kép;
    /** Max. hány lépésig vizsgáljuk a z_{n+1} = z_n * z_n + c iterációt?
     * (tk. most a nagyítási pontosság) */
    protected int iterációsHatár = 255;
    /** Jelzi, hogy éppen megy-e a szamítás? */
    protected boolean számításFut = false;
    /** Jelzi az ablakban, hogy éppen melyik sort számoljuk. */
    protected int sor = 0;
    /** A pillanatfelvételek számozásához. */
    protected static int pillanatfelvételSzámláló = 0;
    /**
     * Létrehoz egy a Mandelbrot halmazt a komplex sík
     * [a,b]x[c,d] tartománya felett kiszámoló
     * <code>MandelbrotHalmaz</code> objektumot.
     *
     * @param      a              a [a,b]x[c,d] tartomány a koordinátája.
     * @param      b              a [a,b]x[c,d] tartomány b koordinátája.
     * @param      c              a [a,b]x[c,d] tartomány c koordinátája.
     * @param      d              a [a,b]x[c,d] tartomány d koordinátája.
     * @param      szélesség      a halmazt tartalmazó tömb szélessége.
     * @param      iterációsHatár a számítás pontossága.
     */
    public MandelbrotHalmaz(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.szélesség = szélesség;
        this.iterációsHatár = iterációsHatár;
        // a magasság az (b-a) / (d-c) = szélesség / magasság
        // arányból kiszámolva az alábbi lesz:
        this.magasság = (int)(szélesség * ((d-c)/(b-a)));
        // a kép, amire rárajzoljuk majd a halmazt
        kép = new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        // Az ablak bezárásakor kilépünk a programból.
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
        // A billentyűzetről érkező események feldolgozása
        addKeyListener(new java.awt.event.KeyAdapter() {
            // Az 's', 'n' és 'm' gombok lenyomását figyeljük
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel();
                // Az 'n' gomb benyomásával pontosabb számítást végzünk.
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    if(számításFut == false) {
                        MandelbrotHalmaz.this.iterációsHatár += 256;
                        // A számítás újra indul:
                        számításFut = true;
                        new Thread(MandelbrotHalmaz.this).start();
                    }
                    // Az 'm' gomb benyomásával pontosabb számítást végzünk,
                    // de közben sokkal magasabbra vesszük az iterációs
                    // határt, mint az 'n' használata esetén
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_M) {
                    if(számításFut == false) {
                        MandelbrotHalmaz.this.iterációsHatár += 10*256;
                        // A számítás újra indul:
                        számításFut = true;
                        new Thread(MandelbrotHalmaz.this).start();
                    }
                }
            }
        });
        // Ablak tulajdonságai
        setTitle("A Mandelbrot halmaz");
        setResizable(false);
        setSize(szélesség, magasság);
        setVisible(true);
        // A számítás indul:
        számításFut = true;
        new Thread(this).start();
    }
    /** A halmaz aktuális állapotának kirajzolása. */
    public void paint(java.awt.Graphics g) {
        // A Mandelbrot halmaz kirajzolása
        g.drawImage(kép, 0, 0, this);
        // Ha éppen fut a számítás, akkor egy vörös
        // vonallal jelöljük, hogy melyik sorban tart:
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }
    }
    // Ne villogjon a felület (mert a "gyári" update()
    // lemeszelné a vászon felületét).
    public void update(java.awt.Graphics g) {
        paint(g);
    }
    /** Pillanatfelvételek készítése. */
    public void pillanatfelvétel() {
        // Az elmentendő kép elkészítése:
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.BLUE);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        g.dispose();
        // A pillanatfelvétel képfájl nevének képzése:
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmaz_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        // A fájl nevébe belevesszük, hogy melyik tartományban
        // találtuk a halmazt:
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    /** 
     * A Mandelbrot halmaz számítási algoritmusa.
     * Az algoritmus részletes ismertetését lásd például a
     * [BARNSLEY KÖNYV] (M. Barnsley: Fractals everywhere, 
     * Academic Press, Boston, 1986) hivatkozásban vagy 
     * ismeretterjesztő szinten a [CSÁSZÁR KÖNYV] hivatkozásban.
     */     
    public void run() {
        // A [a,b]x[c,d] tartományon milyen sűrű a
        // megadott szélesség, magasság háló:
        double dx = (b-a)/szélesség;
        double dy = (d-c)/magasság;
        double reC, imC, reZ, imZ, ujreZ, ujimZ;
        int rgb;
        // Hány iterációt csináltunk?
        int iteráció = 0;
        // Végigzongorázzuk a szélesség x magasság hálót:
        for(int j=0; j<magasság; ++j) {
            sor = j;
            for(int k=0; k<szélesség; ++k) {
                // c = (reC, imC) a háló rácspontjainak
                // megfelelő komplex szám
                reC = a+k*dx;
                imC = d-j*dy;
                // z_0 = 0 = (reZ, imZ)
                reZ = 0;
                imZ = 0;
                iteráció = 0;
                // z_{n+1} = z_n * z_n + c iterációk
                // számítása, amíg |z_n| < 2 vagy még
                // nem értük el a 255 iterációt, ha
                // viszont elértük, akkor úgy vesszük,
                // hogy a kiinduláci c komplex számra
                // az iteráció konvergens, azaz a c a
                // Mandelbrot halmaz eleme
                while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {
                    // z_{n+1} = z_n * z_n + c
                    ujreZ = reZ*reZ - imZ*imZ + reC;
                    ujimZ = 2*reZ*imZ + imC;
                    reZ = ujreZ;
                    imZ = ujimZ;
                    
                    ++iteráció;
                    
                }
                // ha a < 4 feltétel nem teljesült és a
                // iteráció < iterációsHatár sérülésével lépett ki, azaz
                // feltesszük a c-ről, hogy itt a z_{n+1} = z_n * z_n + c
                // sorozat konvergens, azaz iteráció = iterációsHatár
                // ekkor az iteráció %= 256 egyenlő 255, mert az esetleges
                // nagyítasok során az iteráció = valahány * 256 + 255
                iteráció %= 256;
                // így a halmaz elemeire 255-255 értéket használjuk,
                // azaz (Red=0,Green=0,Blue=0) fekete színnel:
                rgb = (255-iteráció)|
                        ((255-iteráció) << 8) |
                        ((255-iteráció) << 16);
                // rajzoljuk a képre az éppen vizsgált pontot:
                kép.setRGB(k, j, rgb);
            }
            repaint();
        }
        számításFut = false;
    }
    /** Az aktuális Mandelbrot halmaz [a,b]x[c,d] adatai.
     * @return double a */
    public double getA() {
        return a;
    }
    /** Az aktuális Mandelbrot halmaz [a,b]x[c,d] adatai.
     * @return double b */
    public double getB() {
        return b;
    }
    /** Az aktuális Mandelbrot halmaz [a,b]x[c,d] adatai.
     * @return double c */
    public double getC() {
        return c;
    }
    /** Az aktuális Mandelbrot halmaz [a,b]x[c,d] adatai.
     * @return double d */
    public double getD() {
        return d;
    }
    /** Az aktuális Mandelbrot halmaz feletti rács adatai.
     * @return int szélesség */    
    public int getSz() {
        return szélesség;
    }
    /** Az aktuális Mandelbrot halmaz feletti rács adatai.
     * @return int magasság */    
    public int getM() {
        return magasság;
    }
    /** Az aktuális Mandelbrot halmazt tartalmazó kép.
     * @return BufferedImage kép */    
    public java.awt.image.BufferedImage kép() {
        return kép;
    }
    /** Példányosít egy Mandelbrot halmazt kiszámoló obektumot. */
    public static void main(String[] args) {
        // A halmazt a komplex sík [-2.0, .7]x[-1.35, 1.35] tartományában
        // keressük egy 400x400-as hálóval:
        new MandelbrotHalmaz(-2.0, .7, -1.35, 1.35, 600, 255);
    }
}                    
                    ]]>
                    </programlisting>                                                                  
            
            </sect3>
            
            <sect3>
                <title>A MandelbrotHalmazNagyító osztály</title>

                    <para>
                        A korábbi pontok fejlesztései eredményeképpen
                        a <classname>MandelbrotHalmazNagyító</classname>
                        osztály alábbi, a 0.0.2 verziója az aktuális.
                        Az alábbi forrásszöveget kijelölve a 
                        <filename>MandelbrotHalmazNagyító.java</filename>
                        forrásállományba kell beillesztenie az Olvasónak 
                        a felhasználáshoz.
                    </para>
                
                    <programlisting>
                    <![CDATA[
/*
 * MandelbrotHalmazNagyító.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A Mandelbrot halmazt nagyító és kirajzoló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.2
 */
public class MandelbrotHalmazNagyító extends MandelbrotHalmaz {
    /** A nagyítandó kijelölt területet bal felső sarka. */
    private int x, y;
    /** A nagyítandó kijelölt terület szélessége és magassága. */
    private int mx, my;
    /**
     * Létrehoz egy a Mandelbrot halmazt a komplex sík
     * [a,b]x[c,d] tartománya felett kiszámoló és nygítani tudó
     * <code>MandelbrotHalmazNagyító</code> objektumot.
     *
     * @param      a              a [a,b]x[c,d] tartomány a koordinátája.
     * @param      b              a [a,b]x[c,d] tartomány b koordinátája.
     * @param      c              a [a,b]x[c,d] tartomány c koordinátája.
     * @param      d              a [a,b]x[c,d] tartomány d koordinátája.
     * @param      szélesség      a halmazt tartalmazó tömb szélessége.
     * @param      iterációsHatár a számítás pontossága.
     */
    public MandelbrotHalmazNagyító(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        // Az ős osztály konstruktorának hívása
        super(a, b, c, d, szélesség, iterációsHatár);
        setTitle("A Mandelbrot halmaz nagyításai");
        // Egér kattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            // Egér kattintással jelöljük ki a nagyítandó területet
            // bal felső sarkát vagy ugyancsak egér kattintással
            // vizsgáljuk egy adott pont iterációit:
            public void mousePressed(java.awt.event.MouseEvent m) {
                // Az egérmutató pozíciója
                x = m.getX();
                y = m.getY();
                // Az 1. egér gombbal a nagyítandó terület kijelölését
                // végezzük:
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
                    // A nagyítandó kijelölt területet bal felső sarka: (x,y)
                    // és szélessége (majd a vonszolás növeli)
                    mx = 0;
                    my = 0;
                    repaint();
                } else {
                    // Nem az 1. egér gombbal az egérmutató mutatta c
                    // komplex számból indított iterációkat vizsgálhatjuk
                    MandelbrotIterációk iterációk =
                            new MandelbrotIterációk(
                            MandelbrotHalmazNagyító.this, 50);
                    new Thread(iterációk).start();
                }
            }
            // Vonszolva kijelölünk egy területet...
            // Ha felengedjük, akkor a kijelölt terület
            // újraszámítása indul:
            public void mouseReleased(java.awt.event.MouseEvent m) {
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
                    double dx = (MandelbrotHalmazNagyító.this.b
                            - MandelbrotHalmazNagyító.this.a)
                            /MandelbrotHalmazNagyító.this.szélesség;
                    double dy = (MandelbrotHalmazNagyító.this.d
                            - MandelbrotHalmazNagyító.this.c)
                            /MandelbrotHalmazNagyító.this.magasság;
                    // Az új Mandelbrot nagyító objektum elkészítése:
                    new MandelbrotHalmazNagyító(
                            MandelbrotHalmazNagyító.this.a+x*dx,
                            MandelbrotHalmazNagyító.this.a+x*dx+mx*dx,
                            MandelbrotHalmazNagyító.this.d-y*dy-my*dy,
                            MandelbrotHalmazNagyító.this.d-y*dy,
                            600,
                            MandelbrotHalmazNagyító.this.iterációsHatár);
                }
            }
        });
        // Egér mozgás események feldolgozása:
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            // Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                // A nagyítandó kijelölt terület szélessége és magassága:
                mx = m.getX() - x;
                my = m.getY() - y;
                repaint();
            }
        });
    }
    /**
     * Pillanatfelvételek készítése.
     */
    public void pillanatfelvétel() {
        // Az elmentendő kép elkészítése:
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.BLACK);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
        g.dispose();
        // A pillanatfelvétel képfájl nevének képzése:
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmazNagyitas_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        // A fájl nevébe belevesszük, hogy melyik tartományban
        // találtuk a halmazt:
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    /**
     * A nagyítandó kijelölt területet jelző négyzet kirajzolása.
     */
    public void paint(java.awt.Graphics g) {
        // A Mandelbrot halmaz kirajzolása
        g.drawImage(kép, 0, 0, this);
        // Ha éppen fut a számítás, akkor egy vörös
        // vonallal jelöljük, hogy melyik sorban tart:
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }
        // A jelző négyzet kirajzolása:
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
    }
    /**
     * Hol áll az egérmutató?
     * @return int a kijelölt pont oszlop pozíciója.
     */    
    public int getX() {
        return x;
    }
    /**
     * Hol áll az egérmutató?
     * @return int a kijelölt pont sor pozíciója.
     */    
    public int getY() {
        return y;
    }
    /**
     * Példányosít egy Mandelbrot halmazt nagyító obektumot.
     */
    public static void main(String[] args) {
        // A kiinduló halmazt a komplex sík [-2.0, .7]x[-1.35, 1.35]
        // tartományában keressük egy 600x600-as hálóval és az
        // aktuális nagyítási pontossággal:
        new MandelbrotHalmazNagyító(-2.0, .7, -1.35, 1.35, 600, 255);
    }
}                    
                    ]]>
                    </programlisting>                                                                              
            </sect3>

            <sect3>
                <title>A MandelbrotIterációk osztály</title>

                    <para>
                        A <classname>MandelbrotIterációk</classname>
                        osztály alábbi, a 0.0.1 verziója az aktuális.
                        Az alábbi forrásszöveget kijelölve a 
                        <filename>MandelbrotIterációk.java</filename>
                        forrásállományba kell beillesztenie az Olvasónak 
                        a felhasználáshoz.                        
                    </para>
                
                    <programlisting>
                    <![CDATA[
/*
 * MandelbrotIterációk.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A nagyított Mandelbrot halmazok adott pontjában képes
 * nyomonkövetni az z_{n+1} = z_n * z_n + c iterációt.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class MandelbrotIterációk implements Runnable{
    /** Mennyi időt várakozzunk két iteráció bemutatása között? */
    private int várakozás;
    // Kissé igaz redundánsan, s nem szépen, de kényelmesen:
    private MandelbrotHalmazNagyító nagyító;
    private int j, k;
    private double a, b, c, d;
    private  int szélesség, magasság;
    private java.awt.image.BufferedImage kép;
    /**
     * Létrehoz egy iterációkat vizsgáló <code>MandelbrotIterációk</code>
     * szál objektumot egy adott <code>MandelbrotHalmaznagyító</code>
     * objektumhoz.
     *
     * @param      nagyító      egy <code>MandelbrotHalmazNagyító</code> objektum
     * @param      várakozás    várakozási idő
     */
    public MandelbrotIterációk(MandelbrotHalmazNagyító nagyító, int várakozás) {        
        this.nagyító = nagyító;
        this.várakozás = várakozás;
        j = nagyító.getY();
        k = nagyító.getX();
        a = nagyító.getA();
        b = nagyító.getB();
        c = nagyító.getC();
        d = nagyító.getD();
        kép = nagyító.kép();
        szélesség  = nagyító.getSz();
        magasság = nagyító.getM();
    }
    /** Az vizsgált pontból induló iterációk bemutatása. */
    public void run() {
        /* Az alábbi kód javarészt a MandelbrotHalmaz.java számolást 
         végző run() módszeréből származik, hiszen ugyanazt csináljuk,
         csak most nem a hálón megyünk végig, hanem a háló adott a
         példányosításunkkor az egérmutató mutatta csomópontjában (ennek
         felel meg a c kompelx szám) számolunk, tehát a két külső for 
         ciklus nem kell. */
        // A [a,b]x[c,d] tartományon milyen sűrű a
        // megadott szélesség, magasság háló:
        double dx = (b-a)/szélesség;
        double dy = (d-c)/magasság;
        double reC, imC, reZ, imZ, ujreZ, ujimZ;
        // Hány iterációt csináltunk?
        int iteráció = 0;
        // c = (reC, imC) a háló rácspontjainak
        // megfelelő komplex szám
        reC = a+k*dx;
        imC = d-j*dy;
        // z_0 = 0 = (reZ, imZ)
        reZ = 0;
        imZ = 0;
        iteráció = 0;
        // z_{n+1} = z_n * z_n + c iterációk
        // számítása, amíg |z_n| < 2 vagy még
        // nem értük el a 255 iterációt, ha
        // viszont elértük, akkor úgy vesszük,
        // hogy a kiinduláci c komplex számra
        // az iteráció konvergens, azaz a c a
        // Mandelbrot halmaz eleme
        while(reZ*reZ + imZ*imZ < 4 && iteráció < 255) {
            // z_{n+1} = z_n * z_n + c
            ujreZ = reZ*reZ - imZ*imZ + reC;
            ujimZ = 2*reZ*imZ + imC;
         
            // az iteráció (reZ, imZ) -> (ujreZ, ujimZ)
            // ezt az egyenest kell kirajzolnunk, de most
            // a komplex számokat vissza kell transzformálnunk
            // a rács oszlop, sor koordinátájává:
            java.awt.Graphics g = kép.getGraphics();
            g.setColor(java.awt.Color.WHITE);
            g.drawLine(
                    (int)((reZ - a)/dx),
                    (int)((d - imZ)/dy),
                    (int)((ujreZ - a)/dx),
                    (int)((d - ujimZ)/dy)
                    );
            g.dispose();
            nagyító.repaint();
            
            reZ = ujreZ;
            imZ = ujimZ;
            
            ++iteráció;
            // Várakozunk, hogy közben csodálhassuk az iteráció
            // látványát:
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
        }
    }    
}                    
                    ]]>
                    </programlisting>                 
                    
				<tip>
				<title>Jar készítése</title>
<para>
                Kérdés: Hogyan készíthetek olyan Java programot, mely Windows XP alatt az asztalra helyezett ikonjára kattintva indul el?
                </para>
                
                    <para>
                    Válasz: Készítsünk <filename>jar</filename> állományt és küldjünk az asztalra egy erre 
                    a <filename>jar</filename> állományra mutató
                    parancsikont!
                            <screen>
                            <![CDATA[
C:\...\Munkakönyvtár> javac MandelbrotHalmaz.java
C:\...\Munkakönyvtár> jar cmf manifest.mf mandelbrotos.jar *.class
                            ]]>
                            </screen> 
                            A fenti fordítás után a <command>jar</command> parancsot használva
                            készítettük el a
                            <filename>mandelbrotos.jar</filename> 
                            Java archívum állományt. (A <command>jar</command>
                            parancs része a JDK csomagnak.)
                    </para>    				
				
				</tip>
                    
                                                                                 
            </sect3>            
                        
        </sect2>
        
        <sect2 id="pi_jegyei">
            <title>A Pi jegyeinek nyomában</title>
            
            <para>
                Ez a rész azt segíti, hogy a kedves Olvasó 
                a <citation>KAPCSOLAT REGÉNY</citation>
                olvasásának befejezésekor keletkezett
                lelkesítő feszültségét át tudja vezetni
                a Pi jegyeinek
                önálló keresésébe.
            </para>
                
            <para>                
                <emphasis><link linkend="pi_bev">A Pi közelítése</link></emphasis>
                című pontban megkezdett gombolyag fonalát követjük tovább. 
                A <citation>PI KÖNYV</citation> könyv hívja fel a figyelmet,
                hogy Penrose - általunk is sokat hivatkozott - 
                <citation>CSÁSZÁR KÖNYV</citation> könyvében azt valószínűsíti,
                hogy a „van-e tíz egymást követő hetes számjegy a Pi
                tizedes kifejtésében?” kérdésre a választ nem egy
                konkrét számítás és keresés, hanem egy egzisztencia bizonyítás
                adja majd meg. S ezzel szemben 1997-ben Kanada megtalált
                egy 7777777777 részsztringet a kifejtésben, ami egyébként a 22.869.046.249.
                pozíciótól kezdődik!
            </para>                            

            <para id="bbp_algoritmus">
                A következőkben olyan algoritmusokat ismertetünk, amihez a 
                64 bites lebegőpontos aritmetika is elegendő. Ez az 1995-ben
                talált
                Bailey-Borwein-Plouffe 
                <citation>PI SZÁMÍTÁS</citation>,
                <citation>BBP ALGORITMUS</citation>,
                <citation>PI KÜLDETÉS</citation>,
                <citation>PI KÖNYV</citation>                
                féle (röviden BBP) algoritmus, aminek 
                további
                meglepő érdekessége, hogy a Pi hexadecimális kifejtésében
                egy adott pozíciótól tudunk jegyeket meghatározni, a korábbi
                jegyek ismerete nélkül!
            </para>                            
            
            <para>
            <programlisting>
            <![CDATA[
/*
 * PiBBP.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A BBP (Bailey-Borwein-Plouffe) algoritmust a Pi hexa
 * jegyeinek számolását végző osztály. A könnyebb olvahatóság
 * kedvéért a változó és metódus neveket megpróbáltuk az algoritmust
 * bemutató [BBP ALGORITMUS] David H. Bailey: The BBP Algorithm for Pi.
 * cikk jelöléseihez.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class PiBBP {
    /** A Pi hexa kifejtésében a d+1. hexa jegytől néhány hexa jegy.*/
    String d16PiHexaJegyek;
    /**
     * Létrehoz egy <code>PiBBP</code>, a BBP algoritmust a Pi-hez
     * alkalmazó objektumot. A [BBP ALGORITMUS] David H. Bailey: The
     * BBP Algorithm for Pi. alapján a
     * {16^d Pi} = {4*{16^d S1} - 2*{16^d S4} - {16^d S5} - {16^d S6}}
     * kiszámítása, a {} a törtrészt jelöli.
     *
     * @param   d   a Pi hexa kifejtésében a d+1. hexa jegytől
     * számoljuk a hexa jegyeket
     */
    public PiBBP(int d) {
        
        double d16Pi = 0.0d;
        
        double d16S1t = d16Sj(d, 1);
        double d16S4t = d16Sj(d, 4);
        double d16S5t = d16Sj(d, 5);
        double d16S6t = d16Sj(d, 6);
        
        d16Pi = 4.0d*d16S1t - 2.0d*d16S4t - d16S5t - d16S6t;
        
        d16Pi = d16Pi - StrictMath.floor(d16Pi);
        
        StringBuffer sb = new StringBuffer();
        
        Character hexaJegyek[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        
        while(d16Pi != 0.0d) {
            
            int jegy = (int)StrictMath.floor(16.0d*d16Pi);
            
            if(jegy<10)
                sb.append(jegy);
            else
                sb.append(hexaJegyek[jegy-10]);
            
            d16Pi = (16.0d*d16Pi) - StrictMath.floor(16.0d*d16Pi);
        }
        
        d16PiHexaJegyek = sb.toString();
    }
    /**
     * BBP algoritmus a Pi-hez, a [BBP ALGORITMUS] David H. Bailey: The
     * BBP Algorithm for Pi. alapján a {16^d Sj} részlet kiszámítása.
     *
     * @param   d   a d+1. hexa jegytől számoljuk a hexa jegyeket
     * @param   j   Sj indexe
     */
    public double d16Sj(int d, int j) {
        
        double d16Sj = 0.0d;
        
        for(int k=0; k<=d; ++k)
            d16Sj += (double)n16modk(d-k, 8*k + j) / (double)(8*k + j);
        
        /* (bekapcsolva a sorozat elejen az első utáni jegyekben növeli pl.
            a pontosságot.)
        for(int k=d+1; k<=2*d; ++k)
            d16Sj += StrictMath.pow(16.0d, d-k) / (double)(8*k + j);
         */
        
        return d16Sj - StrictMath.floor(d16Sj);
    }
    /**
     * Bináris hatványozás mod k, a 16^n mod k kiszámítása.
     *
     * @param   n   kitevő
     * @param   k   modulus
     */
    public long n16modk(int n, int k) {
        
        int t = 1;
        while(t <= n)
            t *= 2;
        
        long r = 1;
        
        while(true) {
            
            if(n >= t) {
                r = (16*r) % k;
                n = n - t;
            }
            
            t = t/2;
            
            if(t < 1)
                break;
            
            r = (r*r) % k;
            
        }
        
        return r;
    }
    /**
     * A kiszámolt néhány hexa jegy visszaadása. A használt lebegőpontos
     * aritmentia függvényében mondjuk az első 6 pontos peldául
     * d=1000000 esetén.
     *
     * @return String a kiszámolt néhány hexa jegy
     */
    public String toString() {
        
        return d16PiHexaJegyek;
    }
    /** Példányosít egy BBP algoritmust implementáló obektumot.*/
    public static void main(String args[]) {        
        System.out.print(new PiBBP(1000000));
    }
}
            ]]>
            </programlisting>   
      
            Fordítva és futtatva a példát azt kapjuk, hogy a Pi
            hexadecimális kifejtése az 1000001. jegytől a következő:
            
            ...<emphasis>6C65E5</emphasis>308...
            
            <screen>
                            <![CDATA[
[norbi@niobe ~]$ javac PiBBP.java
[norbi@niobe ~]$ java PiBBP
6C65E5308
                            ]]>
            </screen>            
            
            (C-ben a <computeroutput>long double</computeroutput> típus használata
            mellett ugyanezzel a futtatással több jegy pontosság érhető el:
            ...<emphasis>6C65E52CB</emphasis>858...)
            
            </para>                            

            <para>                            
            A <classname>PiBBP</classname> osztály felhasználásával
            elkezdhetjük folyamatosan vizsgálni adott pozíciótól a Pi
            hexadecimális kifejtésének jegyeit, az osztály
            <function>main()</function> indítófüggvényét módosítva:
                        
            <programlisting>
            <![CDATA[
    public static void main(String args[]) {
        
        for(int i=1000000; i<1001000; i+=2) {
            PiBBP piBBP = new PiBBP(i);
            System.out.print(piBBP.toString().charAt(0));
            System.out.print(piBBP.toString().charAt(1));            
        }        
    }
            ]]>
            </programlisting>   
            
            Fordítás és futtatás után
            
            <screen>
                            <![CDATA[
[norbi@niobe ~]$ javac PiBBP.java
[norbi@niobe ~]$ java PiBBP
6C65E52CB459350050E4BB178F4C67A0FCF7BF27206290FBE70F93B828CD939C475C728F2FDB0CB9
23CF52C40D631D4DB2E98340AA25A6F07DB685C0A9C04F3F6E667CFD6E1764C83ECA94E79661FC18
0E6AEF581987E79E13278712CB01255E8CE4D9E048F782D756370548FB0778323CF2074C2716D121
639F1DD5A31EF6C242676B3783AD528852CCA52A9B4F999C526B0750859AEEC9CE6635B30996A210
CD419D5FD47A4E7AAF906E26A4CCF99A2E493BBB5E7D5E0B94F15196DA8CD1A0C57FE03A629B2D58
42317C173D163EA8717B46930EE0FE82FEC4B01016F155FB446AA6958EAD9265EC0C914CB84755DD
1BCE5100C23804D67A787BEC57CD7D8E190B3F55E3D2558927215504F141AC8B0BA836F7781E1966
4EFA8B22BEB3816A70F7210E4784A1F37762361286448CD051BCE3A4CE156D70CDBA256C1A36C386
48633C8F13A53405795635084A2DEAF3B9066BC3863BB07447DDDBDE5644034A6893E3E1CFDB3696
31BAA4240D93F17F667F7C51ABF076F7C1BB35DECC240153F4817A579CBD1DAC895E8555929D1ADA
3C787A0BF2881BBC44C4BE505E91FE5A28B9BA47D4845B7639239AD71D8B63BF9D23B2CC88C9D39C
033B0482F5F801D778BBB734EA8B1BE878D129514BFA5C4A6D60E80CF4B14A2A5673992B18397230
54BD44F767B03245F2873973EF6D84B2B96EFC9A
]]>
            </screen>            
            
            kaptuk például a Pi hexadecimális kifejtésének 1000001. pozíciójától
            a kifejtés 1000 hexadecimális számjegyét.
            
            </para>                            

            <para>                            
            A <classname>PiBBP</classname> osztály felhasználásával
            természetesen elölről is
            elkezdhetjük folyamatosan vizsgálni a Pi
            hexadecimális kifejtésének jegyeit, az osztály
            <function>main()</function> indítófüggvényét ehhez így módosítva:
                        
            <programlisting>
            <![CDATA[
    public static void main(String args[]) {
        
        for(int i=0; i<3000; i+=1) {
            PiBBP piBBP = new PiBBP(i);
            System.out.print(piBBP.toString().charAt(0));
        }
    }
            ]]>
            </programlisting>   
            
            Fordítás és futtatás után
            
            <screen>
                            <![CDATA[
[norbi@niobe ~]$ javac PiBBP.java
[norbi@niobe ~]$ java PiBBP
243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89452821E638D01377
BE5466CF34E90C6CC0AC29B7C97C50DD3F84D5B5B54709179216D5D98979FB1BD1310BA698DFB5AC
2FFD72DBD01ADFB7B8E1AFED6A267E96BA7C9045F12C7F9924A19947B3916CF70801F2E2858EFC16
636920D871574E69A458FEA3F4933D7E0D95748F728EB658718BCD5882154AEE7B54A41DC25A59B5
9C30D5392AF26013C5D1B023286085F0CA417918B8DB38EF8E79DCB0603A180E6C9E0E8BB01E8A3E
D71577C1BD314B2778AF2FDA55605C60E65525F3AA55AB945748986263E8144055CA396A2AAB10B6
B4CC5C341141E8CEA15486AF7C72E993B3EE1411636FBC2A2BA9C55D741831F6CE5C3E169B87931E
AFD6BA336C24CF5C7A325381289586773B8F48986B4BB9AFC4BFE81B6628219361D809CCFB21A991
487CAC605DEC8032EF845D5DE98575B1DC262302EB651B8823893E81D396ACC50F6D6FF383F44239
2E0B4482A484200469C8F04A9E1F9B5E21C66842F6E96C9A670C9C61ABD388F06A51A0D2D8542F68
960FA728AB5133A36EEF0B6C137A3BE4BA3BF0507EFB2A98A1F1651D39AF017666CA593E82430E88
8CEE8619456F9FB47D84A5C33B8B5EBEE06F75D885C12073401A449F56C16AA64ED3AA62363F7706
1BFEDF72429B023D37D0D724D00A1248DB0FEAD349F1C09B075372C980991B7B25D479D8F6E8DEF7
E3FE501AB6794C3B976CE0BD04C006BAC1A94FB6409F60C45E5C9EC2196A246368FB6FAF3E6C53B5
1339B2EB3B52EC6F6DFC511F9B30952CCC814544AF5EBD09BEE3D004DE334AFD660F2807192E4BB3
C0CBA85745C8740FD20B5F39B9D3FBDB5579C0BD1A60320AD6A100C6402C7279679F25FEFB1FA3CC
8EA5E9F8DB3222F83C7516DFFD616B152F501EC8AD0552AB323DB5FAFD23876053317B483E00DF82
9E5C57BBCA6F8CA01A87562EDF1769DBD542A8F6287EFFC3AC6732C68C4F5573695B27B0BBCA58C8
E1FFA35DB8F011A010FA3D98FD2183B84AFCB56C2DD1D35B9A53E479B6F84565D28E49BC4BFB9790
E1DDF2DAA4CB7E3362FB1341CEE4C6E8EF20CADA36774C01D07E9EFE2BF11FB495DBDA4DAE909198
EAAD8E716B93D5A0D08ED1D0AFC725E08E3C5B2F8E7594B78FF6E2FBF2122B648888B812900DF01C
4FAD5EA0688FC31CD1CFF191B3A8C1AD2F2F2218BE0E1777EA752DFE8B021FA1E5A0CC0FB56F74E8
18ACF3D6CE89E299B4A84FE0FD13E0B77CC43B81D2ADA8D9165FA2668095770593CC7314211A1477
E6AD206577B5FA86C75442F5FB9D35CFEBCDAF0C7B3E89A0D6411BD3AE1E7E4900250E2D2071B35E
226800BB57B8E0AF2464369BF009B91E5563911D59DFA6AA78C14389D95A537F207D5BA202E5B9C5
832603766295CFA911C819684E734A41B3472DCA7B14A94A1B5100529A532915D60F573FBC9BC6E4
2B60A47681E6740008BA6FB5571BE91FF296EC6B2A0DD915B6636521E7B9F9B6FF34052EC5855664
53B02D5DA99F8FA108BA47996E85076A4B7A70E9B5B32944DB75092EC4192623AD6EA6B049A7DF7D
9CEE60B88FEDB266ECAA8C71699A17FF5664526CC2B19EE1193602A575094C29A0591340E4183A3E
3F54989A5B429D656B8FE4D699F73FD6A1D29C07EFE830F54D2D38E6F0255DC14CDD20868470EB26
6382E9C6021ECC5E09686B3F3EBAEFC93C9718146B6A70A1687F358452A0E286B79C5305AA500737
3E07841C7FDEAE5C8E7D44EC5716F2B8B03ADA37F0500C0DF01C1F040200B3FFAE0CF51A3CB574B2
25837A58DC0921BDD19113F97CA92FF69432477322F547013AE5E58137C2DADCC8B576349AF3DDA7
A94461460FD0030EECC8C73EA4751E41E238CD993BEA0E2F3280BBA1183EB3314E548B384F6DB908
6F420D03F60A04BF2CB8129024977C795679B072BCAF89AFDE9A771FD9930810B38BAE12DCCF3F2E
5512721F2E6B7124501ADDE69F84CD877A5847187408DA17BC9F9ABCE94B7D8CEC7AEC3ADB851DFA
63094366C464C3D2EF1C18473215D908DD433B3724C2BA1612A14D432A65C45150940002133AE4DD
71DFF89E10314E5581AC77D65F11199B043556F1
]]>
            </screen>            
            
            megkapjuk a Pi hexadecimális kifejtésének 3000 jegyét, azaz hexában a
            3.<emphasis>243F6...</emphasis>. 
            
            </para>                                        
            
            <para>                                                    
            Hosszabb számítások végzéséhez a 
            kevésbé objektumorientált jellegű <classname>PiBBPBench</classname>
            osztály használatát javasoljuk, az osztályt az 
            <emphasis><link linkend="sebesseg">Egyszerű összehasonlítások a sebesség kérdésében</link></emphasis>                                                                
            című pontban találja meg az érdeklődő Olvasó.
            </para>                                        
            
        </sect2>
            
    </sect1>
    
    </appendix>
    
	<!-- Technikai mellékletek ki (Q és A, verziótörténeti részletezés) -->
    
</part>    

   <bibliography>
        <title>Irodalomjegyzék</title>

        <bibliodiv>
            <title>Idézetek, bevezető részek</title>
            
            <biblioentry>
              <abbrev>MÁTRIX MOZI</abbrev>
              <authorgroup>
                <author><firstname>Andy</firstname><surname>Wachowski</surname></author>
                <author><firstname>Larry</firstname><surname>Wachowski</surname></author>
              </authorgroup>
              <title>The Matrix</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.imdb.com/title/tt0133093/">http://www.imdb.com/title/tt0133093/</ulink>
                </publishername>
              </publisher>
              <pubdate>1999</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>KVANTUM MOZI</abbrev>
              <authorgroup>
				<author><firstname>William</firstname><surname>Arntz</surname></author>
                <author><firstname>Betsy</firstname><surname>Chasse</surname></author>
              </authorgroup>
              <title>What the #$*! Do We (K)now!? Mi a csudát tudunk a világról?</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.imdb.com/title/tt0399877/">http://www.imdb.com/title/tt0399877/</ulink>
<ulink url="http://www.whatthebleep.com/">http://www.whatthebleep.com/</ulink>                    
                </publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>
            
            <biblioentry>
              <abbrev>DOOM JÁTÉK</abbrev>
              <title>DOOM</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.idsoftware.com/">http://www.idsoftware.com/</ulink>
                </publishername>
              </publisher>              
            </biblioentry>

            <biblioentry>
              <abbrev>MARX KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>György</firstname><surname>Marx</surname></author>
              </authorgroup>
              <title>Gyorsuló idő</title>
              <publisher>
                <publishername>Typotex</publishername>
              </publisher>
              <pubdate>2005</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>DOOM KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>David</firstname><surname>Kushner</surname></author>
              </authorgroup>
              <title>A DOOM LEGENDÁJA</title>
              <publisher>
                <publishername>VogelBurda</publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>
            
            <biblioentry>
              <abbrev>SZÁMÉRZÉK KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Stanislas</firstname><surname>Dehaene</surname></author>
              </authorgroup>
              <title>A számérzék</title>
              <publisher>
                <publishername>Osiris</publishername>
              </publisher>
              <pubdate>2003</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>VASSY JEGYZET</abbrev>
              <authorgroup>
                <author><firstname>Zoltán</firstname><surname>Vassy</surname></author>
              </authorgroup>
              <title>Schrödingerék macskája és más történetek</title>
              <publisher>
                <publishername>
                    <ulink url="http://vmek.oszk.hu/00500/00571/html/">http://vmek.oszk.hu/00500/00571/html/</ulink>                    
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>KERNIGHAN PROG KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Brian W.</firstname><surname>Kernighan</surname></author>
                <author><firstname>P. J.</firstname><surname>Plauger</surname></author>
              </authorgroup>
              <title>A programozás magasiskolája</title>
              <publisher>
                <publishername>Műszaki</publishername>
              </publisher>
              <pubdate>1982</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>KERNIGHAN C KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Brian W.</firstname><surname>Kernighan</surname></author>
                <author><firstname>Dennis M.</firstname><surname>Ritchie</surname></author>
              </authorgroup>
              <title>A C programozási nyelv</title>
              <publisher>
                <publishername>Műszaki</publishername>
              </publisher>
              <pubdate>1993</pubdate>
            </biblioentry>            
                        
            <biblioentry>
              <abbrev>WIGNER KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Jenő</firstname><surname>Wigner</surname></author>
              </authorgroup>
              <title>Szimmetriák és reflexiok</title>
              <publisher>
                <publishername>Gondolat</publishername>
              </publisher>
              <pubdate>1972</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>TELLER LEVÉL</abbrev>
              <authorgroup>
                <author><firstname>Eric M.</firstname><surname>Jones</surname></author>
              </authorgroup>
              <title><quote>Where is everybody</quote>An Account of Fermi's Question</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.fas.org/sgp/othergov/doe/lanl/la-10311-ms.pdf">http://www.fas.org/sgp/othergov/doe/lanl/la-10311-ms.pdf</ulink>
                </publishername>
              </publisher>
            </biblioentry>

        </bibliodiv>
                
        <bibliodiv>
            <title>Informatikai, fizikai, matematikai jellegű ismeretterjesztés</title>

            <biblioentry>
              <abbrev>CSÁSZÁR KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Roger</firstname><surname>Penrose</surname></author>
              </authorgroup>
              <title>A császár új elméje</title>
              <publisher>
                <publishername>Akadémiai</publishername>
              </publisher>
              <pubdate>1993</pubdate>
            </biblioentry>
        
            <biblioentry>
              <abbrev>PENROSE-HAWKING KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Roger</firstname><surname>Penrose</surname></author>
                <author><firstname>Stephen</firstname><surname>Hawking</surname></author>
              </authorgroup>
              <title>A nagy, a kicsi és az emberi elme</title>
              <publisher>
                <publishername>Akkord</publishername>
              </publisher>
              <pubdate>2003</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>STEWART KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Ian</firstname><surname>Stewart</surname></author>
              </authorgroup>
              <title>A matematika problémái</title>
              <publisher>
                <publishername>Akadémiai</publishername>
              </publisher>
              <pubdate>1991</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>SZÁMÉRZÉK KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Stanislas</firstname><surname>Dehaene</surname></author>
              </authorgroup>
              <title>A számérzék</title>
              <publisher>
                <publishername>Osiris</publishername>
              </publisher>
              <pubdate>2003</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>PARADOXON KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Gábor</firstname><surname>Székely J.</surname></author>
              </authorgroup>
              <title>Paradoxonok a véletlen matematikájában</title>
              <publisher>
                <publishername>Typotex</publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>PÉNZ KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>László</firstname><surname>Mérő</surname></author>
              </authorgroup>
              <title>Az élő pénz</title>
              <publisher>
                <publishername>Tercium</publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>ISTEN KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Paul</firstname><surname>Davies</surname></author>
              </authorgroup>
              <title>Isten gondolatai</title>
              <publisher>
                <publishername>Kulturtrade</publishername>
              </publisher>
              <pubdate>1995</pubdate>
            </biblioentry>            
            
        </bibliodiv>        
                
        <bibliodiv>
            <title>Automata, algoritmus és információelmélet</title>
            
            <biblioentry>
              <abbrev>ALGORITMUSOK KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Lajos</firstname><surname>Rónyai</surname></author>
              </authorgroup>
              <title>ALGORITMUSOK</title>
              <publisher>
                <publishername>Typotex</publishername>
              </publisher>
              <pubdate>1998</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>LOVÁSZ KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>László</firstname><surname>Lovász</surname></author>
              </authorgroup>
              <title>Algoritmusok bonyolultsága</title>
              <publisher>
                <publishername>Nemzeti</publishername>
              </publisher>
              <pubdate>1994</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>CHAITIN OMEGA</abbrev>
              <authorgroup>
                <author><firstname>Gregory</firstname><surname>Chaitin</surname></author>
              </authorgroup>
              <title>A theory of program size formally identical to information theory</title>
              <publisher>
                <publishername>Journal of the ACM 
                    <ulink url="http://www.cs.auckland.ac.nz/CDMTCS/chaitin/acm75.pdf">http://www.cs.auckland.ac.nz/CDMTCS/chaitin/acm75.pdf</ulink>
                    <ulink url="http://citeseer.ist.psu.edu/chaitin75theory.html">http://citeseer.ist.psu.edu/chaitin75theory.html</ulink>
                </publishername>
              </publisher>
              <volumenum>22</volumenum>
              <pagenums>329-340</pagenums>              
              <pubdate>1975</pubdate>              
            </biblioentry>

            <biblioentry>
              <abbrev>CHAITIN OMEGA 1</abbrev>
              <authorgroup>
                <author><firstname>Gregory</firstname><surname>Chaitin</surname></author>
              </authorgroup>
              <title>META MATH! The Quest for Omega</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.cs.auckland.ac.nz/CDMTCS/chaitin/omega.html">http://www.cs.auckland.ac.nz/CDMTCS/chaitin/omega.html</ulink>
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>CHAITIN OMEGA 2</abbrev>
              <authorgroup>
                <author><firstname>Gregory</firstname><surname>Chaitin</surname></author>
              </authorgroup>
              <title>THE LIMITS OF REASON</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.cs.auckland.ac.nz/CDMTCS/chaitin/sciamer3.html">http://www.cs.auckland.ac.nz/CDMTCS/chaitin/sciamer3.html</ulink>
                </publishername>
              </publisher>
            </biblioentry>
                        
            <biblioentry>
              <abbrev>CHAITIN OMEGA n</abbrev>
              <authorgroup>
                <author><firstname>Gregory</firstname><surname>Chaitin</surname></author>
              </authorgroup>
              <title>Omega and why maths has no TOEs</title>
              <publisher>
                <publishername>
                    <ulink url="http://plus.maths.org/issue37/features/omega/">http://plus.maths.org/issue37/features/omega/</ulink>
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>CALUDE KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Cristian S.</firstname><surname>Calude</surname></author>
              </authorgroup>
              <title>Information and Randomness An Algorithmic Perspective</title>
              <publisher>
                <publishername>Springer</publishername>
              </publisher>
              <pubdate>2002</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>JAVA PROG és OMEGA</abbrev>
              <authorgroup>
                <author><firstname>Cristian S.</firstname><surname>Calude</surname></author>
                <author><firstname>Michael J.</firstname><surname>Dinneen</surname></author>
                <author><firstname>Chi-Kou</firstname><surname>Shu</surname></author>
              </authorgroup>
              <title>Computing a Glimpse of Randomness</title>
              <publisher>
                <publishername>Experimental Mathematics
                    <ulink url="http://www.cs.auckland.ac.nz/~cristian/Calude361_370.pdf">http://www.cs.auckland.ac.nz/~cristian/Calude361_370.pdf</ulink>
                    <ulink url="http://arxiv.org/abs/nlin.cd/0112022">http://arxiv.org/abs/nlin.cd/0112022</ulink>                    
                </publishername>
              </publisher>
              <pubdate>2002</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>JAVA PROG és OMEGA 2</abbrev>
              <authorgroup>
                <author><firstname>Chi-Kou</firstname><surname>Shu</surname></author>
              </authorgroup>
              <title>Computing Exact Approximations of a Chaitin Omega Number</title>
              <publisher>
                <publishername>
                    Ph.D. Thesis, University of Auckland, New Zealand
                </publishername>
              </publisher>
              <pubdate>2003</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>BENNETT CIKK</abbrev>
              <authorgroup>
                <author><firstname>Charles H.</firstname><surname>Bennett</surname></author>
              </authorgroup>
              <title>On Random and Hard-to-Describe Numbers</title>
              <publisher>
                <publishername>
                    <ulink url="http://citeseer.ist.psu.edu/429077.html">http://citeseer.ist.psu.edu/429077.html</ulink>
                </publishername>
              </publisher>
              <pubdate>1979</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>VITÁNYI KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Ming</firstname><surname>Li</surname></author>
                <author><firstname>Paul</firstname><surname>Vitányi</surname></author>
              </authorgroup>
              <title>An Introduction to Kolmogorov Complexity and its Applications</title>
              <publisher>
                <publishername>Springer</publishername>
              </publisher>
              <pubdate>1993</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>VITÁNYI HASONLÓSÁG CIKK</abbrev>
              <authorgroup>
                <author><firstname>Xin</firstname><surname>Chen</surname></author>
                <author><firstname>Xin</firstname><surname>Li</surname></author>
                <author><firstname>Bin</firstname><surname>Ma</surname></author>
                <author><firstname>Paul</firstname><surname>Vitányi</surname></author>
              </authorgroup>
              <title>The Similarity Metric</title>
              <publisher>
                <publishername>IEEE Transactions on Information Theory
                    <ulink url="http://www.cwi.nl/~paulv/papers/similarity.pdf">http://www.cwi.nl/~paulv/papers/similarity.pdf</ulink>
                    <ulink url="http://arxiv.org/abs/cs.CC/0111054">http://arxiv.org/abs/cs.CC/0111054</ulink>                    
                </publishername>
              </publisher>
              <volumenum>50</volumenum>
              <issuenum>12</issuenum>              
              <pubdate>2004</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>TURING CIKK</abbrev>
              <authorgroup>
                <author><firstname>Alan</firstname><surname>Turing</surname></author>
              </authorgroup>
              <title>On computable numbers, with an application to the Entscheidungsproblem</title>
              <publisher>
                <publishername>Proceedings of the London Mathematical Society
                    <ulink url="http://web.comlab.ox.ac.uk/oucl/research/areas/ieg/e-library/sources/tp2-ie.pdf">http://web.comlab.ox.ac.uk/oucl/research/areas/ieg/e-library/sources/tp2-ie.pdf</ulink>                    
                </publishername>
              </publisher>
              <volumenum>2</volumenum>
              <issuenum>42</issuenum>              
              <pubdate>1936</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>TURING GÉP REPREZENTÁCIÓ</abbrev>
              <authorgroup>
                <author><firstname>István</firstname><surname>Juhász</surname></author>
                <author><firstname>Ferenc</firstname><surname>Szalai</surname></author>
              </authorgroup>
              <title>Turing gép az általános iskolában</title>
              <publisher>
                <publishername>Frey Tamás Vándorgyűlés, Kecskemét.</publishername>                    
              </publisher>
			  <pubdate>1989</pubdate>              
            </biblioentry>
                       
            <biblioentry>
              <abbrev>DRAGÁLIN KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Albert</firstname><surname>Dragálin</surname></author>
                <author><firstname>Szvetlána</firstname><surname>Búzási</surname></author>
              </authorgroup>
              <title>Bevezetés a matematikai logikába</title>
              <publisher>
                <publishername>Kossuth Egyetemi Kiadó</publishername>
              </publisher>
              <pubdate>1996</pubdate>
            </biblioentry>            
                        
            <biblioentry>
              <abbrev>MOBIL JÁTÉK ÉLMÉNY</abbrev>
              <authorgroup>
                <author><firstname>Norbert</firstname><surname>Bátfai</surname></author>
                <author><firstname>Erika</firstname><surname>Bátfai</surname></author>
              </authorgroup>
              <title>A mobil játékfejlesztés elméleti és gyakorlati momentumai</title>
              <publisher>
                <publishername>Híradástechnika</publishername>
              </publisher>
              <volumenum>LX</volumenum>
              <pagenums>34-36</pagenums>
              <pubdate>2005/5</pubdate>
            </biblioentry>
                        
            <biblioentry>
              <abbrev>BENCZÚR CIKK</abbrev>
              <authorgroup>
                <author><firstname>András</firstname><surname>Benczúr</surname></author>
              </authorgroup>
              <title>The Evolution of Human Communication and the
              Information Revolution - A Mathematical Perspective</title>
              <publisher>
                <publishername>Mathematical and Computer Modeling</publishername>
              </publisher>
              <volumenum>38</volumenum>
              <pagenums>691-708</pagenums>
              <pubdate>2003</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>SHANNON INFÓELM CIKK</abbrev>
              <authorgroup>
                <author><firstname>C. E.</firstname><surname>Shannon</surname></author>
              </authorgroup>
              <title>A Mathematical Theory of Communication</title>
              <publisher>
                <publishername>The Bell System Tech. Journal
                    <ulink url="http://cm.bell-labs.com/cm/ms/what/shannonday/paper.html">http://cm.bell-labs.com/cm/ms/what/shannonday/paper.html</ulink>
                </publishername>
              </publisher>
              <volumenum>27</volumenum>
              <pagenums>379-423</pagenums>
              <pubdate>1984</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>DEMETROVICS KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>János</firstname><surname>Demetrovics</surname></author>
                <author><firstname>Denev</firstname><surname>Jordan</surname></author>
                <author><firstname>Pavlov</firstname><surname>Radiszlav</surname></author>
              </authorgroup>
              <title>A számítástudomány matematikai alapjai</title>
              <publisher>
                <publishername>Nemzeti Tankönyvkiadó</publishername>
              </publisher>
              <pubdate>1985</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>CHOMSKY NYELVOSZTÁLYOK</abbrev>
              <authorgroup>
                <author><firstname>Noam</firstname><surname>Chomsky</surname></author>
              </authorgroup>
              <title>Three Models For The Description of Language</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.chomsky.info/articles.htm">http://www.chomsky.info/articles.htm</ulink>
                </publishername>
              </publisher>
            </biblioentry>
            
        </bibliodiv>
                
        <bibliodiv>
            <title>Programozás</title>
            
            <biblioentry>
              <abbrev>PROGRAMOZÓ PÁTERNOSZTER JEGYZET</abbrev>
              <authorgroup>
                <author><firstname>Norbert</firstname><surname>Bátfai</surname></author>
              </authorgroup>
              <title>Programozó Pátermoszter jegyzet</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.javacska.hu/ProgramozoPaternoszter.pdf">http://www.javacska.hu/ProgramozoPaternoszter.pdf</ulink>                
                    <ulink url="http://www.inf.unideb.hu/~nbatfai/ProgramozoPaternoszter.pdf">http://www.inf.unideb.hu/~nbatfai/ProgramozoPaternoszter.pdf</ulink>                
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>PICI PROGRAMOZÁS I JEGYZET</abbrev>
              <authorgroup>
                <author><firstname>István</firstname><surname>Juhász</surname></author>
              </authorgroup>
              <title>Programozás 1 egyetemi jegyzet</title>
              <publisher>
                <publishername>
                    <ulink url="http://infotech.inf.unideb.hu/juhasz/">http://infotech.inf.unideb.hu/juhasz/</ulink>
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>PICI PROGRAMOZÁS II JEGYZET</abbrev>
              <authorgroup>
                <author><firstname>István</firstname><surname>Juhász</surname></author>
              </authorgroup>
              <title>Programozás 2 egyetemi jegyzet</title>
              <publisher>
                <publishername>
                    <ulink url="http://infotech.inf.unideb.hu/juhasz/">http://infotech.inf.unideb.hu/juhasz/</ulink>
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>PROGRAMOZÁS KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Judit</firstname><surname>Nyékyné Gaizler</surname></author>
              </authorgroup>
              <title>Programozási nyelvek</title>
              <publisher>
                <publishername>Kiskapu</publishername>
              </publisher>
              <pubdate>2003</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>LEVÉNEZ IDŐVONALAK</abbrev>
              <authorgroup>
                <author><firstname>Éric</firstname><surname>Lévénez</surname></author>
              </authorgroup>
              <title>Programming Languages</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.levenez.com/lang/">http://www.levenez.com/lang/</ulink>
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>SEBESTA KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Robert W.</firstname><surname>Sebesta</surname></author>
              </authorgroup>
              <title>Concepts of programming languages</title>
              <publisher>
                <publishername>The Benjamin/Cumming</publishername>
              </publisher>
              <pubdate>1993</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>SEBESTA ÚJ KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Robert W.</firstname><surname>Sebesta</surname></author>
              </authorgroup>
              <title>Concepts of programming languages</title>
              <publisher>
                <publishername>Addison-Wesley</publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>

            
            <biblioentry>
              <abbrev>JAVA ás C SHARP</abbrev>
              <authorgroup>
                <author><firstname>Shyamal Suhana</firstname><surname>Chandra</surname></author>
                <author><firstname>Kailash</firstname><surname>Chandra</surname></author>
              </authorgroup>
              <title>A comparison of Java and C Sharp</title>
              <publisher>
                <publishername>
                    Journal of Computing Sciences in Colleges
                    <ulink url="http://portal.acm.org/">http://portal.acm.org/</ulink>                                                            
                </publishername>
              </publisher>
              <volumenum>20</volumenum>
              <issuenum>3</issuenum>
              <pagenums>238-254</pagenums>
              <pubdate>2005</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>C SHARP J--</abbrev>
              <authorgroup>
                <author><firstname>Mark</firstname><surname>Johnson</surname></author>
              </authorgroup>
              <title>C Sharp: A language alternative or just J--?</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.javaworld.com/javaworld/jw-11-2000/jw-1122-csharp1.html">http://www.javaworld.com/javaworld/jw-11-2000/jw-1122-csharp1.html</ulink>                                        
                </publishername>
              </publisher>
              <pubdate>2000</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>.NET Framework SDK 2.0</abbrev>
              <title>.NET Framework Developer Center</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.microsoft.com/netframework">http://www.microsoft.com/netframework</ulink>                                        
                </publishername>
              </publisher>
            </biblioentry>                        

            <biblioentry>
              <abbrev>C SHARP ALAP KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Anders</firstname><surname>Hejlsberg</surname></author>
                <author><firstname>Scott</firstname><surname>Wiltamuth</surname></author>
                <author><firstname>Peter</firstname><surname>Golde</surname></author>
              </authorgroup>
              <title>The C Sharp Programming Language</title>
              <publisher>
                <publishername>Addison-Wesley</publishername>
              </publisher>
              <pubdate>2006</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>C SHARP KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Zoltán</firstname><surname>Illés</surname></author>
              </authorgroup>
              <title>Programozás C Sharp nyelven</title>
              <publisher>
                <publishername>Jedlik Oktatási Stúdió</publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>C SHARP KÖNYV 2</abbrev>
              <authorgroup>
                <author><firstname>Joseph</firstname><surname>Mayo</surname></author>
              </authorgroup>
              <title>C Sharp Unleashed</title>
              <publisher>
                <publishername>SAMS</publishername>
              </publisher>
              <pubdate>2002</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>C SHARP KÖNYV 3</abbrev>
              <authorgroup>
                <author><firstname>John</firstname><surname>Sharp</surname></author>
                <author><firstname>Jon</firstname><surname>Jagger</surname></author>
              </authorgroup>
              <title>Microsoft Visual C Sharp .NET</title>
              <publisher>
                <publishername>Microsoft Press</publishername>
              </publisher>
              <pubdate>2002</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>SOMMERVILLE KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Ian</firstname><surname>Sommerville</surname></author>
              </authorgroup>
              <title>Szoftverrendszerek fejlesztése</title>
              <publisher>
                <publishername>Panem</publishername>
              </publisher>
              <pubdate>2002</pubdate>
            </biblioentry>                        
            
        </bibliodiv>

        <bibliodiv>
            <title>Java programozás</title>

            <biblioentry>
              <abbrev>JAVA.SUN.COM</abbrev>
              <title>Java Technology</title>
              <publisher>
                <publishername>
                    <ulink url="http://java.sun.com">http://java.sun.com</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>JAVA.COM</abbrev>
              <title>java.com: Hot Games, Cool Apps</title>
              <publisher>
                <publishername>
                    <ulink url="http://java.com">http://java.com</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>
            
            <biblioentry>
              <abbrev>JAVA KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Judit</firstname><surname>Nyékyné Gaizler</surname></author>
              </authorgroup>
              <title>Java 2 útikalauz programozóknak</title>
              <publisher>
                <publishername>ELTE TTK Hallgatói Alapítvány</publishername>
              </publisher>
              <pubdate>2000</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>JAVA EE KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Judit</firstname><surname>Nyékyné Gaizler</surname></author>
              </authorgroup>
              <title>J2EE Útikalauz Java programozóknak</title>
              <publisher>
                <publishername>ELTE TTK Hallgatói Alapítvány</publishername>
              </publisher>
              <pubdate>2002</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>JAVA 5 KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Tony</firstname><surname>Gaddis</surname></author>
              </authorgroup>
              <title>Starting out with Java 5 Early Objects</title>
              <publisher>
                <publishername>Addison Wesley</publishername>
              </publisher>
              <pubdate>2005</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>KILLER KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Andrew</firstname><surname>Davison</surname></author>
              </authorgroup>
              <title>Killer Game Programming</title>
              <publisher>
                <publishername>O'Reilly</publishername>
              </publisher>
              <pubdate>2005</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>J2ME KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Vartan</firstname><surname>Piroumian</surname></author>
              </authorgroup>
              <title>Wireless J2ME Platform Programming</title>
              <publisher>
                <publishername>Prentice Hall</publishername>
              </publisher>
              <pubdate>2005</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>JAVA EE 5</abbrev>
              <authorgroup>
                <author><firstname>Eric</firstname><surname>Jendrock</surname></author>
                <author><firstname>et.</firstname><surname>al.</surname></author>
              </authorgroup>
              <title>The Java EE 5 Tutorial </title>
              <publisher>
                <publishername>
                    <ulink url="http://java.sun.com/javaee/5/docs/tutorial/doc">http://java.sun.com/javaee/5/docs/tutorial/doc</ulink>
                </publishername>
              </publisher>
              <pubdate>2006</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>JAVA JÁTÉK</abbrev>
              <authorgroup>
                <author><firstname>Doug</firstname><surname>Twilleager</surname></author>
                <author><firstname>Jeff</firstname><surname>Kesselman</surname></author>
                <author><firstname>Athomas</firstname><surname>Goldberg</surname></author>
                <author><firstname>Daniel</firstname><surname>Petersen</surname></author>
                <author><firstname>Juan Carlos</firstname><surname>Soto</surname></author>
                <author><firstname>Chris</firstname><surname>Melissinos</surname></author>
              </authorgroup>
              <title>Java Technologies for Games</title>
              <publisher>
                <publishername>ACM Computers in Entartainment
                    <ulink url="http://portal.acm.org">http://portal.acm.org</ulink>
                </publishername>
              </publisher>
              <volumenum>2</volumenum>
              <issuenum>2</issuenum>              
              <pubdate>2004</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>MIDP 2.0 JÁTÉKOK</abbrev>
              <authorgroup>
                <author><firstname>Qusay</firstname><surname>Mahmoud</surname></author>
              </authorgroup>
              <title>Getting Started With the MIDP 2.0 Game API</title>
              <publisher>
                <publishername>
                    <ulink url="http://developers.sun.com/techtopics/mobility/midp/articles/gameapi">http://developers.sun.com/techtopics/mobility/midp/articles/gameapi</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>
                        
            <biblioentry>
              <abbrev>JAVA PÉLDA WEBSZERVER</abbrev>
              <authorgroup>
                <author><firstname>David</firstname><surname>Brown</surname></author>
              </authorgroup>
              <title>A Simple Multithreaded Web Server</title>
              <publisher>
                <publishername>
                    <ulink url="http://java.sun.com/developer/technicalArticles/Networking/Webserver/index.html">http://java.sun.com/developer/technicalArticles/Networking/Webserver/index.html</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>
            
            <biblioentry>
              <abbrev>OAK</abbrev>
              <authorgroup>
                <author><firstname>Jon</firstname><surname>Byous</surname></author>
              </authorgroup>
              <title>Java Technology: the Early Years</title>
              <publisher>
                <publishername>
                    <ulink url="http://java.sun.com/features/1998/05/birthday.html">http://java.sun.com/features/1998/05/birthday.html</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>
            
            <biblioentry>
              <abbrev>JAVA MINDENÜTT</abbrev>
              <title>Java Everywhere</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.sun.com/java/everywhere">http://www.sun.com/java/everywhere</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>GOSLING INTERJÚ</abbrev>
              <authorgroup>
                <author><firstname>Robert</firstname><surname>Eckstein</surname></author>
              </authorgroup>
              <title>James Gosling on Open Sourcing Sun's Java Platform Implementations</title>
              <publisher>
                <publishername>
                    <ulink url="http://java.sun.com/developer/technical/Articles/Intervoews/gosling_os1_qa.html">http://java.sun.com/developer/technical/Articles/Intervoews/gosling_os1_qa.html</ulink>                                        
                </publishername>
              </publisher>
              <pubdate>2000</pubdate>
            </biblioentry>                        
            
            <biblioentry>
              <abbrev>HÁLÓZATI JAVA</abbrev>
              <authorgroup>
                <author><firstname>David</firstname><surname>Reilly</surname></author>
                <author><firstname>Michael</firstname><surname>Reilly</surname></author>
              </authorgroup>
              <title>Java Network Programming and Distributed Computing</title>
              <publisher>
                <publishername>Addison-Wesley</publishername>
              </publisher>
              <pubdate>2002</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>JAVA DOKUMENTÁCIÓ</abbrev>
              <title>JDK 6 Documentation</title>
              <publisher>
                <publishername>
                    <ulink url="http://java.sun.com/javase/6/download.jsp#docs">http://java.sun.com/javase/6/download.jsp#docs</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>SUN JAVA CIKKEK</abbrev>
              <title>Core Java Technologies Tech Tips</title>
              <publisher>
                <publishername>
                    <ulink url="http://java.sun.com/developer/JDCTechTips/">http://java.sun.com/developer/JDCTechTips/</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>SUN JAVA MOBIL CIKKEK</abbrev>
              <title>J2ME Technical Articles and Tips</title>
              <publisher>
                <publishername>
                    <ulink url="http://developers.sun.com/techtopics/mobility/reference/techart/index.html">http://developers.sun.com/techtopics/mobility/reference/techart/index.html</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>
            
            <biblioentry>
              <abbrev>FORUM NOKIA CIKKEK</abbrev>
              <title>Forum Nokia - resources for mobile application developers</title>
              <publisher>
                <publishername>
                    <ulink url="http://forum.nokia.com/">http://forum.nokia.com/</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>MOBIL PROG EA</abbrev>
              <authorgroup>
                <author><firstname>Norbert</firstname><surname>Bátfai</surname></author>
              </authorgroup>
              <title>A mobil játékfejlesztés elméleti és gyakorlati momentumai</title>
              <publisher>
                <publishername>Gyires Béla Informatikai Nap, Debrecen
                    <ulink url="http://www.inf.unideb.hu/kutatas/gybin/gybin04/Batfai_Norbert.pdf">http://www.inf.unideb.hu/kutatas/gybin/gybin04/Batfai_Norbert.pdf</ulink>
                </publishername>                    
              </publisher>
			  <pubdate>2005</pubdate>
            </biblioentry>
            
            <biblioentry>
              <abbrev>MOBIL PROG SUN EA</abbrev>
              <authorgroup>
                <author><firstname>Norbert</firstname><surname>Bátfai</surname></author>
                <author><firstname>Erika</firstname><surname>Bátfai</surname></author>
              </authorgroup>
              <title>A Java mobiljáték-fejlesztés elmélete és gyakorlata és a kék (JSR 82) játékok</title>
              <publisher>
                <publishername>5. Sun Java Fejlesztői Nap, Budapest</publishername>                    
              </publisher>
			  <pubdate>2005</pubdate>              
            </biblioentry>

            <biblioentry>
              <abbrev>JAVA START</abbrev>
              <authorgroup>
                <author><firstname>Csaba</firstname><surname>Vég</surname></author>
                <author><firstname>István</firstname><surname>Juhász</surname></author>
              </authorgroup>
              <title>Java Start!</title>
              <publisher>
                <publishername>Logos 2000</publishername>
              </publisher>
              <pubdate>1999</pubdate>
            </biblioentry>            

        </bibliodiv>
                
        <bibliodiv>
            <title>Hálózatok, internet</title>
            
            <biblioentry>
              <abbrev>HÁLÓZATOK KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Andrew S.</firstname><surname>Tanenbaum</surname></author>
              </authorgroup>
              <title>Számítógép-hálózatok</title>
              <publisher>
                <publishername>Panem</publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>HÁLÓZATOS JAVA KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Balázs</firstname><surname>Csizmazia</surname></author>
              </authorgroup>
              <title>Hálózati alkalmazások készítése : CORBA, Java, WWW</title>
              <publisher>
                <publishername>Kalibán BT</publishername>
              </publisher>
              <pubdate>1998</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>CORBA SPECIFIKÁCIÓ</abbrev>
              <title>CORBA</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.omg.org/technology/documents/formal/corba_iiop.htm">http://www.omg.org/technology/documents/formal/corba_iiop.htm</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>COSNAMING IDL</abbrev>
              <title>cosnaming.idl</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.omg.org/docs/formal/04-10-07.txt">http://www.omg.org/docs/formal/04-10-07.txt</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>NYELVI LEKÉPEZÉS</abbrev>
              <title>Catalog of OMG IDL / Language Mappings Specifications</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.omg.org/technology/documents/idl2x_spec_catalog.htm">http://www.omg.org/technology/documents/idl2x_spec_catalog.htm</ulink>
                    <ulink url="http://www.omg.org/docs/formal/02-08-05.pdf">http://www.omg.org/docs/formal/02-08-05.pdf</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>
            
            <biblioentry>
              <abbrev>INTERNET REGULATION</abbrev>
              <authorgroup>
                <author><firstname>David</firstname><surname>Clark</surname></author>
              </authorgroup>
              <title>Social Protocols, Design Principles, and Analytic Methods</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.w3.org/Talks/1999/0105-Regulation/all.htm">http://www.w3.org/Talks/1999/0105-Regulation/all.htm</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>PORTOK</abbrev>
              <title>IANA port assignments</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.iana.org/assignments/port-numbers">http://www.iana.org/assignments/port-numbers</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>RFC</abbrev>
              <title>Request for Comments</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.ietf.org/rfc">http://www.ietf.org/rfc</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>RFC 822</abbrev>
              <title>STANDARD FOR THE FORMAT OF ARPA INTERNET TEXT MESSAGES</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.ietf.org/rfc">http://www.ietf.org/rfc</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>RFC 2616</abbrev>
              <title>Hypertext Transfer Protocol - HTTP/1.1</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.ietf.org/rfc">http://www.ietf.org/rfc</ulink>
                </publishername>                    
              </publisher>
            </biblioentry>
            
        </bibliodiv>        
        
        <bibliodiv>
            <title>Máselvű programozás</title>

            <biblioentry>
              <abbrev>DES TÖRÉS</abbrev>
              <authorgroup>
                <author><firstname>Dan</firstname><surname>Boneh</surname></author>
              </authorgroup>
              <title>Breaking DES Using a Molecular Computer</title>
              <publisher>
                <publishername>
                    <ulink url="http://citeseer.ist.psu.edu/boneh95breaking.html">http://citeseer.ist.psu.edu/boneh95breaking.html</ulink>
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>DNA SZÁMÍTÁS</abbrev>
              <authorgroup>
                <author><firstname>Leonard M.</firstname><surname>Adleman</surname></author>
              </authorgroup>
              <title>Molecular Computation Of Solutions To Combinatorial Problems</title>
              <publisher>
                <publishername>
                    <ulink url="http://citeseer.ist.psu.edu/adleman94molecular.html">http://citeseer.ist.psu.edu/adleman94molecular.html</ulink>
                </publishername>
              </publisher>
            </biblioentry>
                        
        </bibliodiv>
                
        <bibliodiv>
            <title>Kvantum számítások</title>

            <biblioentry>
              <abbrev>ORCH OR</abbrev>
              <authorgroup>
                <author><firstname>Stuart</firstname><surname>Hameroff</surname></author>
                <author><firstname>Roger</firstname><surname>Penrose</surname></author>
              </authorgroup>
              <title>Orchestrated Objective Reduction of Quantum Coherence in Brain Microtubules: 
              The <quote>Orch OR</quote> Model for Consciousmess</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.quantumconsciousness.org/penrose-hameroff/orchOR.html">http://www.quantumconsciousness.org/penrose-hameroff/orchOR.html</ulink>
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>ORCH OR TUDAT</abbrev>
              <authorgroup>
                <author><firstname>Stuart</firstname><surname>Hameroff</surname></author>
                <author><firstname>Roger</firstname><surname>Penrose</surname></author>
              </authorgroup>
              <title>Conscious Events as Orchestrated Space-Time Selections</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.quantumconsciousness.org/penrose-hameroff/consciousevents.html">http://www.quantumconsciousness.org/penrose-hameroff/consciousevents.html</ulink>
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>TEGMARK DEKOHERENCIA CIKK</abbrev>
              <authorgroup>
                <author><firstname>M.</firstname><surname>Tegmark</surname></author>
              </authorgroup>
              <title>Importance of quantum decoherence in brain processes</title>
              <publisher>
                <publishername>
                    Physical Review E.
                    <ulink url="http://prola.aps.org/abstract/PRE/v61/i4/p4194_1">http://prola.aps.org/abstract/PRE/v61/i4/p4194_1</ulink>                                                            
                </publishername>
              </publisher>
              <volumenum>65</volumenum>
              <pubdate>2002</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>TEGMARK DEKOHERENCIA VÁLASZ CIKK</abbrev>
              <authorgroup>
                <author><firstname>Stuart R.</firstname><surname>Hameroff</surname></author>
              </authorgroup>
              <title>Quantum computation in brain microtubules: Decoherence
              and biological feasibility</title>
              <publisher>
                <publishername>
                    Physical Review E.
                    <ulink url="http://prola.aps.org/abstract/PRE/v65/i6/e061901">http://prola.aps.org/abstract/PRE/v65/i6/e061901</ulink>                                                            
                    <ulink url="http://arxiv.org/abs/quant-ph/0005025">http://arxiv.org/abs/quant-ph/0005025</ulink>
                </publishername>
              </publisher>
              <volumenum>65</volumenum>
              <pubdate>2002</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>VÉLETLEN MŰSZER</abbrev>
              <title>Quantum Random Numbers Generator</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.gapoptic.unige.ch/Prototypes/QRNG/">http://www.gapoptic.unige.ch/Prototypes/QRNG/</ulink>
                </publishername>
              </publisher>
            </biblioentry>
            
            <biblioentry>
              <abbrev>KVANTUM TUDAT</abbrev>
              <authorgroup>
                <author><firstname>Harald</firstname><surname>atmanspacher</surname></author>
              </authorgroup>
              <title>Quantum Theory and Consciousness: an Overview with Selected Examples</title>
              <volumenum>1</volumenum>
              <publisher>
                <publishername>
                    Discrete Dynamics in Nature and Society
                    <ulink url="http://www.hindawi.com/GetArticle.aspx?doi=10.1155/S102602260440106X">http://www.hindawi.com/GetArticle.aspx?doi=10.1155/S102602260440106X</ulink>
                </publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>DEUTSCH KVANTUMGÉP CIKK</abbrev>
              <authorgroup>
                <author><firstname>David</firstname><surname>Deutsch</surname></author>
              </authorgroup>
              <title>Quantum theory, the Church-Turing principle and the universal quantum computer</title>
              <publisher>
                <publishername>
                    Proceedings of the Royal Society of London A
                    <ulink url="http://citeseer.ist.psu.edu/deutsch85quantum.html">http://citeseer.ist.psu.edu/deutsch85quantum.html</ulink>
                    </publishername>
              </publisher>
              <volumenum>400</volumenum>
              <pagenums>97-117</pagenums>              
              <pubdate>1985</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>KVANTUMINFORMATIKA</abbrev>
              <authorgroup>
                <author><firstname>Kornél</firstname><surname>Sailer</surname></author>
              </authorgroup>
              <title>Kvantuminformatika</title>
              <publisher>
                <publishername>
                    <ulink url="http://dtp.atomki.hu/HOME-PAGE/lectures/kvinfl.pdf">http://dtp.atomki.hu/HOME-PAGE/lectures/kvinfl.pdf</ulink> 
                    <ulink url="http://dtp.science.unideb.hu/hun/jegyzetek.php">http://dtp.science.unideb.hu/hun/jegyzetek.php</ulink>                                                            
                </publishername>
              </publisher>
              <pubdate>1985</pubdate>
            </biblioentry>            

        </bibliodiv>
        
        <bibliodiv>
            <title>Biológiai jellegű</title>
        
            <biblioentry>
              <abbrev>GÉP és AGY</abbrev>
              <authorgroup>
                <author><firstname>János</firstname><surname>Neumann</surname></author>
              </authorgroup>
              <title>A számológép és az agy</title>
              <publisher>
                <publishername>Gondolat</publishername>
              </publisher>
              <pubdate>1964</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>HAMEROFF MIKROTUBULUS</abbrev>
              <authorgroup>
                <author><firstname>Stuart R.</firstname><surname>Hameroff</surname></author>
                <author><firstname>Richard C.</firstname><surname>Watt</surname></author>
              </authorgroup>
              <title>Information Processing in Microtubules</title>
              <publisher>
                <publishername>
                    Journal of Theoretical Biology
                    <ulink url="http://www.ncbi.nlm.nih.gov/entrez/">http://www.ncbi.nlm.nih.gov/entrez/</ulink>                                                            
                </publishername>
              </publisher>
              <volumenum>98</volumenum>
              <pagenums>549-561</pagenums>
              <pubdate>1982</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>HAMEROFF INTERJÚ</abbrev>
              <authorgroup>
                <author><firstname>Stuart R.</firstname><surname>Hameroff</surname></author>
                <author><firstname>Liane</firstname><surname>Gabora</surname></author>
              </authorgroup>
              <title>Microtubules, Anesthetics, and Quantum Consciousness: An
              Interview with Stuart Hameroff</title>
              <publisher>
                <publishername>
                    Foundations of Science
                    <ulink url="http://www.springerlink.com/index/X55154J16754W370.pdf">http://www.springerlink.com/index/X55154J16754W370.pdf</ulink>                                                            
                </publishername>
              </publisher>
              <volumenum>4</volumenum>
              <pagenums>205-223</pagenums>
              <pubdate>1999</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>HANGYÁK és KOLMOGOROV CIKK</abbrev>
              <authorgroup>
                <author><firstname>Boris</firstname><surname>Ryabko</surname></author>
                <author><firstname>Zhanna</firstname><surname>Reznikova</surname></author>
              </authorgroup>
              <title>Using Shannon Entropy and Kolmogorov Complexity To
              Study the Communicative System and Cognitive Capacities in Ants</title>
              <publisher>
                <publishername>
                    <ulink url="http://boris.ryabko.net/papers.html">http://boris.ryabko.net/papers.html</ulink>                    
                </publishername>
              </publisher>
            </biblioentry>                                    

            <biblioentry>
              <abbrev>C. ELEGANS</abbrev>
              <authorgroup>
                <author><firstname>Hiroaki</firstname><surname>Kitano</surname></author>
                <author><firstname>Shugo</firstname><surname>Hamahashi</surname></author>
                <author><firstname>Jun</firstname><surname>Kitazawa</surname></author>
                <author><firstname>Sean</firstname><surname>Luke</surname></author>
              </authorgroup>
              <title>The Perfect C. elegans Project: An Initial Report</title>
              <publisher>
                <publishername>                    
                    <ulink url="http://citeseer.ist.psu.edu/120528.html">http://citeseer.ist.psu.edu/120528.html</ulink>                                                            
                </publishername>
              </publisher>
              <!--
              <volumenum></volumenum>
              <pagenums></pagenums>
              <pubdate></pubdate>
				-->
            </biblioentry>                        

            <biblioentry>
              <abbrev>UniProtKB/Swiss-Prot</abbrev>
              <title>ExPASy Proteomics Server</title>
              <publisher>
                <publishername>                    
                    <ulink url="http://www.expasy.org">http://www.expasy.org</ulink>
                </publishername>
              </publisher>
              <!--
              <volumenum></volumenum>
              <pagenums></pagenums>
              <pubdate></pubdate>
				-->
            </biblioentry>                        

            <biblioentry>
              <abbrev>HUMÁN GENOM PROJEKT</abbrev>
              <title>Humán Genom Projekt</title>
              <publisher>
                <publishername>                    
                    <ulink url="http://www.ncbi.nlm.nih.gov/genome/seq">http://www.ncbi.nlm.nih.gov/genome/seq</ulink>
                </publishername>
              </publisher>
              <!--
              <volumenum></volumenum>
              <pagenums></pagenums>
              <pubdate></pubdate>
				-->
            </biblioentry>                        

            <biblioentry>
              <abbrev>SEJTBIO 1</abbrev>
              <authorgroup>
                <author><firstname>György</firstname><surname>Csaba</surname></author>
              </authorgroup>
              <title>Sejtbiológia</title>
              <publisher>
                <publishername>Medicina</publishername>
              </publisher>
              <pubdate>1990</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>SEJTBIO 2</abbrev>
              <authorgroup>
                <author><firstname>József</firstname><surname>Szeberényi</surname></author>
              </authorgroup>
              <title>Molekuláris sejtbiológia</title>
              <publisher>
                <publishername>Dialóg Campus</publishername>
              </publisher>
              <pubdate>1999</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>MIKROTUBULUS 1</abbrev>
              <authorgroup>
                <author><firstname>Ioannis G.</firstname><surname>Karafyllidis</surname></author>
                <author><firstname>Dimitris C.</firstname><surname>Lagoudas</surname></author>
              </authorgroup>
              <title>Microtubules as mechanical force sensors</title>
              <publisher>
                <publishername>BioSystems
                    <ulink url="http://www.ncbi.nlm.nih.gov/entrez">http://www.ncbi.nlm.nih.gov/entrez</ulink>
                    PMID: 16806669
                </publishername>
              </publisher>
              <pubdate>2006</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>BIOINFORMATIKA</abbrev>
              <authorgroup>
                <author><firstname>Péter</firstname><surname>Maróti</surname></author>
              </authorgroup>
              <title>Információelmélet a biológiában</title>
              <publisher>
                <publishername>JATEPress</publishername>
              </publisher>
              <pubdate>2003</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>PROTEOMIKA</abbrev>
              <authorgroup>
                <author><firstname>A. Malcolm</firstname><surname>Campbell</surname></author>
                <author><firstname>Laurie J.</firstname><surname>Heyer</surname></author>
              </authorgroup>
              <title>Genomika, proteomika, bioinformatika</title>
              <publisher>
                <publishername>Medicina</publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>GONDOLKODÓ KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>William H.</firstname><surname>Calvin</surname></author>
              </authorgroup>
              <title>A gondolkodó agy</title>
              <publisher>
                <publishername>Kulturtrade</publishername>
              </publisher>
              <pubdate>1996</pubdate>
            </biblioentry>            
                        
        </bibliodiv>
        
        <bibliodiv>
            <title>Matematikai jellegű</title>          

            <biblioentry>
              <abbrev>KNUTH 2. KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Donald E.</firstname><surname>Knuth</surname></author>
              </authorgroup>
              <title>A számítógép programozás művészete 2.</title>
              <publisher>
                <publishername>Műszaki</publishername>
              </publisher>
              <pubdate>1994</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>MATEK JÁTÉK</abbrev>
              <authorgroup>
                <author><firstname>Béla</firstname><surname>Csákány</surname></author>
              </authorgroup>
              <title>Diszkrét matematikai játékok</title>
              <publisher>
                <publishername>Polygon</publishername>
              </publisher>
              <pagenums>171-173</pagenums>
              <pubdate>1998</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>ÉLET CIKK</abbrev>
              <authorgroup>
                <author><firstname>Robert T.</firstname><surname>Wainwright</surname></author>
              </authorgroup>
              <title>Life is Universal</title>
              <publisher>
                <publishername>
                    <ulink url="http://portal.acm.org/citation.cfm?id=800290.811303">http://portal.acm.org/citation.cfm?id=800290.811303</ulink>                    
                </publishername>
              </publisher>
              <pubdate>1974</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>VÉLETLEN VÉLETLEN</abbrev>
              <authorgroup>
                <author><firstname>Pál</firstname><surname>Révész</surname></author>
              </authorgroup>
              <title>Mennyire véletlen a véletlen?</title>
              <publisher>
                <publishername>Akadémiai</publishername>
              </publisher>
              <pagenums>14</pagenums>
              <pubdate>1984</pubdate>
            </biblioentry>                                    
            
            <biblioentry>
              <abbrev>VÉLETLEN KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>István</firstname><surname>Deák</surname></author>
              </authorgroup>
              <title>Véletlenszám generátorok és alkalmazásuk</title>
              <publisher>
                <publishername>Akadémiai</publishername>
              </publisher>
              <pubdate>1986</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>BARNSLEY KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>M.</firstname><surname>Barnsley</surname></author>
              </authorgroup>
              <title>Fractals everywhere</title>
              <publisher>
                <publishername>Academic Press, Boston</publishername>
              </publisher>
              <pubdate>1986</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>FRAKT. SZAKDOLG.</abbrev>
              <authorgroup>
                <author><firstname>Norbert</firstname><surname>Bátfai</surname></author>
              </authorgroup>
              <title>Szimultán számrendszerekkel generált fraktálok ábrázolása</title>
              <publisher>
                <publishername>KLTE szakdolgozat, témavezető Boros Zoltán</publishername>
              </publisher>
              <pubdate>1996</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>PI KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>J. Lennart</firstname><surname>Berggren</surname></author>
                <author><firstname>Jonathan M.</firstname><surname>Borwein</surname></author>
                <author><firstname>Peter B.</firstname><surname>Borwein</surname></author>
              </authorgroup>
              <title>A Pamphlet on Pi serving as a Supplement for the
              Third Edition of Pi: A Source Book</title>
              <publisher>
                <publishername>
                    <ulink url="http://citeseer.ist.psu.edu/589901.html">http://citeseer.ist.psu.edu/589901.html</ulink>                    
                </publishername>
              </publisher>
              <pubdate>2003</pubdate>
            </biblioentry>            

            <biblioentry>
              <abbrev>PI SZÁMÍTÁS</abbrev>
              <authorgroup>
                <author><firstname>David H.</firstname><surname>Bailey</surname></author>
                <author><firstname>Peter B.</firstname><surname>Borwein</surname></author>
                <author><firstname>Simon</firstname><surname>Plouffe</surname></author>
              </authorgroup>
              <title>On The Rapid Computation of Various Polylogarithmic Constants</title>
              <publisher>
                <publishername>Mathematics of Computation
                    <ulink url="http://citeseer.ist.psu.edu/bailey96rapid.html">http://citeseer.ist.psu.edu/bailey96rapid.html</ulink>
                </publishername>
              </publisher>
              <volumenum>66</volumenum>
              <issuenum>218</issuenum>              
              <pagenums>903-913</pagenums>              
              <pubdate>1997</pubdate>
            </biblioentry>                                    
            
            <biblioentry>
              <abbrev>PI KÜLDETÉS</abbrev>
              <authorgroup>
                <author><firstname>David H.</firstname><surname>Bailey</surname></author>
                <author><firstname>Jonathan M.</firstname><surname>Borwein</surname></author>
                <author><firstname>Peter B.</firstname><surname>Borwein</surname></author>
                <author><firstname>Simon</firstname><surname>Plouffe</surname></author>
              </authorgroup>
              <title>The Quest for Pi</title>
              <publisher>
                <publishername>Mathematical Intelligencer
                    <ulink url="http://citeseer.ist.psu.edu/bailey96quest.html">http://citeseer.ist.psu.edu/bailey96quest.html</ulink>
                </publishername>
              </publisher>
              <volumenum>19</volumenum>
              <issuenum>1</issuenum>              
              <pagenums>50-57</pagenums>              
              <pubdate>1996</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>BBP ALGORITMUS</abbrev>
              <authorgroup>
                <author><firstname>David H.</firstname><surname>Bailey</surname></author>
              </authorgroup>
              <title>The BBP Algorithm for Pi</title>
              <publisher>
                <publishername>
                    <ulink url="http://crd.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf">http://crd.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf</ulink>                    
                </publishername>
              </publisher>
              <pubdate>2006</pubdate>
            </biblioentry>                                    

            <biblioentry>
              <abbrev>NEUMANN KVANTUM KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>János</firstname><surname>Neumann</surname></author>
              </authorgroup>
              <title>A kvantummechanika matematikai alapjai</title>
              <publisher>
                <publishername>Akadémiai</publishername>
              </publisher>
              <pubdate>1980</pubdate>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>RÉNYI VALSÉG KÖNYV</abbrev>
              <authorgroup>
                <author><firstname>Alfréd</firstname><surname>Rényi</surname></author>
              </authorgroup>
              <title>Valószínűségszámítás</title>
              <publisher>
                <publishername>Tankönyvkiadó</publishername>
              </publisher>
              <pagenums>144</pagenums>
              <pubdate>1973</pubdate>
            </biblioentry>                        
            
        </bibliodiv>                
        
        <bibliodiv>
            <title>Informatika gyerekeknek, diákoknak</title>

            <biblioentry>
              <abbrev>JÁVÁCSKA BARÁTAI</abbrev>
              <authorgroup>
                <author><firstname>Norbert</firstname><surname>Bátfai</surname></author>
              </authorgroup>
              <title>Jávácska Barátai, Gyermek - Robot Barátság</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.javacska.hu">http://www.javacska.hu</ulink>
                </publishername>
              </publisher>
            </biblioentry>            

            <biblioentry>
              <abbrev>JÁVÁCSKA PORTÁL</abbrev>
              <authorgroup>
                <author><firstname>Norbert</firstname><surname>Bátfai</surname></author>
                <author><firstname>Erika</firstname><surname>Bátfai</surname></author>
              </authorgroup>
              <title>Jávácska Portál</title>
              <publisher>
                <publishername>
                    <ulink url="http://javacska.lib.unideb.hu">http://javacska.lib.unideb.hu</ulink>
                </publishername>
              </publisher>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>II. JÁVÁCSKA</abbrev>
              <authorgroup>
                <author><firstname></firstname><surname></surname></author>
              </authorgroup>
              <title>II. Jávácska Konferencia</title>
              <publisher>
                <publishername>
                    <ulink url="http://javacska.lib.unideb.hu/konf2">http://javacska.lib.unideb.hu/konf2</ulink>
                </publishername>
              </publisher>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>TANÁRKÉPZÉS EA.</abbrev>
              <authorgroup>
                <author><firstname>Norbert</firstname><surname>Bátfai</surname></author>
                <author><firstname>Erika</firstname><surname>Bátfai</surname></author>
              </authorgroup>
              <title>Jávácska és az informatika tanárképzés</title>
              <publisher>
                <publishername>
                    <ulink url="http://javacska.lib.unideb.hu/ea/IF_2005/Javacska_InfoTanarkepzes_If2005.pdf">http://javacska.lib.unideb.hu/ea/IF_2005/Javacska_InfoTanarkepzes_If2005.pdf</ulink>
                </publishername>
              </publisher>
            </biblioentry>            

            <biblioentry>
              <abbrev>FANTASZTIKUS PROGRAMOZÁS</abbrev>
              <authorgroup>
                <author><firstname>Norbert</firstname><surname>Bátfai</surname></author>
                <author><firstname>Erika</firstname><surname>Bátfai</surname></author>
              </authorgroup>
              <title>Fantasztikus programozás</title>
              <publisher>
                <publishername>Debreceni Egyetem Egyetemi és Nemzeti Könyvtár 
                    <ulink url="http://javacska.lib.unideb.hu/konyv/bv-naploja-kezirat-I-5_0_0.pdf">http://javacska.lib.unideb.hu/konyv/bv-naploja-kezirat-I-5_0_0.pdf</ulink>
                </publishername>                
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>                        

            <biblioentry>
              <abbrev>LEGO MINDSTORMS</abbrev>
              <title>LEGO.com  MINDSTORMS NXT Home</title>
              <publisher>
                <publishername>
                    <ulink url="http://mindstorms.lego.com/">http://mindstorms.lego.com/</ulink>
                </publishername>
              </publisher>
            </biblioentry>

            <biblioentry>
              <abbrev>LEJOS JAVA</abbrev>
              <title>leJOS - Java for Lego Mindstorms</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.lejos.org">http://www.lejos.org</ulink>
                    <ulink url="http://lejos.sourceforge.net/">http://lejos.sourceforge.net/</ulink>
                </publishername>
              </publisher>
            </biblioentry>
            
            <biblioentry>
              <abbrev>LEGO és NI</abbrev>
              <title>LEGO MINDSTORMS NXT - Powered by NI LabVIEW</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.ni.com/academic/mindstorms/">http://www.ni.com/academic/mindstorms/</ulink>
                </publishername>
              </publisher>
            </biblioentry>
            
        </bibliodiv>
        
        <bibliodiv>
            <title>Tudományos közösségek és szórakoztató ismeretterjesztés</title>

            <biblioentry>
              <abbrev>KAPCSOLAT MOZI</abbrev>
              <authorgroup>
                <author><firstname>Robert</firstname><surname>Zemeckis</surname></author>
              </authorgroup>
              <title>Contact</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.imdb.com/title/tt0118884/ ">http://www.imdb.com/title/tt0118884/ </ulink>
                </publishername>
              </publisher>
              <pubdate>1997</pubdate>
            </biblioentry>
                        
            <biblioentry>
              <abbrev>KAPCSOLAT REGÉNY</abbrev>
              <authorgroup>
                <author><firstname>Carl</firstname><surname>Sagan</surname></author>
              </authorgroup>
              <title>Kapcsolat</title>
              <publisher>
                <publishername>Édesvíz</publishername>
              </publisher>
              <pubdate>1993</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>SETI HOME</abbrev>
              <title>SETI@home</title>
              <publisher>
                <publishername>
                    <ulink url="http://setiathome.ssl.berkeley.edu">http://setiathome.ssl.berkeley.edu</ulink>
                </publishername>
              </publisher>
            </biblioentry>            
            
            <biblioentry>
              <abbrev>ASIMOV REGÉNY</abbrev>
              <authorgroup>
                <author><firstname>Isaac</firstname><surname>Asimov</surname></author>
              </authorgroup>
              <title>Én, a robot</title>
              <publisher>
                <publishername>Szukits</publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>ASIMOV MOZI</abbrev>
              <authorgroup>
                <author><firstname>Alex</firstname><surname>Proyas</surname></author>
              </authorgroup>
              <title>Én, a robot</title>
              <publisher>
                <publishername>
                    <ulink url="http://www.imdb.com/title/tt0343818/">http://www.imdb.com/title/tt0343818/</ulink>                    
                </publishername>
              </publisher>
              <pubdate>2004</pubdate>
            </biblioentry>            

        </bibliodiv>        

        <bibliodiv>
            <title>A szokásos paradigmákon túl</title>

            <biblioentry>
              <abbrev>KVANTUM JÓGA</abbrev>
              <authorgroup>
                <author><firstname>Amit</firstname><surname>Goswami</surname></author>
              </authorgroup>
              <title>Képzelt ablak</title>
              <publisher>
                <publishername>Édesvíz</publishername>
              </publisher>
              <pubdate>2005</pubdate>
            </biblioentry>

            <biblioentry>
              <abbrev>PROGRAMOZOTT VÍZ</abbrev>
              <authorgroup>
                <author><firstname>Masaru</firstname><surname>Emoto</surname></author>
              </authorgroup>
              <title>A víz rejtett bölcsessége</title>
              <publisher>
                <publishername>Édesvíz</publishername>
              </publisher>
              <pubdate>2005</pubdate>
            </biblioentry>
                        
        </bibliodiv>
        
        <bibliodiv>
            <title>Általános</title>

            <biblioentry>
              <abbrev>WIKI</abbrev>
              <authorgroup>
                <author><firstname></firstname><surname></surname></author>
              </authorgroup>
              <title>Wikipedia, the free encyclopedia</title>
              <publisher>
                <publishername>
                    <ulink url="http://en.wikipedia.org">Wikipedia</ulink>
                </publishername>
              </publisher>
            </biblioentry>
                        
        </bibliodiv>
        
    </bibliography>
        
</book>
